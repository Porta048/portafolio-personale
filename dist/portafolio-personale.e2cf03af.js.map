{"mappings":"AIMA,MAEM,EAAM,KAAK,GAAG,CACd,EAAM,KAAK,GAAG,CACd,EAAQ,KAAK,KAAK,CAElB,EAAe,AAAA,GAAM,CAAA,CACzB,EAAG,EACH,EAAG,CACL,CAAA,EACM,EAAkB,CACtB,KAAM,QACN,MAAO,OACP,OAAQ,MACR,IAAK,QACP,EACM,EAAuB,CAC3B,MAAO,MACP,IAAK,OACP,EAIA,SAAS,EAAS,CAAK,CAAE,CAAK,EAC5B,MAAO,AAAiB,YAAjB,OAAO,EAAuB,EAAM,GAAS,CACtD,CACA,SAAS,EAAQ,CAAS,EACxB,OAAO,EAAU,KAAK,CAAC,IAAI,CAAC,EAAE,AAChC,CACA,SAAS,EAAa,CAAS,EAC7B,OAAO,EAAU,KAAK,CAAC,IAAI,CAAC,EAAE,AAChC,CACA,SAAS,EAAgB,CAAI,EAC3B,MAAO,AAAS,MAAT,EAAe,IAAM,GAC9B,CACA,SAAS,EAAc,CAAI,EACzB,MAAO,AAAS,MAAT,EAAe,SAAW,OACnC,CACA,MAAM,EAA0B,IAAI,IAAI,CAAC,MAAO,SAAS,EACzD,SAAS,EAAY,CAAS,EAC5B,OAAO,EAAW,GAAG,CAAC,EAAQ,IAAc,IAAM,GACpD,CAqBA,SAAS,EAA8B,CAAS,EAC9C,OAAO,EAAU,OAAO,CAAC,aAAc,AAAA,GAAa,CAAoB,CAAC,EAAU,CACrF,CACA,MAAM,EAAc,CAAC,OAAQ,QAAQ,CAC/B,EAAc,CAAC,QAAS,OAAO,CAC/B,EAAc,CAAC,MAAO,SAAS,CAC/B,EAAc,CAAC,SAAU,MAAM,CAyBrC,SAAS,EAAqB,CAAS,EACrC,OAAO,EAAU,OAAO,CAAC,yBAA0B,AAAA,GAAQ,CAAe,CAAC,EAAK,CAClF,CAkBA,SAAS,EAAiB,CAAI,EAC5B,GAAM,CAAA,EACJ,CAAC,CAAA,EACD,CAAC,CAAA,MACD,CAAK,CAAA,OACL,CAAM,CACP,CAAG,EACJ,MAAO,CACL,MAAA,EACA,OAAA,EACA,IAAK,EACL,KAAM,EACN,MAAO,EAAI,EACX,OAAQ,EAAI,EACZ,EAAA,EACA,EAAA,CACF,CACF,CDrIA,SAAS,EAA2B,CAAI,CAAE,CAAS,CAAE,CAAG,EACtD,IAYI,EAZA,CAAA,UACF,CAAS,CAAA,SACT,CAAQ,CACT,CAAG,EACE,EAAW,AAAA,EAAY,GACvB,ECwCC,EAAgB,EDxCgB,IACjC,EAAc,AAAA,EAAc,GAC5B,EAAO,AAAA,EAAQ,GACf,EAAa,AAAa,MAAb,EACb,EAAU,EAAU,CAAC,CAAG,EAAU,KAAK,CAAG,EAAI,EAAS,KAAK,CAAG,EAC/D,EAAU,EAAU,CAAC,CAAG,EAAU,MAAM,CAAG,EAAI,EAAS,MAAM,CAAG,EACjE,EAAc,CAAS,CAAC,EAAY,CAAG,EAAI,CAAQ,CAAC,EAAY,CAAG,EAEzE,OAAQ,GACN,IAAK,MACH,EAAS,CACP,EAAG,EACH,EAAG,EAAU,CAAC,CAAG,EAAS,MAAM,AAClC,EACA,KACF,KAAK,SACH,EAAS,CACP,EAAG,EACH,EAAG,EAAU,CAAC,CAAG,EAAU,MAAM,AACnC,EACA,KACF,KAAK,QACH,EAAS,CACP,EAAG,EAAU,CAAC,CAAG,EAAU,KAAK,CAChC,EAAG,CACL,EACA,KACF,KAAK,OACH,EAAS,CACP,EAAG,EAAU,CAAC,CAAG,EAAS,KAAK,CAC/B,EAAG,CACL,EACA,KACF,SACE,EAAS,CACP,EAAG,EAAU,CAAC,CACd,EAAG,EAAU,CAAC,AAChB,CACJ,CACA,OAAQ,AAAA,EAAa,IACnB,IAAK,QACH,CAAM,CAAC,EAAc,EAAI,EAAe,CAAA,GAAO,EAAa,GAAK,CAAA,EACjE,KACF,KAAK,MACH,CAAM,CAAC,EAAc,EAAI,EAAe,CAAA,GAAO,EAAa,GAAK,CAAA,CAErE,CACA,OAAO,CACT,CASA,MAAM,EAAkB,MAAO,EAAW,EAAU,KAClD,GAAM,CAAA,UACJ,EAAY,QAAA,CAAA,SACZ,EAAW,UAAA,CAAA,WACX,EAAa,EAAE,CAAA,SACf,CAAQ,CACT,CAAG,EACE,EAAkB,EAAW,MAAM,CAAC,SACpC,EAAM,MAAO,CAAA,AAAkB,MAAlB,EAAS,KAAK,CAAW,KAAK,EAAI,EAAS,KAAK,CAAC,EAAA,EAChE,EAAQ,MAAM,EAAS,eAAe,CAAC,CACzC,UAAA,EACA,SAAA,EACA,SAAA,CACF,GACI,CAAA,EACF,CAAC,CAAA,EACD,CAAC,CACF,CAAG,EAA2B,EAAO,EAAW,GAC7C,EAAoB,EACpB,EAAiB,CAAC,EAClB,EAAa,EACjB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAgB,MAAM,CAAE,IAAK,CAC/C,GAAM,CAAA,KACJ,CAAI,CAAA,GACJ,CAAE,CACH,CAAG,CAAe,CAAC,EAAE,CAChB,CACJ,EAAG,CAAK,CACR,EAAG,CAAK,CAAA,KACR,CAAI,CAAA,MACJ,CAAK,CACN,CAAG,MAAM,EAAG,CACX,EAAA,EACA,EAAA,EACA,iBAAkB,EAClB,UAAW,EACX,SAAA,EACA,eAAA,EACA,MAAA,EACA,SAAA,EACA,SAAU,CACR,UAAA,EACA,SAAA,CACF,CACF,GACA,EAAI,AAAS,MAAT,EAAgB,EAAQ,EAC5B,EAAI,AAAS,MAAT,EAAgB,EAAQ,EAC5B,EAAiB,CACf,GAAG,CAAc,CACjB,CAAC,EAAK,CAAE,CACN,GAAG,CAAc,CAAC,EAAK,CACvB,GAAG,CAAI,AACT,CACF,EACI,GAAS,GAAc,KACzB,IACqB,UAAjB,OAAO,IACL,EAAM,SAAS,EACjB,CAAA,EAAoB,EAAM,SAAS,AAAT,EAExB,EAAM,KAAK,EACb,CAAA,EAAQ,AAAgB,CAAA,IAAhB,EAAM,KAAK,CAAY,MAAM,EAAS,eAAe,CAAC,CAC5D,UAAA,EACA,SAAA,EACA,SAAA,CACF,GAAK,EAAM,KAAK,AAAL,EAEZ,CAAA,EACC,CAAC,CAAA,EACD,CAAC,CACF,CAAG,EAA2B,EAAO,EAAmB,IAE3D,EAAI,GAER,CACA,MAAO,CACL,EAAA,EACA,EAAA,EACA,UAAW,EACX,SAAA,EACA,eAAA,CACF,CACF,EAUA,eAAe,EAAe,CAAK,CAAE,CAAO,MACtC,EChDoB,CDiDpB,AAAY,MAAK,IAAjB,GACF,CAAA,EAAU,CAAC,CAAA,EAEb,GAAM,CAAA,EACJ,CAAC,CAAA,EACD,CAAC,CAAA,SACD,CAAQ,CAAA,MACR,CAAK,CAAA,SACL,CAAQ,CAAA,SACR,CAAQ,CACT,CAAG,EACE,CAAA,SACJ,EAAW,mBAAA,CAAA,aACX,EAAe,UAAA,CAAA,eACf,EAAiB,UAAA,CAAA,YACjB,EAAc,CAAA,CAAA,CAAA,QACd,EAAU,CAAA,CACX,CAAG,AAAA,EAAS,EAAS,GAChB,EClEC,AAAmB,UAAnB,OADiB,EDmEe,GC3EhC,CACL,IAAK,EACL,MAAO,EACP,OAAQ,EACR,KAAM,EACN,GAIuD,CAAA,AAHzD,EAGoE,CAClE,IAAK,EACL,MAAO,EACP,OAAQ,EACR,KAAM,CACR,ED+DM,EAAU,CAAQ,CAAC,EADN,AAAmB,aAAnB,EAAgC,YAAc,WACb,EAAe,CAC7D,EAAqB,AAAA,EAAiB,MAAM,EAAS,eAAe,CAAC,CACzE,QAAU,AAAC,AAAsG,MAAtG,CAAA,EAAwB,MAAO,CAAA,AAAsB,MAAtB,EAAS,SAAS,CAAW,KAAK,EAAI,EAAS,SAAS,CAAC,EAAA,CAAO,GAAc,EAAgC,EAAU,EAAQ,cAAc,EAAK,MAAO,CAAA,AAA+B,MAA/B,EAAS,kBAAkB,CAAW,KAAK,EAAI,EAAS,kBAAkB,CAAC,EAAS,QAAQ,CAAA,EAChS,SAAA,EACA,aAAA,EACA,SAAA,CACF,IACM,EAAO,AAAmB,aAAnB,EAAgC,CAC3C,EAAA,EACA,EAAA,EACA,MAAO,EAAM,QAAQ,CAAC,KAAK,CAC3B,OAAQ,EAAM,QAAQ,CAAC,MAAM,AAC/B,EAAI,EAAM,SAAS,CACb,EAAe,MAAO,CAAA,AAA4B,MAA5B,EAAS,eAAe,CAAW,KAAK,EAAI,EAAS,eAAe,CAAC,EAAS,QAAQ,CAAA,EAC5G,EAAe,MAAO,CAAA,AAAsB,MAAtB,EAAS,SAAS,CAAW,KAAK,EAAI,EAAS,SAAS,CAAC,EAAA,GAAmB,MAAO,CAAA,AAAqB,MAArB,EAAS,QAAQ,CAAW,KAAK,EAAI,EAAS,QAAQ,CAAC,EAAA,GAAmB,CACvL,EAAG,EACH,EAAG,CACL,EAIM,EAAoB,AAAA,EAAiB,EAAS,qDAAqD,CAAG,MAAM,EAAS,qDAAqD,CAAC,CAC/K,SAAA,EACA,KAAA,EACA,aAAA,EACA,SAAA,CACF,GAAK,GACL,MAAO,CACL,IAAM,AAAA,CAAA,EAAmB,GAAG,CAAG,EAAkB,GAAG,CAAG,EAAc,GAAE,AAAF,EAAO,EAAY,CAAC,CACzF,OAAS,AAAA,CAAA,EAAkB,MAAM,CAAG,EAAmB,MAAM,CAAG,EAAc,MAAK,AAAL,EAAU,EAAY,CAAC,CACrG,KAAO,AAAA,CAAA,EAAmB,IAAI,CAAG,EAAkB,IAAI,CAAG,EAAc,IAAG,AAAH,EAAQ,EAAY,CAAC,CAC7F,MAAQ,AAAA,CAAA,EAAkB,KAAK,CAAG,EAAmB,KAAK,CAAG,EAAc,KAAI,AAAJ,EAAS,EAAY,CAAC,AACnG,CACF,CAugBA,MAAM,EAA2B,IAAI,IAAI,CAAC,OAAQ,MAAM,EAKxD,eAAe,EAAqB,CAAK,CAAE,CAAO,EAChD,GAAM,CAAA,UACJ,CAAS,CAAA,SACT,CAAQ,CAAA,SACR,CAAQ,CACT,CAAG,EACE,EAAM,MAAO,CAAA,AAAkB,MAAlB,EAAS,KAAK,CAAW,KAAK,EAAI,EAAS,KAAK,CAAC,EAAS,QAAQ,CAAA,EAC/E,EAAO,AAAA,EAAQ,GACf,EAAY,AAAA,EAAa,GACzB,EAAa,AAA2B,MAA3B,AAAA,EAAY,GACzB,EAAgB,EAAY,GAAG,CAAC,GAAQ,GAAK,EAC7C,EAAiB,GAAO,EAAa,GAAK,EAC1C,EAAW,AAAA,EAAS,EAAS,GAG/B,CAAA,SACF,CAAQ,CAAA,UACR,CAAS,CAAA,cACT,CAAa,CACd,CAAG,AAAoB,UAApB,OAAO,EAAwB,CACjC,SAAU,EACV,UAAW,EACX,cAAe,IACjB,EAAI,CACF,SAAU,EAAS,QAAQ,EAAI,EAC/B,UAAW,EAAS,SAAS,EAAI,EACjC,cAAe,EAAS,aAAa,AACvC,EAIA,OAHI,GAAa,AAAyB,UAAzB,OAAO,GACtB,CAAA,EAAY,AAAc,QAAd,EAAsB,AAAgB,GAAhB,EAAqB,CADzD,EAGO,EAAa,CAClB,EAAG,EAAY,EACf,EAAG,EAAW,CAChB,EAAI,CACF,EAAG,EAAW,EACd,EAAG,EAAY,CACjB,CACF,CEvwBA,SAAS,IACP,MAAO,AAAkB,aAAlB,OAAO,MAChB,CACA,SAAS,EAAY,CAAI,SACvB,AAAI,EAAO,GACD,AAAA,CAAA,EAAK,QAAQ,EAAI,EAAA,EAAI,WAAW,GAKnC,WACT,CACA,SAAS,EAAU,CAAI,EACrB,IAAI,EACJ,MAAQ,AAAA,CAAA,AAAQ,MAAR,GAAgB,AAA8C,MAA7C,CAAA,EAAsB,EAAK,aAAa,AAAb,EAAyB,KAAK,EAAI,EAAoB,WAAU,AAAV,GAAgB,MAC5H,CACA,SAAS,EAAmB,CAAI,EAC9B,IAAI,EACJ,OAAO,AAAmF,MAAlF,CAAA,EAAQ,AAAA,CAAA,EAAO,GAAQ,EAAK,aAAa,CAAG,EAAK,QAAO,AAAP,GAAa,OAAO,QAAO,AAAP,EAAoB,KAAK,EAAI,EAAK,eAAe,AAChI,CACA,SAAS,EAAO,CAAK,QACnB,CAAI,CAAC,KAGE,CAAA,aAAiB,MAAQ,aAAiB,EAAU,GAAO,IAAI,AAAJ,CACpE,CACA,SAAS,EAAU,CAAK,QACtB,CAAI,CAAC,KAGE,CAAA,aAAiB,SAAW,aAAiB,EAAU,GAAO,OAAO,AAAP,CACvE,CACA,SAAS,EAAc,CAAK,QAC1B,CAAI,CAAC,KAGE,CAAA,aAAiB,aAAe,aAAiB,EAAU,GAAO,WAAW,AAAX,CAC3E,CACA,SAAS,EAAa,CAAK,QACzB,CAAI,CAAC,KAAe,AAAsB,aAAtB,OAAO,YAGpB,CAAA,aAAiB,YAAc,aAAiB,EAAU,GAAO,UAAU,AAAV,CAC1E,CACA,MAAM,EAA4C,IAAI,IAAI,CAAC,SAAU,WAAW,EAChF,SAAS,EAAkB,CAAO,EAChC,GAAM,CAAA,SACJ,CAAQ,CAAA,UACR,CAAS,CAAA,UACT,CAAS,CAAA,QACT,CAAO,CACR,CAAG,EAAiB,GACrB,MAAO,kCAAkC,IAAI,CAAC,EAAW,EAAY,IAAc,CAAC,EAA6B,GAAG,CAAC,EACvH,CACA,MAAM,EAA6B,IAAI,IAAI,CAAC,QAAS,KAAM,KAAK,EAI1D,EAAoB,CAAC,gBAAiB,SAAS,CACrD,SAAS,EAAW,CAAO,EACzB,OAAO,EAAkB,IAAI,CAAC,AAAA,IAC5B,GAAI,CACF,OAAO,EAAQ,OAAO,CAAC,EACzB,CAAE,MAAO,EAAI,CACX,MAAO,CAAA,CACT,CACF,EACF,CACA,MAAM,EAAsB,CAAC,YAAa,YAAa,QAAS,SAAU,cAAc,CAClF,EAAmB,CAAC,YAAa,YAAa,QAAS,SAAU,cAAe,SAAS,CACzF,EAAgB,CAAC,QAAS,SAAU,SAAU,UAAU,CAC9D,SAAS,EAAkB,CAAY,EACrC,IAAM,EAAS,IACT,EAAM,EAAU,GAAgB,EAAiB,GAAgB,EAIvE,OAAO,EAAoB,IAAI,CAAC,AAAA,GAAS,EAAA,CAAG,CAAC,EAAM,EAAG,AAAe,SAAf,CAAG,CAAC,EAAM,GAAyB,EAAA,EAAI,aAAa,EAAG,AAAsB,WAAtB,EAAI,aAAa,EAA0B,CAAC,KAAW,EAAI,cAAc,EAAG,AAAuB,SAAvB,EAAI,cAAc,EAAwB,CAAC,KAAW,EAAI,MAAM,EAAG,AAAe,SAAf,EAAI,MAAM,EAAwB,EAAiB,IAAI,CAAC,AAAA,GAAS,AAAC,CAAA,EAAI,UAAU,EAAI,EAAA,EAAI,QAAQ,CAAC,KAAW,EAAc,IAAI,CAAC,AAAA,GAAS,AAAC,CAAA,EAAI,OAAO,EAAI,EAAA,EAAI,QAAQ,CAAC,GACna,CAaA,SAAS,UACP,AAAmB,aAAf,OAAO,MAAuB,CAAC,IAAI,QAAQ,EACxC,IAAI,QAAQ,CAAC,0BAA2B,OACjD,CACA,MAAM,EAAwC,IAAI,IAAI,CAAC,OAAQ,OAAQ,YAAY,EACnF,SAAS,EAAsB,CAAI,EACjC,OAAO,EAAyB,GAAG,CAAC,EAAY,GAClD,CACA,SAAS,EAAiB,CAAO,EAC/B,OAAO,EAAU,GAAS,gBAAgB,CAAC,EAC7C,CACA,SAAS,EAAc,CAAO,SAC5B,AAAI,EAAU,GACL,CACL,WAAY,EAAQ,UAAU,CAC9B,UAAW,EAAQ,SAAS,AAC9B,EAEK,CACL,WAAY,EAAQ,OAAO,CAC3B,UAAW,EAAQ,OAAO,AAC5B,CACF,CACA,SAAS,EAAc,CAAI,EACzB,GAAI,AAAsB,SAAtB,EAAY,GACd,OAAO,EAET,IAAM,EAEN,EAAK,YAAY,EAEjB,EAAK,UAAU,EAEf,EAAa,IAAS,EAAK,IAAI,EAE/B,EAAmB,GACnB,OAAO,EAAa,GAAU,EAAO,IAAI,CAAG,CAC9C,CA4BA,SAAS,EAAgB,CAAG,EAC1B,OAAO,EAAI,MAAM,EAAI,OAAO,cAAc,CAAC,EAAI,MAAM,EAAI,EAAI,YAAY,CAAG,IAC9E,CHzJA,SAAS,EAAiB,CAAO,EAC/B,IAAM,EAAM,AAAA,EAAiB,GAGzB,EAAQ,WAAW,EAAI,KAAK,GAAK,EACjC,EAAS,WAAW,EAAI,MAAM,GAAK,EACjC,EAAY,AAAA,EAAc,GAC1B,EAAc,EAAY,EAAQ,WAAW,CAAG,EAChD,EAAe,EAAY,EAAQ,YAAY,CAAG,EAClD,EAAiB,AAAA,EAAM,KAAW,GAAe,AAAA,EAAM,KAAY,EAKzE,OAJI,IACF,EAAQ,EACR,EAAS,GAEJ,CACL,MAAA,EACA,OAAA,EACA,EAAG,CACL,CACF,CAEA,SAAS,EAAc,CAAO,EAC5B,OAAO,AAAC,AAAA,EAAU,GAAoC,EAAzB,EAAQ,cAAc,AACrD,CAEA,SAAS,EAAS,CAAO,EACvB,IAAM,EAAa,EAAc,GACjC,GAAI,CAAC,AAAA,EAAc,GACjB,OAAO,AAAA,EAAa,GAEtB,IAAM,EAAO,EAAW,qBAAqB,GACvC,CAAA,MACJ,CAAK,CAAA,OACL,CAAM,CAAA,EACN,CAAC,CACF,CAAG,EAAiB,GACjB,EAAI,AAAC,CAAA,EAAI,AAAA,EAAM,EAAK,KAAK,EAAI,EAAK,KAAI,AAAJ,EAAS,EAC3C,EAAI,AAAC,CAAA,EAAI,AAAA,EAAM,EAAK,MAAM,EAAI,EAAK,MAAK,AAAL,EAAU,EAUjD,OANI,AAAC,GAAM,OAAO,QAAQ,CAAC,IACzB,CAAA,EAAI,CAAA,EAEF,AAAC,GAAM,OAAO,QAAQ,CAAC,IACzB,CAAA,EAAI,CAAA,EAEC,CACL,EAAA,EACA,EAAA,CACF,CACF,CAEA,MAAM,EAAyB,AAAA,EAAa,GAC5C,SAAS,EAAiB,CAAO,EAC/B,IAAM,EAAM,AAAA,EAAU,UACtB,AAAI,AAAC,AAAA,KAAe,EAAI,cAAc,CAG/B,CACL,EAAG,EAAI,cAAc,CAAC,UAAU,CAChC,EAAG,EAAI,cAAc,CAAC,SAAS,AACjC,EALS,CAMX,CAWA,SAAS,GAAsB,CAAO,CAAE,CAAY,CAAE,CAAe,CAAE,CAAY,MAV1C,CAWnC,AAAiB,MAAK,IAAtB,GACF,CAAA,EAAe,CAAA,CADjB,EAGI,AAAoB,KAAK,IAAzB,GACF,CAAA,EAAkB,CAAA,CADpB,EAGA,IAAM,EAAa,EAAQ,qBAAqB,GAC1C,EAAa,EAAc,GAC7B,EAAQ,AAAA,EAAa,GACrB,IACE,EACE,AAAA,EAAU,IACZ,CAAA,EAAQ,EAAS,EADnB,EAIA,EAAQ,EAAS,IAGrB,IAAM,EAAgB,CA5BlB,AAAY,KAAK,KADkB,EA6BkB,IA3BvD,CAAA,EAAU,CAAA,CADZ,EA4B0E,GAzB7C,CAAA,CAAA,GAAW,AAyBkC,IAzBT,AAAA,EAyBpB,EAzB8B,GAGpE,GAsBmF,EAAiB,GAAc,AAAA,EAAa,GAClI,EAAK,AAAA,CAAA,EAAW,IAAI,CAAG,EAAc,CAAC,AAAD,EAAK,EAAM,CAAC,CACjD,EAAK,AAAA,CAAA,EAAW,GAAG,CAAG,EAAc,CAAC,AAAD,EAAK,EAAM,CAAC,CAChD,EAAQ,EAAW,KAAK,CAAG,EAAM,CAAC,CAClC,EAAS,EAAW,MAAM,CAAG,EAAM,CAAC,CACxC,GAAI,EAAY,CACd,IAAM,EAAM,AAAA,EAAU,GAChB,EAAY,GAAgB,AAAA,EAAU,GAAgB,AAAA,EAAU,GAAgB,EAClF,EAAa,EACb,EAAgB,AAAA,EAAgB,GACpC,KAAO,GAAiB,GAAgB,IAAc,GAAY,CAChE,IAAM,EAAc,EAAS,GACvB,EAAa,EAAc,qBAAqB,GAChD,EAAM,AAAA,EAAiB,GACvB,EAAO,EAAW,IAAI,CAAI,AAAA,CAAA,EAAc,UAAU,CAAG,WAAW,EAAI,WAAW,CAAA,EAAK,EAAY,CAAC,CACjG,EAAM,EAAW,GAAG,CAAI,AAAA,CAAA,EAAc,SAAS,CAAG,WAAW,EAAI,UAAU,CAAA,EAAK,EAAY,CAAC,CACnG,GAAK,EAAY,CAAC,CAClB,GAAK,EAAY,CAAC,CAClB,GAAS,EAAY,CAAC,CACtB,GAAU,EAAY,CAAC,CACvB,GAAK,EACL,GAAK,EAEL,EAAgB,AAAA,EADhB,EAAa,AAAA,EAAU,GAEzB,CACF,CACA,OAAO,AAAA,EAAiB,CACtB,MAAA,EACA,OAAA,EACA,EAAA,EACA,EAAA,CACF,EACF,CAIA,SAAS,GAAoB,CAAO,CAAE,CAAI,EACxC,IAAM,EAAa,AAAA,EAAc,GAAS,UAAU,QACpD,AAAK,EAGE,EAAK,IAAI,CAAG,EAFV,GAAsB,AAAA,EAAmB,IAAU,IAAI,CAAG,CAGrE,CAEA,SAAS,GAAc,CAAe,CAAE,CAAM,CAAE,CAAgB,EAC1D,AAAqB,KAAK,IAA1B,GACF,CAAA,EAAmB,CAAA,CADrB,EAGA,IAAM,EAAW,EAAgB,qBAAqB,GAKtD,MAAO,CACL,EALQ,EAAS,IAAI,CAAG,EAAO,UAAU,CAAI,CAAA,EAAmB,EAElE,GAAoB,EAAiB,EAAA,EAInC,EAHQ,EAAS,GAAG,CAAG,EAAO,SAAS,AAIzC,CACF,CA4FA,MAAM,GAA+B,IAAI,IAAI,CAAC,WAAY,QAAQ,EAkBlE,SAAS,GAAkC,CAAO,CAAE,CAAgB,CAAE,CAAQ,EAC5E,IAAI,EACJ,GAAI,AAAqB,aAArB,EACF,EAAO,AA9CX,SAAyB,CAAO,CAAE,CAAQ,EACxC,IAAM,EAAM,AAAA,EAAU,GAChB,EAAO,AAAA,EAAmB,GAC1B,EAAiB,EAAI,cAAc,CACrC,EAAQ,EAAK,WAAW,CACxB,EAAS,EAAK,YAAY,CAC1B,EAAI,EACJ,EAAI,EACR,GAAI,EAAgB,CAClB,EAAQ,EAAe,KAAK,CAC5B,EAAS,EAAe,MAAM,CAC9B,IAAM,EAAsB,AAAA,IACxB,CAAA,CAAC,GAAuB,GAAuB,AAAa,UAAb,CAAa,IAC9D,EAAI,EAAe,UAAU,CAC7B,EAAI,EAAe,SAAS,CAEhC,CACA,MAAO,CACL,MAAA,EACA,OAAA,EACA,EAAA,EACA,EAAA,CACF,CACF,EAuB2B,EAAS,QAC3B,GAAI,AAAqB,aAArB,EACT,EAAO,AAnEX,SAAyB,CAAO,EAC9B,IAAM,EAAO,AAAA,EAAmB,GAC1B,EAAS,AAAA,EAAc,GACvB,EAAO,EAAQ,aAAa,CAAC,IAAI,CACjC,EAAQ,AAAA,EAAI,EAAK,WAAW,CAAE,EAAK,WAAW,CAAE,EAAK,WAAW,CAAE,EAAK,WAAW,EAClF,EAAS,AAAA,EAAI,EAAK,YAAY,CAAE,EAAK,YAAY,CAAE,EAAK,YAAY,CAAE,EAAK,YAAY,EACzF,EAAI,CAAC,EAAO,UAAU,CAAG,GAAoB,GAC3C,EAAI,CAAC,EAAO,SAAS,CAI3B,MAHI,AAAqC,QAArC,AAAA,EAAiB,GAAM,SAAS,EAClC,CAAA,GAAK,AAAA,EAAI,EAAK,WAAW,CAAE,EAAK,WAAW,EAAI,CADjD,EAGO,CACL,MAAA,EACA,OAAA,EACA,EAAA,EACA,EAAA,CACF,CACF,EAkD2B,AAAA,EAAmB,SACrC,GAAI,AAAA,EAAU,GACnB,EAAO,AAvBX,SAAoC,CAAO,CAAE,CAAQ,EACnD,IAAM,EAAa,GAAsB,EAAS,CAAA,EAAM,AAAa,UAAb,GAClD,EAAM,EAAW,GAAG,CAAG,EAAQ,SAAS,CACxC,EAAO,EAAW,IAAI,CAAG,EAAQ,UAAU,CAC3C,EAAQ,AAAA,EAAc,GAAW,EAAS,GAAW,AAAA,EAAa,GAClE,EAAQ,EAAQ,WAAW,CAAG,EAAM,CAAC,CACrC,EAAS,EAAQ,YAAY,CAAG,EAAM,CAAC,CAG7C,MAAO,CACL,MAAA,EACA,OAAA,EACA,EALQ,EAAO,EAAM,CAAC,CAMtB,EALQ,EAAM,EAAM,CAAC,AAMvB,CACF,EAQsC,EAAkB,OAC/C,CACL,IAAM,EAAgB,EAAiB,GACvC,EAAO,CACL,EAAG,EAAiB,CAAC,CAAG,EAAc,CAAC,CACvC,EAAG,EAAiB,CAAC,CAAG,EAAc,CAAC,CACvC,MAAO,EAAiB,KAAK,CAC7B,OAAQ,EAAiB,MAAM,AACjC,CACF,CACA,OAAO,AAAA,EAAiB,EAC1B,CA4HA,SAAS,GAAmB,CAAO,EACjC,MAAO,AAAuC,WAAvC,AAAA,EAAiB,GAAS,QAAQ,AAC3C,CAEA,SAAS,GAAoB,CAAO,CAAE,CAAQ,EAC5C,GAAI,CAAC,AAAA,EAAc,IAAY,AAAuC,UAAvC,AAAA,EAAiB,GAAS,QAAQ,CAC/D,OAAO,KAET,GAAI,EACF,OAAO,EAAS,GAElB,IAAI,EAAkB,EAAQ,YAAY,CAS1C,OAHI,AAAA,EAAmB,KAAa,GAClC,CAAA,EAAkB,EAAgB,aAAa,CAAC,IAAI,AAAJ,EAE3C,CACT,CAIA,SAAS,GAAgB,CAAO,CAAE,CAAQ,MGzXlB,EH0XtB,IAAM,EAAM,AAAA,EAAU,GACtB,GAAI,AAAA,EAAW,GACb,OAAO,EAET,GAAI,CAAC,AAAA,EAAc,GAAU,CAC3B,IAAI,EAAkB,AAAA,EAAc,GACpC,KAAO,GAAmB,CAAC,AAAA,EAAsB,IAAkB,CACjE,GAAI,AAAA,EAAU,IAAoB,CAAC,GAAmB,GACpD,OAAO,EAET,EAAkB,AAAA,EAAc,EAClC,CACA,OAAO,CACT,CACA,IAAI,EAAe,GAAoB,EAAS,GAChD,KAAO,IGzYe,EHyYgB,EGxY/B,EAAc,GAAG,CAAC,EAAY,MHwYkB,GAAmB,IACxE,EAAe,GAAoB,EAAc,UAEnD,AAAI,GAAgB,AAAA,EAAsB,IAAiB,GAAmB,IAAiB,CAAC,AAAA,EAAkB,GACzG,EAEF,GAAgB,AGvXzB,SAA4B,CAAO,EACjC,IAAI,EAAc,EAAc,GAChC,KAAO,EAAc,IAAgB,CAAC,EAAsB,IAAc,CACxE,GAAI,EAAkB,GACpB,OAAO,EACF,GAAI,EAAW,GACpB,MAEF,EAAc,EAAc,EAC9B,CACA,OAAO,IACT,EH4W4C,IAAY,CACxD,CAEA,MAAM,GAAkB,eAAgB,CAAI,EAC1C,IAAM,EAAoB,IAAI,CAAC,eAAe,EAAI,GAC5C,EAAkB,IAAI,CAAC,aAAa,CACpC,EAAqB,MAAM,EAAgB,EAAK,QAAQ,EAC9D,MAAO,CACL,UAAW,AAjGf,SAAuC,CAAO,CAAE,CAAY,CAAE,CAAQ,EACpE,IAAM,EAA0B,AAAA,EAAc,GACxC,EAAkB,AAAA,EAAmB,GACrC,EAAU,AAAa,UAAb,EACV,EAAO,GAAsB,EAAS,CAAA,EAAM,EAAS,GACvD,EAAS,CACX,WAAY,EACZ,UAAW,CACb,EACM,EAAU,AAAA,EAAa,GAO7B,GAAI,GAA2B,CAAC,GAA2B,CAAC,EAI1D,GAHI,CAAA,AAA8B,SAA9B,AAAA,EAAY,IAA4B,AAAA,EAAkB,EAAA,GAC5D,CAAA,EAAS,AAAA,EAAc,EADzB,EAGI,EAAyB,CAC3B,IAAM,EAAa,GAAsB,EAAc,CAAA,EAAM,EAAS,EACtE,CAAA,EAAQ,CAAC,CAAG,EAAW,CAAC,CAAG,EAAa,UAAU,CAClD,EAAQ,CAAC,CAAG,EAAW,CAAC,CAAG,EAAa,SAAS,AACnD,MAAW,GAVX,CAAA,EAAQ,CAAC,CAAG,GAAoB,EAAhC,CAcE,CAAA,GAAW,CAAC,GAA2B,GAdzC,CAAA,EAAQ,CAAC,CAAG,GAAoB,EAAhC,EAiBF,IAAM,EAAa,CAAA,GAAoB,GAA4B,EAAmD,AAAA,EAAa,GAAtD,GAAc,EAAiB,GAG5G,MAAO,CACL,EAHQ,EAAK,IAAI,CAAG,EAAO,UAAU,CAAG,EAAQ,CAAC,CAAG,EAAW,CAAC,CAIhE,EAHQ,EAAK,GAAG,CAAG,EAAO,SAAS,CAAG,EAAQ,CAAC,CAAG,EAAW,CAAC,CAI9D,MAAO,EAAK,KAAK,CACjB,OAAQ,EAAK,MAAM,AACrB,CACF,EAyD6C,EAAK,SAAS,CAAE,MAAM,EAAkB,EAAK,QAAQ,EAAG,EAAK,QAAQ,EAC9G,SAAU,CACR,EAAG,EACH,EAAG,EACH,MAAO,EAAmB,KAAK,CAC/B,OAAQ,EAAmB,MAAM,AACnC,CACF,CACF,EAMM,GAAW,CACf,sDAhUF,SAA+D,CAAI,EACjE,GAAI,CAAA,SACF,CAAQ,CAAA,KACR,CAAI,CAAA,aACJ,CAAY,CAAA,SACZ,CAAQ,CACT,CAAG,EACE,EAAU,AAAa,UAAb,EACV,EAAkB,AAAA,EAAmB,GACrC,EAAW,EAAA,GAAW,AAAA,EAAW,EAAS,QAAQ,EACxD,GAAI,IAAiB,GAAmB,GAAY,EAClD,OAAO,EAET,IAAI,EAAS,CACX,WAAY,EACZ,UAAW,CACb,EACI,EAAQ,AAAA,EAAa,GACnB,EAAU,AAAA,EAAa,GACvB,EAA0B,AAAA,EAAc,GAC9C,GAAI,CAAA,GAA2B,CAAC,GAA2B,CAAC,CAAA,IACtD,CAAA,AAA8B,SAA9B,AAAA,EAAY,IAA4B,AAAA,EAAkB,EAAA,GAC5D,CAAA,EAAS,AAAA,EAAc,EADzB,EAGI,AAAA,EAAc,IAAe,CAC/B,IAAM,EAAa,GAAsB,GACzC,EAAQ,EAAS,GACjB,EAAQ,CAAC,CAAG,EAAW,CAAC,CAAG,EAAa,UAAU,CAClD,EAAQ,CAAC,CAAG,EAAW,CAAC,CAAG,EAAa,SAAS,AACnD,CAEF,IAAM,EAAa,CAAA,GAAoB,GAA4B,EAAyD,AAAA,EAAa,GAA5D,GAAc,EAAiB,EAAQ,CAAA,GACpH,MAAO,CACL,MAAO,EAAK,KAAK,CAAG,EAAM,CAAC,CAC3B,OAAQ,EAAK,MAAM,CAAG,EAAM,CAAC,CAC7B,EAAG,EAAK,CAAC,CAAG,EAAM,CAAC,CAAG,EAAO,UAAU,CAAG,EAAM,CAAC,CAAG,EAAQ,CAAC,CAAG,EAAW,CAAC,CAC5E,EAAG,EAAK,CAAC,CAAG,EAAM,CAAC,CAAG,EAAO,SAAS,CAAG,EAAM,CAAC,CAAG,EAAQ,CAAC,CAAG,EAAW,CAAC,AAC7E,CACF,EA2RE,mBAAA,EACA,gBAvJF,SAAyB,CAAI,EAC3B,GAAI,CAAA,QACF,CAAO,CAAA,SACP,CAAQ,CAAA,aACR,CAAY,CAAA,SACZ,CAAQ,CACT,CAAG,EAEE,EAAoB,IADO,AAAa,sBAAb,EAAmC,AAAA,EAAW,GAAW,EAAE,CAAG,AAxCjG,SAAqC,CAAO,CAAE,CAAK,EACjD,IAAM,EAAe,EAAM,GAAG,CAAC,GAC/B,GAAI,EACF,OAAO,EAET,IAAI,EAAS,AGjKf,CAAA,SAAS,EAAqB,CAAI,CAAE,CAAI,CAAE,CAAe,EACvD,IAAI,CACA,AAAS,MAAK,IAAd,GACF,CAAA,EAAO,EAAE,AAAF,EAEL,AAAoB,KAAK,IAAzB,GACF,CAAA,EAAkB,CAAA,CADpB,EAGA,IAAM,EAAqB,AAlB7B,SAAS,EAA2B,CAAI,EACtC,IAAM,EAAa,EAAc,UACjC,AAAI,EAAsB,GACjB,EAAK,aAAa,CAAG,EAAK,aAAa,CAAC,IAAI,CAAG,EAAK,IAAI,CAE7D,EAAc,IAAe,EAAkB,GAC1C,EAEF,EAA2B,EACpC,EASwD,GAChD,EAAS,IAAwB,CAAA,AAA+C,MAA9C,CAAA,EAAuB,EAAK,aAAa,AAAb,EAAyB,KAAK,EAAI,EAAqB,IAAI,AAAJ,EACrH,EAAM,EAAU,GACtB,GAAI,EAAQ,CACV,IAAM,EAAe,EAAgB,GACrC,OAAO,EAAK,MAAM,CAAC,EAAK,EAAI,cAAc,EAAI,EAAE,CAAE,EAAkB,GAAsB,EAAqB,EAAE,CAAE,GAAgB,EAAkB,EAAqB,GAAgB,EAAE,CAC9L,CACA,OAAO,EAAK,MAAM,CAAC,EAAoB,EAAqB,EAAoB,EAAE,CAAE,GACtF,CAAA,EHiJoC,EAAS,EAAE,CAAE,CAAA,GAAO,MAAM,CAAC,AAAA,GAAM,AAAA,EAAU,IAAO,AAAoB,SAApB,AAAA,EAAY,IAC5F,EAAsC,KACpC,EAAiB,AAAuC,UAAvC,AAAA,EAAiB,GAAS,QAAQ,CACrD,EAAc,EAAiB,AAAA,EAAc,GAAW,EAG5D,KAAO,AAAA,EAAU,IAAgB,CAAC,AAAA,EAAsB,IAAc,CACpE,IAAM,EAAgB,AAAA,EAAiB,GACjC,EAA0B,AAAA,EAAkB,EAC9C,CAAC,GAA2B,AAA2B,UAA3B,EAAc,QAAQ,EACpD,CAAA,EAAsC,IADxC,EAG8B,CAAA,EAAiB,CAAC,GAA2B,CAAC,EAAsC,CAAC,GAA2B,AAA2B,WAA3B,EAAc,QAAQ,EAAiB,CAAC,CAAC,GAAuC,GAAgB,GAAG,CAAC,EAAoC,QAAQ,GAAK,AAAA,EAAkB,IAAgB,CAAC,GAA2B,AA5BrW,SAAS,EAAyB,CAAO,CAAE,CAAQ,EACjD,IAAM,EAAa,AAAA,EAAc,SACjC,CAAI,CAAA,IAAe,GAAY,CAAC,AAAA,EAAU,IAAe,AAAA,EAAsB,EAAA,GAGxE,CAAA,AAA0C,UAA1C,AAAA,EAAiB,GAAY,QAAQ,EAAgB,EAAyB,EAAY,EAAjG,CACF,EAsB8X,EAAS,EAAnY,EAGE,EAAS,EAAO,MAAM,CAAC,AAAA,GAAY,IAAa,GAGhD,EAAsC,EAExC,EAAc,AAAA,EAAc,EAC9B,CAEA,OADA,EAAM,GAAG,CAAC,EAAS,GACZ,CACT,EAW6H,EAAS,IAAI,CAAC,EAAE,EAAI,EAAE,CAAC,MAAM,CAAC,GACjG,EAAa,CAC/D,EAAwB,CAAiB,CAAC,EAAE,CAC5C,EAAe,EAAkB,MAAM,CAAC,CAAC,EAAS,KACtD,IAAM,EAAO,GAAkC,EAAS,EAAkB,GAK1E,OAJA,EAAQ,GAAG,CAAG,AAAA,EAAI,EAAK,GAAG,CAAE,EAAQ,GAAG,EACvC,EAAQ,KAAK,CAAG,AAAA,EAAI,EAAK,KAAK,CAAE,EAAQ,KAAK,EAC7C,EAAQ,MAAM,CAAG,AAAA,EAAI,EAAK,MAAM,CAAE,EAAQ,MAAM,EAChD,EAAQ,IAAI,CAAG,AAAA,EAAI,EAAK,IAAI,CAAE,EAAQ,IAAI,EACnC,CACT,EAAG,GAAkC,EAAS,EAAuB,IACrE,MAAO,CACL,MAAO,EAAa,KAAK,CAAG,EAAa,IAAI,CAC7C,OAAQ,EAAa,MAAM,CAAG,EAAa,GAAG,CAC9C,EAAG,EAAa,IAAI,CACpB,EAAG,EAAa,GAAG,AACrB,CACF,EAgIE,gBAAA,GACA,gBAAA,GACA,eA7RF,SAAwB,CAAO,EAC7B,OAAO,MAAM,IAAI,CAAC,EAAQ,cAAc,GAC1C,EA4RE,cAjIF,SAAuB,CAAO,EAC5B,GAAM,CAAA,MACJ,CAAK,CAAA,OACL,CAAM,CACP,CAAG,EAAiB,GACrB,MAAO,CACL,MAAA,EACA,OAAA,CACF,CACF,EAyHE,SAAA,EACA,UAAA,EACA,MAdF,SAAe,CAAO,EACpB,MAAO,AAAwC,QAAxC,AAAA,EAAiB,GAAS,SAAS,AAC5C,CAaA,EA8LM,GC2GS,SAAU,CAAO,EAI9B,OAHI,AAAY,KAAK,IAAjB,GACF,CAAA,EAAU,CAAA,EAEL,CACL,KAAM,SACN,QAAA,EACA,MAAM,GAAG,CAAK,EACZ,IAAI,EAAuB,EAC3B,GAAM,CAAA,EACJ,CAAC,CAAA,EACD,CAAC,CAAA,UACD,CAAS,CAAA,eACT,CAAc,CACf,CAAG,EACE,EAAa,MAAM,EAAqB,EAAO,UAIrD,AAAI,IAAe,CAAA,AAAmD,MAAlD,CAAA,EAAwB,EAAe,MAAK,AAAL,EAAkB,KAAK,EAAI,EAAsB,SAAS,AAAT,GAAc,AAAkD,MAAjD,CAAA,EAAwB,EAAe,KAAI,AAAJ,GAAkB,EAAsB,eAAe,CAChN,CAAC,EAEH,CACL,EAAG,EAAI,EAAW,CAAC,CACnB,EAAG,EAAI,EAAW,CAAC,CACnB,KAAM,CACJ,GAAG,CAAU,CACb,UAAA,CACF,CACF,CACF,CACF,CACF,ED5HM,GCmIQ,SAAU,CAAO,EAI7B,OAHI,AAAY,KAAK,IAAjB,GACF,CAAA,EAAU,CAAC,CAAA,EAEN,CACL,KAAM,QACN,QAAA,EACA,MAAM,GAAG,CAAK,EACZ,GAAM,CAAA,EACJ,CAAC,CAAA,EACD,CAAC,CAAA,UACD,CAAS,CACV,CAAG,EACE,CACJ,SAAU,EAAgB,CAAA,CAAI,CAC9B,UAAW,EAAiB,CAAA,CAAK,CAAA,QACjC,EAAU,CACR,GAAI,AAAA,IACF,GAAI,CAAA,EACF,CAAC,CAAA,EACD,CAAC,CACF,CAAG,EACJ,MAAO,CACL,EAAA,EACA,EAAA,CACF,CACF,CACF,CAAA,CACA,GAAG,EACJ,CAAG,AAAA,EAAS,EAAS,GAChB,EAAS,CACb,EAAA,EACA,EAAA,CACF,EACM,EAAW,MAAM,EAAe,EAAO,GACvC,EAAY,AAAA,EAAY,AAAA,EAAQ,IAChC,EAAW,AAAA,EAAgB,GAC7B,EAAgB,CAAM,CAAC,EAAS,CAChC,EAAiB,CAAM,CAAC,EAAU,CACtC,GAAI,EAAe,CACjB,IAAM,EAAU,AAAa,MAAb,EAAmB,MAAQ,OACrC,EAAU,AAAa,MAAb,EAAmB,SAAW,QACxC,EAAM,EAAgB,CAAQ,CAAC,EAAQ,CACvC,EAAM,EAAgB,CAAQ,CAAC,EAAQ,CAC7C,ECx0BC,EDw0BqB,ECx0BV,EDw0Be,EAAe,GAC5C,CACA,GAAI,EAAgB,CAClB,IAAM,EAAU,AAAc,MAAd,EAAoB,MAAQ,OACtC,EAAU,AAAc,MAAd,EAAoB,SAAW,QACzC,EAAM,EAAiB,CAAQ,CAAC,EAAQ,CACxC,EAAM,EAAiB,CAAQ,CAAC,EAAQ,CAC9C,EC/0BC,ED+0BsB,EC/0BX,ED+0BgB,EAAgB,GAC9C,CACA,IAAM,EAAgB,EAAQ,EAAE,CAAC,CAC/B,GAAG,CAAK,CACR,CAAC,EAAS,CAAE,EACZ,CAAC,EAAU,CAAE,CACf,GACA,MAAO,CACL,GAAG,CAAa,CAChB,KAAM,CACJ,EAAG,EAAc,CAAC,CAAG,EACrB,EAAG,EAAc,CAAC,CAAG,EACrB,QAAS,CACP,CAAC,EAAS,CAAE,EACZ,CAAC,EAAU,CAAE,CACf,CACF,CACF,CACF,CACF,CACF,EDlMM,GCtSO,SAAU,CAAO,EAI5B,OAHI,AAAY,KAAK,IAAjB,GACF,CAAA,EAAU,CAAC,CAAA,EAEN,CACL,KAAM,OACN,QAAA,EACA,MAAM,GAAG,CAAK,MACR,EAAuB,EAqDrB,EAAuB,EA+Bf,EAnFd,GAAM,CAAA,UACJ,CAAS,CAAA,eACT,CAAc,CAAA,MACd,CAAK,CAAA,iBACL,CAAgB,CAAA,SAChB,CAAQ,CAAA,SACR,CAAQ,CACT,CAAG,EACE,CACJ,SAAU,EAAgB,CAAA,CAAI,CAC9B,UAAW,EAAiB,CAAA,CAAI,CAChC,mBAAoB,CAA2B,CAAA,iBAC/C,EAAmB,SAAA,CAAA,0BACnB,EAA4B,MAAA,CAAA,cAC5B,EAAgB,CAAA,CAAA,CAChB,GAAG,EACJ,CAAG,AAAA,EAAS,EAAS,GAMtB,GAAI,AAAkD,MAAjD,CAAA,EAAwB,EAAe,KAAI,AAAJ,GAAkB,EAAsB,eAAe,CACjG,MAAO,CAAC,EAEV,IAAM,EAAO,AAAA,EAAQ,GACf,EAAkB,AAAA,EAAY,GAC9B,EAAkB,AAAA,EAAQ,KAAsB,EAChD,EAAM,MAAO,CAAA,AAAkB,MAAlB,EAAS,KAAK,CAAW,KAAK,EAAI,EAAS,KAAK,CAAC,EAAS,QAAQ,CAAA,EAC/E,EAAqB,GAAgC,CAAA,GAAmB,CAAC,EAAgB,CAAC,AAAA,EAAqB,GAAkB,CAAG,AC5XhJ,SAA+B,CAAS,EACtC,IAAM,EAAoB,EAAqB,GAC/C,MAAO,CAAC,EAA8B,GAAY,EAAmB,EAA8B,GAAmB,AACxH,EDyXsK,EAAA,EAC1J,EAA+B,AAA8B,SAA9B,CACjC,EAAC,GAA+B,GAClC,EAAmB,IAAI,IAAI,ACvWnC,SAAmC,CAAS,CAAE,CAAa,CAAE,CAAS,CAAE,CAAG,EACzE,IAAM,EAAY,EAAa,GAC3B,EAAO,AAfb,SAAqB,CAAI,CAAE,CAAO,CAAE,CAAG,EACrC,OAAQ,GACN,IAAK,MACL,IAAK,SACH,GAAI,EAAK,OAAO,EAAU,EAAc,EACxC,OAAO,EAAU,EAAc,CACjC,KAAK,OACL,IAAK,QACH,OAAO,EAAU,EAAc,CACjC,SACE,MAAO,EAAE,AACb,CACF,EAGyB,EAAQ,GAAY,AAAc,UAAd,EAAuB,GAOlE,OANI,IACF,EAAO,EAAK,GAAG,CAAC,AAAA,GAAQ,EAAO,IAAM,GACjC,GACF,CAAA,EAAO,EAAK,MAAM,CAAC,EAAK,GAAG,CAAC,GAD9B,GAIK,CACT,ED6V6D,EAAkB,EAAe,EAA2B,IAEnH,IAAM,EAAa,CAAC,KAAqB,EAAmB,CACtD,EAAW,MAAM,EAAe,EAAO,GACvC,EAAY,EAAE,CAChB,EAAgB,AAAE,CAAA,AAA+C,MAA/C,CAAA,EAAuB,EAAe,IAAG,AAAH,EAAgB,KAAK,EAAI,EAAqB,SAAQ,AAAR,GAAc,EAAE,CAI1H,GAHI,GACF,EAAU,IAAI,CAAC,CAAQ,CAAC,EAAK,EAE3B,EAAgB,CAClB,IAAM,EAAQ,ACtZtB,SAA2B,CAAS,CAAE,CAAK,CAAE,CAAG,EAC1C,AAAQ,KAAK,IAAb,GACF,CAAA,EAAM,CAAA,CADR,EAGA,IAAM,EAAY,EAAa,GACzB,EAPC,EAAgB,EAOgB,IACjC,EAAS,EAAc,GACzB,EAAoB,AAAkB,MAAlB,EAAwB,IAAe,CAAA,EAAM,MAAQ,OAAA,EAAW,QAAU,OAAS,AAAc,UAAd,EAAwB,SAAW,MAI9I,OAHI,EAAM,SAAS,CAAC,EAAO,CAAG,EAAM,QAAQ,CAAC,EAAO,EAClD,CAAA,EAAoB,EAAqB,EAD3C,EAGO,CAAC,EAAmB,EAAqB,GAAmB,AACrE,ED0YwC,EAAW,EAAO,GAClD,EAAU,IAAI,CAAC,CAAQ,CAAC,CAAK,CAAC,EAAE,CAAC,CAAE,CAAQ,CAAC,CAAK,CAAC,EAAE,CAAC,CACvD,CAOA,GANA,EAAgB,IAAI,EAAe,CACjC,UAAA,EACA,UAAA,CACF,EAAE,CAGE,CAAC,EAAU,KAAK,CAAC,AAAA,GAAQ,GAAQ,GAAI,CAEvC,IAAM,EAAY,AAAE,CAAA,AAAC,CAAA,AAAgD,MAAhD,CAAA,EAAwB,EAAe,IAAI,AAAJ,EAAgB,KAAK,EAAI,EAAsB,KAAI,AAAJ,GAAU,CAAA,EAAK,EACpH,EAAgB,CAAU,CAAC,EAAU,CAC3C,GAAI,GAEE,CAAA,AAD+C,cAAnB,GAAiC,IAAoB,AAAA,EAAY,IAIjG,EAAc,KAAK,CAAC,AAAA,GAAK,EAAE,SAAS,CAAC,EAAE,CAAG,GAAK,AAAA,EAAY,EAAE,SAAS,IAAM,EAAA,EAE1E,MAAO,CACL,KAAM,CACJ,MAAO,EACP,UAAW,CACb,EACA,MAAO,CACL,UAAW,CACb,CACF,EAMJ,IAAI,EAAiB,AAA+H,MAA9H,CAAA,EAAwB,EAAc,MAAM,CAAC,AAAA,GAAK,EAAE,SAAS,CAAC,EAAE,EAAI,GAAG,IAAI,CAAC,CAAC,EAAG,IAAM,EAAE,SAAS,CAAC,EAAE,CAAG,EAAE,SAAS,CAAC,EAAE,CAAC,CAAC,EAAC,AAAD,EAAc,KAAK,EAAI,EAAsB,SAAS,CAGnM,GAAI,CAAC,EACH,OAAQ,GACN,IAAK,UACH,CAEE,IAAM,EAAY,AASuI,MATtI,CAAA,EAAyB,EAAc,MAAM,CAAC,AAAA,IAC/D,GAAI,EAA8B,CAChC,IAAM,EAAkB,AAAA,EAAY,EAAE,SAAS,EAC/C,OAAO,IAAoB,GAG3B,AAAoB,MAApB,CACF,CACA,MAAO,CAAA,CACT,GAAG,GAAG,CAAC,AAAA,GAAK,CAAC,EAAE,SAAS,CAAE,EAAE,SAAS,CAAC,MAAM,CAAC,AAAA,GAAY,EAAW,GAAG,MAAM,CAAC,CAAC,EAAK,IAAa,EAAM,EAAU,GAAG,EAAE,IAAI,CAAC,CAAC,EAAG,IAAM,CAAC,CAAC,EAAE,CAAG,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,AAAF,EAAc,KAAK,EAAI,CAAsB,CAAC,EAAE,AAC9L,CAAA,GACF,CAAA,EAAiB,CADnB,EAGA,KACF,CACF,IAAK,mBACH,EAAiB,CAErB,CAEF,GAAI,IAAc,EAChB,MAAO,CACL,MAAO,CACL,UAAW,CACb,CACF,CAEJ,CACA,MAAO,CAAC,CACV,CACF,CACF,EDkNM,GAAkB,CAAC,EAAW,EAAU,KAI5C,IAAM,EAAQ,IAAI,IACZ,EAAgB,CACpB,SAAA,GACA,GAAG,CAAO,AACZ,EACM,EAAoB,CACxB,GAAG,EAAc,QAAQ,CACzB,GAAI,CACN,EACA,OAAO,AAAA,EAAkB,EAAW,EAAU,CAC5C,GAAG,CAAa,CAChB,SAAU,CACZ,EACF,EDlvBM,GAAY,SAAS,aAAa,CAAiB,cACnD,GAAU,SAAS,aAAa,CAAiB,aACjD,GAAW,SAAS,gBAAgB,CAAoB,aACxD,GAAS,SAAS,aAAa,CAAc,WACtC,SAAS,aAAa,CAAc,SAGjD,MAAM,GAAe,SAAS,aAAa,CAAoB,oBACzD,GAAU,SAAS,aAAa,CAAc,YAoDpD,SAAS,KAED,OAAO,UAAU,EAAI,OACrB,IAAW,UAAU,OAAO,UAC5B,IAAS,UAAU,OAAO,UAGtB,IAAS,UAAU,SAAS,UAC5B,SAAS,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAG,SAE/B,SAAS,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAG,OAG3C,CAEA,SAAS,KAED,OAAO,UAAU,EAAI,OACrB,IAAW,UAAU,OAAO,UAC5B,IAAS,UAAU,OAAO,UAC1B,SAAS,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAG,OAEvC,CArEA,AAF4B,SAAS,gBAAgB,CAAC,kBAElC,OAAO,CAAC,AAAA,IAExB,IAAM,EAAc,AADF,EACY,OAAO,CAAC,OAAO,EAAI,GAE3C,EAAc,KACX,KACL,GAAQ,WAAW,CAAG,EACtB,GAAQ,SAAS,CAAC,GAAG,CAAC,WAEtB,AAAA,GARc,EAQa,GAAS,CAChC,UAAW,MACX,WAAY,CAAC,AAAA,GAAO,GAAI,AAAA,KAAQ,AAAA,GAAM,CAAE,QAAS,CAAE,GAAG,AAC1D,GAAG,IAAI,CAAC,CAAC,CAAA,EAAE,CAAC,CAAA,EAAE,CAAC,CAAE,IACb,OAAO,MAAM,CAAC,GAAQ,KAAK,CAAE,CACzB,KAAM,CAAA,EAAG,EAAE,EAAE,CAAC,CACd,IAAK,CAAA,EAAG,EAAE,EAAE,CAAC,AACjB,EACJ,GACJ,EAEM,EAAc,KACZ,IACA,GAAQ,SAAS,CAAC,MAAM,CAAC,UAEjC,EAEA,AAzBkB,EAyBR,gBAAgB,CAAC,aAAc,GACzC,AA1BkB,EA0BR,gBAAgB,CAAC,aAAc,GACzC,AA3BkB,EA2BR,gBAAgB,CAAC,QAAS,GACpC,AA5BkB,EA4BR,gBAAgB,CAAC,OAAQ,EACvC,GAGA,OAAO,gBAAgB,CAAC,SAAU,KAC1B,OAAO,OAAO,CAAG,IACjB,IAAc,UAAU,IAAI,WAE5B,IAAc,UAAU,OAAO,UAEvC,GAEA,IAAc,iBAAiB,QAAS,AAAC,IACrC,EAAE,cAAc,GAChB,SAAS,aAAa,CAAC,UAAU,eAAe,CAAE,SAAU,QAAS,EACzE,GA2BA,IAAW,iBAAiB,QAAS,AAAC,IAClC,EAAE,cAAc,GAChB,EAAE,eAAe,GACjB,IACJ,GAGA,IAAW,iBAAiB,aAAc,AAAC,IACvC,EAAE,cAAc,GAChB,EAAE,eAAe,EACrB,EAAG,CAAE,QAAS,CAAA,CAAM,GAEpB,IAAW,iBAAiB,WAAY,AAAC,IACrC,EAAE,cAAc,GAChB,EAAE,eAAe,GACjB,IACJ,EAAG,CAAE,QAAS,CAAA,CAAM,GAGpB,GAAS,OAAO,CAAC,AAAA,IACb,EAAK,gBAAgB,CAAC,QAAS,IAG/B,EAAK,gBAAgB,CAAC,WAAY,AAAC,IAE/B,WAAW,GAAiB,IAChC,EAAG,CAAE,QAAS,CAAA,CAAK,EACvB,GAGA,SAAS,gBAAgB,CAAC,QAAS,AAAC,IAChC,IAAM,EAAS,EAAE,MAAM,AACnB,CAAA,OAAO,UAAU,EAAI,MACrB,IAAS,UAAU,SAAS,WAC5B,CAAC,GAAQ,QAAQ,CAAC,IAClB,CAAC,IAAW,SAAS,IACrB,IAER,GAGA,SAAS,gBAAgB,CAAC,aAAc,AAAC,IACrC,IAAM,EAAS,EAAE,MAAM,AACnB,CAAA,OAAO,UAAU,EAAI,MACrB,IAAS,UAAU,SAAS,WAC5B,CAAC,GAAQ,QAAQ,CAAC,IAClB,CAAC,IAAW,SAAS,IACrB,IAER,EAAG,CAAE,QAAS,CAAA,CAAK,GAGnB,OAAO,gBAAgB,CAAC,SAAU,KAC1B,OAAO,UAAU,CAAG,OACpB,KAEA,SAAS,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAG,OAC/B,IAAW,UAAU,OAAO,UAC5B,IAAS,UAAU,OAAO,UAElC,GAGA,SAAS,gBAAgB,CAAC,UAAW,AAAC,IAC9B,AAAU,WAAV,EAAE,GAAG,EACL,OAAO,UAAU,EAAI,MACrB,IAAS,UAAU,SAAS,WAC5B,IAER,GAIA,SAAS,gBAAgB,CAAC,aAAc,AAAC,IACjC,OAAO,UAAU,EAAI,MAAQ,IAAS,UAAU,SAAS,WAChD,EAAE,OAAO,CAAC,EAAE,CAAC,OAAO,AAErC,EAAG,CAAE,QAAS,CAAA,CAAK,GAEnB,SAAS,gBAAgB,CAAC,YAAa,AAAC,IACpC,GAAI,OAAO,UAAU,EAAI,MAAQ,IAAS,UAAU,SAAS,UAAW,CACpE,IAAM,EAAS,EAAE,MAAM,AACnB,CAAC,GAAQ,QAAQ,CAAC,IAClB,EAAE,cAAc,EAExB,CACJ,EAAG,CAAE,QAAS,CAAA,CAAM,GAGpB,OAAO,gBAAgB,CAAC,SAAU,KAC1B,OAAO,OAAO,CAAG,IACjB,IAAQ,UAAU,IAAI,YAEtB,IAAQ,UAAU,OAAO,WAEjC,GAGA,OAAO,gBAAgB,CAAC,SAAU,KAC9B,IAAM,EAAU,OAAO,OAAO,CAC1B,EAAmB,GAEjB,EAAW,SAAS,gBAAgB,CAAc,eAWxD,GATA,EAAS,OAAO,CAAC,AAAA,IAGT,GAFe,EAAQ,SAAS,CAAG,IAGnC,CAAA,EAAmB,EAAQ,YAAY,CAAC,OAAS,EADrD,CAGJ,GAGI,OAAQ,WAAW,CAAG,OAAO,OAAO,EAAK,SAAS,IAAI,CAAC,YAAY,CAAG,EAAG,CACzE,IAAM,EAAc,CAAQ,CAAC,EAAS,MAAM,CAAG,EAAE,AAC7C,CAAA,GACA,CAAA,EAAmB,EAAY,YAAY,CAAC,OAAS,EADzD,CAGJ,CAEA,GAAS,OAAO,CAAC,AAAA,IACb,EAAK,SAAS,CAAC,MAAM,CAAC,UAClB,EAAK,YAAY,CAAC,UAAY,CAAC,CAAC,EAAE,EAAA,CAAkB,EACpD,EAAK,SAAS,CAAC,GAAG,CAAC,SAE3B,EACJ,GAuBA,MAAM,GAAW,IAAI,qBAAqB,AAAC,IACvC,EAAQ,OAAO,CAAC,AAAA,IACR,EAAM,cAAc,GACpB,EAAM,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,WAGvB,EAAM,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,mBAEhC,AADc,EAAM,MAAM,CAAC,gBAAgB,CAAC,mBACtC,OAAO,CAAC,CAAC,EAAM,KAChB,EAAqB,KAAK,CAAC,eAAe,CAAG,CAAA,EAAG,AAAQ,IAAR,EAAa,CAAC,CAAC,CAC/D,EAAqB,KAAK,CAAC,OAAO,CAAG,IACrC,EAAqB,KAAK,CAAC,SAAS,CAAG,wBAC5C,GAIA,EAAM,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,WAEhC,AADoB,EAAM,MAAM,CAAC,gBAAgB,CAAc,YACnD,OAAO,CAAC,AAAA,IAChB,IAAM,EAAS,SAAS,EAAK,OAAO,CAAC,MAAM,EAAI,KACzC,EAAS,EAAK,OAAO,CAAC,MAAM,EAAI,EAClC,CAAC,MAAM,IACP,AA1CxB,SAAwB,CAAoB,CAAE,CAAc,CAAE,EAAmB,GAAI,CAAE,EAAiB,EAAE,EACtG,IAAI,EAAQ,EACN,EAAY,EAAU,CAAA,EAAW,EAAA,EACjC,EAAQ,YAAY,KAElB,AADJ,CAAA,GAAS,CAAT,GACa,GACT,EAAQ,WAAW,CAAG,EAAO,QAAQ,GAAK,EAC1C,cAAc,IAEd,EAAQ,WAAW,CAAG,KAAK,KAAK,CAAC,GAAO,QAAQ,GAAK,CAE7D,EAAG,GACP,EA8BuC,EAAM,EAAQ,IAAM,EAE3C,GAEA,GAAS,SAAS,CAAC,EAAM,MAAM,GAG3C,EACJ,EAnCkD,CAC9C,UAAW,GACX,WAAY,mBAChB,GAqtBA,SAAS,KACL,IAAM,EAAgB,SAAS,gBAAgB,CAAC,kBAE1C,EAAmB,IAAI,qBAAqB,AAAC,IAC/C,EAAQ,OAAO,CAAC,AAAA,IACR,EAAM,cAAc,EACpB,EAAM,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,UAEnC,EACJ,EAAG,CAAE,UAAW,EAAI,GAEpB,EAAc,OAAO,CAAC,AAAA,IAClB,EAAiB,OAAO,CAAC,EAC7B,EACJ,CAmlCA,SAAS,gBAAgB,CAAC,mBAAoB,KAC1C,QAAQ,GAAG,CAAC,mDAIZ,AADa,SAAS,gBAAgB,CAAC,QAClC,OAAO,CAAC,CAAC,EAAK,KACd,EAAoB,KAAK,CAAC,cAAc,CAAG,CAAA,EAAG,AAAQ,IAAR,EAAa,CAAC,CAAC,AAClE,GAGA,IAAM,EAAe,SAAS,cAAc,CAAC,yBACvC,EAAiB,SAAS,cAAc,CAAC,oBACzC,EAAiB,SAAS,cAAc,CAAC,mBAE/C,QAAQ,GAAG,CAAC,yBAA0B,CAClC,OAAQ,CAAC,CAAC,EACV,SAAU,CAAC,CAAC,EACZ,SAAU,CAAC,CAAC,CAChB,GAEI,IACA,QAAQ,GAAG,CAAC,6CACZ,AA17BR,eAqBQ,EACA,EACA,EAtBJ,QAAQ,GAAG,CAAC,sCACZ,IAAM,EAAS,SAAS,cAAc,CAAC,yBACvC,GAAI,CAAC,EAAQ,OACT,QAAQ,KAAK,CAAC,oCAGlB,QAAQ,GAAG,CAAC,sDAEZ,IAAM,EAAM,EAAO,UAAU,CAAC,MAC9B,GAAI,CAAC,EAAK,OACN,QAAQ,KAAK,CAAC,uDAIlB,IAAM,EAAQ,CAAE,EAAG,EAAG,EAAG,CAAE,EAC3B,OAAO,gBAAgB,CAAC,YAAa,AAAA,IACjC,EAAM,CAAC,CAAG,EAAE,OAAO,CACnB,EAAM,CAAC,CAAG,EAAE,OAAO,AACvB,GAKA,IAAI,EAAO,EAEL,EAAe,KACjB,EAAO,KAAK,CAAG,OAAO,UAAU,CAChC,EAAO,MAAM,CAAG,OAAO,WAAW,CAElC,EAAQ,EAAE,CACV,IAAM,EAAY,OAAO,UAAU,CAAG,IAAM,GAAK,IACjD,IAAK,IAAI,EAAI,EAAG,EAAI,EAAW,IAC3B,EAAM,IAAI,CAAC,CACP,EAAG,KAAK,MAAM,GAAK,EAAO,KAAK,CAC/B,EAAG,KAAK,MAAM,GAAK,EAAO,MAAM,CAChC,GAAK,AAAA,CAAA,KAAK,MAAM,GAAK,EAAA,EAAO,GAC5B,GAAK,AAAA,CAAA,KAAK,MAAM,GAAK,EAAA,EAAO,GAC5B,WAAY,AAAgB,IAAhB,KAAK,MAAM,GAAW,GAClC,WAAY,KAAK,MAAM,GAAK,KAAK,EAAE,CACnC,MAAO,KAAK,MAAM,GAAK,GAAM,UAAY,UACzC,OAAQ,KAAK,MAAM,GACnB,MAAO,KAAK,KAAK,CAAC,AAAgB,EAAhB,KAAK,MAAM,IAC7B,WAAY,KAAK,MAAM,GAAK,GAC5B,YAAa,EAAE,CACf,YAAa,EACb,cAAe,AAAgB,GAAhB,KAAK,MAAM,GAAW,EACzC,GAIJ,EAAM,OAAO,CAAC,CAAC,EAAM,KACjB,EAAM,OAAO,CAAC,CAAC,EAAW,KAClB,IAAM,GAEF,AAAO,IADE,KAAK,IAAI,CAAC,KAAK,GAAG,CAAC,EAAK,CAAC,CAAG,EAAU,CAAC,CAAE,GAAK,KAAK,GAAG,CAAC,EAAK,CAAC,CAAG,EAAU,CAAC,CAAE,KACxE,KAAK,MAAM,GAAK,IAC9B,EAAK,WAAW,CAAC,IAAI,CAAC,EAGlC,EACJ,GAEA,EAAY,EAAE,CAEd,IAAK,IAAI,EAAI,EAAG,EADM,GACa,IAC/B,EAAU,IAAI,CAAC,CACX,EAAG,KAAK,MAAM,GAAK,EAAO,KAAK,CAC/B,EAAG,KAAK,MAAM,GAAK,EAAO,MAAM,CAChC,GAAK,AAAA,CAAA,KAAK,MAAM,GAAK,EAAA,EAAO,EAC5B,GAAK,AAAA,CAAA,KAAK,MAAM,GAAK,EAAA,EAAO,EAC5B,KAAM,KAAK,MAAM,GACjB,QAAS,CAAA,KAAK,MAAM,GAAS,GAC7B,KAAM,AAAgB,EAAhB,KAAK,MAAM,GAAS,GAC1B,WAAY,KAAK,KAAK,CAAC,KAAK,MAAM,GAAK,EAAM,MAAM,EACnD,MAAO,KAAK,MAAM,GAAK,GAAM,UAAY,SAC7C,GAGJ,EAAW,EAAE,AACjB,EAuMM,EAAU,KACZ,AAtMS,CAAA,KACT,GAAK,GACL,EAAI,SAAS,CAAC,EAAG,EAAG,EAAO,KAAK,CAAE,EAAO,MAAM,EAC/C,GAAQ,KAGR,IAAK,IAAI,EAAI,EAAG,EAAI,GAAI,IAAK,CACzB,IAAM,EAAI,KAAK,MAAM,GAAK,EAAO,KAAK,CAChC,EAAI,KAAK,MAAM,GAAK,EAAO,MAAM,CACjC,EAAO,AAAgB,IAAhB,KAAK,MAAM,GAClB,EAAQ,AAAgB,IAAhB,KAAK,MAAM,GACzB,EAAI,SAAS,GACb,EAAI,GAAG,CAAC,EAAG,EAAG,EAAM,EAAG,AAAU,EAAV,KAAK,EAAE,EAC9B,EAAI,SAAS,CAAG,CAAC,oBAAoB,EAAE,EAAM,CAAC,CAAC,CAC/C,EAAI,IAAI,EACZ,CAGA,EAAU,OAAO,CAAC,AAAA,IACd,IAAM,EAAa,CAAK,CAAC,EAAS,UAAU,CAAC,CACvC,EAAK,EAAW,CAAC,CAAG,EAAS,CAAC,CAC9B,EAAK,EAAW,CAAC,CAAG,EAAS,CAAC,CAC9B,EAAO,KAAK,IAAI,CAAC,EAAK,EAAK,EAAK,GAElC,EAAO,IACP,EAAS,EAAE,EAAI,AAAK,KAAL,EACf,EAAS,EAAE,EAAI,AAAK,KAAL,GAGnB,EAAS,CAAC,EAAI,EAAS,EAAE,CACzB,EAAS,CAAC,EAAI,EAAS,EAAE,CACzB,EAAS,IAAI,EAAI,KAEb,CAAA,EAAS,IAAI,CAAG,EAAS,OAAO,EAAI,EAAO,CAAA,IAC3C,EAAS,IAAI,CAAG,EAChB,EAAS,CAAC,CAAG,KAAK,MAAM,GAAK,EAAO,KAAK,CACzC,EAAS,CAAC,CAAG,KAAK,MAAM,GAAK,EAAO,MAAM,CAC1C,EAAS,UAAU,CAAG,KAAK,KAAK,CAAC,KAAK,MAAM,GAAK,EAAM,MAAM,GAGjE,IAAM,EAAS,AAAA,CAAA,EAAI,EAAS,IAAI,CAAG,EAAS,OAAO,AAAP,EAAW,GACvD,EAAI,SAAS,GACb,EAAI,GAAG,CAAC,EAAS,CAAC,CAAE,EAAS,CAAC,CAAE,EAAS,IAAI,CAAE,EAAG,AAAU,EAAV,KAAK,EAAE,EACzD,IAAM,EAAqB,AAAgD,IAAhD,KAAK,KAAK,CAAC,AAAQ,IAAR,GAAa,QAAQ,CAAC,IAAI,MAAM,CAAS,IAAM,KAAK,KAAK,CAAC,AAAQ,IAAR,GAAa,QAAQ,CAAC,IAAM,KAAK,KAAK,CAAC,AAAQ,IAAR,GAAa,QAAQ,CAAC,GAC7J,CAAA,EAAI,SAAS,CAAG,CAAA,EAAG,EAAS,KAAK,CAAA,EAAG,EAAA,CAAoB,CACxD,EAAI,IAAI,EACZ,GAGA,IAAK,IAAI,EAAQ,EAAG,EAAQ,EAAG,IAC3B,EAAM,MAAM,CAAC,AAAA,GAAQ,EAAK,KAAK,GAAK,GAAO,OAAO,CAAC,AAAA,IAC/C,EAAK,CAAC,EAAI,EAAK,EAAE,CACjB,EAAK,CAAC,EAAI,EAAK,EAAE,CACjB,EAAK,MAAM,EAAI,KAEX,CAAA,EAAK,CAAC,CAAG,GAAK,EAAK,CAAC,CAAG,EAAO,KAAK,AAAL,GAAO,CAAA,EAAK,EAAE,EAAI,EAApD,EACI,CAAA,EAAK,CAAC,CAAG,GAAK,EAAK,CAAC,CAAG,EAAO,MAAM,AAAN,GAAQ,CAAA,EAAK,EAAE,EAAI,EAArD,EAEA,EAAK,UAAU,EAAI,IACnB,IAAM,EAAe,AAAA,CAAA,KAAK,GAAG,CAAC,EAAK,UAAU,EAAI,CAAA,EAAK,EAChD,EAAgB,EAAK,UAAU,CAAG,AAAc,IAAd,EAIlC,EAAiB,KAAK,GAAG,CAAC,EAAG,EAAI,AADnB,KAAK,IAAI,CAAC,KAAK,GAAG,CAAC,EAAK,CAAC,CAAG,EAAM,CAAC,CAAE,GAAK,KAAK,GAAG,CAAC,EAAK,CAAC,CAAG,EAAM,CAAC,CAAE,IACpC,IAGjD,CAAA,EAAK,UAAU,EAAI,AAAgB,IAAhB,KAAK,MAAM,IAC9B,EAAS,IAAI,CAAC,CACV,EAAG,EAAK,CAAC,CACT,EAAG,EAAK,CAAC,CACT,KAAM,EACN,QAAS,IACT,YAAa,IAAI,EAAK,WAAW,CAAC,CAClC,QAAS,IAAI,IACb,MAAO,EAAK,KAAK,AACrB,GAIJ,IAAM,EAAa,EAAgB,AAAiB,GAAjB,EAAsB,AAAC,CAAA,EAAI,CAAA,EAAS,EACjE,EAAW,EAAI,oBAAoB,CAAC,EAAK,CAAC,CAAE,EAAK,CAAC,CAAE,EAAG,EAAK,CAAC,CAAE,EAAK,CAAC,CAAE,GACvE,EAAU,AAAC,CAAA,GAAM,AAAQ,GAAR,CAAQ,EAAO,EAAK,aAAa,CAClD,EAAc,AAAkD,IAAlD,KAAK,KAAK,CAAC,AAAU,IAAV,GAAe,QAAQ,CAAC,IAAI,MAAM,CAAS,IAAM,KAAK,KAAK,CAAC,AAAU,IAAV,GAAe,QAAQ,CAAC,IAAM,KAAK,KAAK,CAAC,AAAU,IAAV,GAAe,QAAQ,CAAC,IACtJ,EAAc,AAAwD,IAAxD,KAAK,KAAK,CAAC,AAAA,KAAA,GAAqB,QAAQ,CAAC,IAAI,MAAM,CAAS,IAAM,KAAK,KAAK,CAAC,AAAA,KAAA,GAAqB,QAAQ,CAAC,IAAM,KAAK,KAAK,CAAC,AAAA,KAAA,GAAqB,QAAQ,CAAC,IAC9K,EAAS,YAAY,CAAC,EAAG,CAAA,EAAG,EAAK,KAAK,CAAA,EAAG,EAAA,CAAa,EACtD,EAAS,YAAY,CAAC,GAAK,CAAA,EAAG,EAAK,KAAK,CAAA,EAAG,EAAA,CAAa,EACxD,EAAS,YAAY,CAAC,EAAG,eAEzB,EAAI,SAAS,GACb,EAAI,GAAG,CAAC,EAAK,CAAC,CAAE,EAAK,CAAC,CAAE,EAAY,EAAG,AAAU,EAAV,KAAK,EAAE,EAC9C,EAAI,SAAS,CAAG,EAChB,EAAI,IAAI,GAGR,EAAI,SAAS,GACb,EAAI,GAAG,CAAC,EAAK,CAAC,CAAE,EAAK,CAAC,CAAE,EAAe,EAAG,AAAU,EAAV,KAAK,EAAE,EACjD,IAAM,EAAc,KAAK,KAAK,CAAC,AAAC,CAAA,GAAM,AAAc,GAAd,EAAoB,AAAiB,GAAjB,CAAiB,EAAO,KAC5E,EAAiB,AAAoC,IAApC,EAAY,QAAQ,CAAC,IAAI,MAAM,CAAS,IAAM,EAAY,QAAQ,CAAC,IAAM,EAAY,QAAQ,CAAC,GACrH,CAAA,EAAI,SAAS,CAAG,CAAA,EAAG,EAAK,KAAK,CAAA,EAAG,EAAA,CAAgB,CAChD,EAAI,IAAI,GAGR,EAAI,SAAS,GACb,EAAI,GAAG,CAAC,EAAK,CAAC,CAAG,AAAgB,IAAhB,EAAsB,EAAK,CAAC,CAAG,AAAgB,IAAhB,EAAsB,AAAgB,GAAhB,EAAqB,EAAG,AAAU,EAAV,KAAK,EAAE,EACrG,EAAI,SAAS,CAAG,CAAC,oBAAoB,EAAE,GAAM,AAAc,GAAd,EAAkB,CAAC,CAAC,CACjE,EAAI,IAAI,GAGJ,EAAK,UAAU,GACf,EAAI,SAAS,GACb,EAAI,GAAG,CAAC,EAAK,CAAC,CAAE,EAAK,CAAC,CAAE,EAAgB,EAAG,EAAG,AAAU,EAAV,KAAK,EAAE,EACrD,EAAI,WAAW,CAAG,CAAC,kBAAkB,EAAE,AAAc,GAAd,EAAkB,CAAC,CAAC,CAC3D,EAAI,SAAS,CAAG,EAChB,EAAI,MAAM,GAElB,GAIJ,EAAS,OAAO,CAAC,CAAC,EAAS,KAEvB,GADA,EAAQ,IAAI,EAAI,KACZ,EAAQ,IAAI,CAAG,EAAQ,OAAO,CAAE,YAChC,EAAS,MAAM,CAAC,EAAO,GAI3B,IAAM,EAAS,AAAA,CAAA,EAAI,EAAQ,IAAI,CAAG,EAAQ,OAAO,AAAP,EAAW,GAC/C,EAAS,AAAe,GAAf,EAAQ,IAAI,CAGrB,EAAqB,AAAgD,IAAhD,KAAK,KAAK,CAAC,AAAQ,IAAR,GAAa,QAAQ,CAAC,IAAI,MAAM,CAAS,IAAM,KAAK,KAAK,CAAC,AAAQ,IAAR,GAAa,QAAQ,CAAC,IAAM,KAAK,KAAK,CAAC,AAAQ,IAAR,GAAa,QAAQ,CAAC,IACvJ,EAAqB,AAAsD,IAAtD,KAAK,KAAK,CAAC,AAAA,MAAA,GAAmB,QAAQ,CAAC,IAAI,MAAM,CAAS,IAAM,KAAK,KAAK,CAAC,AAAA,MAAA,GAAmB,QAAQ,CAAC,IAAM,KAAK,KAAK,CAAC,AAAA,MAAA,GAAmB,QAAQ,CAAC,IACzK,EAAW,EAAI,oBAAoB,CAAC,EAAQ,CAAC,CAAE,EAAQ,CAAC,CAAE,EAAG,EAAQ,CAAC,CAAE,EAAQ,CAAC,CAAE,GACzF,EAAS,YAAY,CAAC,EAAG,CAAA,EAAG,EAAQ,KAAK,CAAA,EAAG,EAAA,CAAoB,EAChE,EAAS,YAAY,CAAC,GAAK,CAAA,EAAG,EAAQ,KAAK,CAAA,EAAG,EAAA,CAAoB,EAClE,EAAS,YAAY,CAAC,EAAG,eAEzB,EAAI,SAAS,GACb,EAAI,GAAG,CAAC,EAAQ,CAAC,CAAE,EAAQ,CAAC,CAAE,EAAQ,EAAG,AAAU,EAAV,KAAK,EAAE,EAChD,EAAI,SAAS,CAAG,EAChB,EAAI,IAAI,EACZ,GAGA,EAAM,OAAO,CAAC,CAAC,EAAM,KACjB,EAAK,WAAW,CAAC,OAAO,CAAC,AAAC,IACtB,IAAM,EAAgB,CAAK,CAAC,EAAgB,CACtC,EAAO,KAAK,IAAI,CAAC,KAAK,GAAG,CAAC,EAAK,CAAC,CAAG,EAAc,CAAC,CAAE,GAAK,KAAK,GAAG,CAAC,EAAK,CAAC,CAAG,EAAc,CAAC,CAAE,IAElG,GAAI,EAAO,IAAK,CACZ,IAAM,EAAc,KAAK,GAAG,CACxB,KAAK,IAAI,CAAC,KAAK,GAAG,CAAC,EAAK,CAAC,CAAG,EAAM,CAAC,CAAE,GAAK,KAAK,GAAG,CAAC,EAAK,CAAC,CAAG,EAAM,CAAC,CAAE,IACrE,KAAK,IAAI,CAAC,KAAK,GAAG,CAAC,EAAc,CAAC,CAAG,EAAM,CAAC,CAAE,GAAK,KAAK,GAAG,CAAC,EAAc,CAAC,CAAG,EAAM,CAAC,CAAE,KAGvF,EAAU,AAAC,CAAA,EAAI,EAAO,GAAA,EAAO,EAC7B,CAAA,EAAc,KACd,CAAA,EAAU,KAAK,GAAG,CAAC,EAAG,EAAW,AAAA,CAAA,EAAI,EAAc,GAAA,EAAO,GAD9D,EAKA,IAAM,EAAa,AAA2C,GAA3C,KAAK,GAAG,CAAC,AAAO,EAAP,EAAW,EAAI,GAAyB,GAI9D,EAAwB,AAAkD,IAAlD,KAAK,KAAK,CAAC,AAAU,IAHnD,CAAA,GAAY,GAAM,AAAa,GAAb,CAAlB,GAGwD,QAAQ,CAAC,IAAI,MAAM,CAAS,IAAM,KAAK,KAAK,CAAC,AAAU,IAAV,GAAe,QAAQ,CAAC,IAAM,KAAK,KAAK,CAAC,AAAU,IAAV,GAAe,QAAQ,CAAC,IAChK,EAAwB,AAAkD,IAAlD,KAAK,KAAK,CAAC,AAAU,IAAV,GAAe,QAAQ,CAAC,IAAI,MAAM,CAAS,IAAM,KAAK,KAAK,CAAC,AAAU,IAAV,GAAe,QAAQ,CAAC,IAAM,KAAK,KAAK,CAAC,AAAU,IAAV,GAAe,QAAQ,CAAC,IAChK,EAAW,EAAI,oBAAoB,CAAC,EAAK,CAAC,CAAE,EAAK,CAAC,CAAE,EAAc,CAAC,CAAE,EAAc,CAAC,EAc1F,GAbA,EAAS,YAAY,CAAC,EAAG,CAAA,EAAG,EAAK,KAAK,CAAA,EAAG,EAAA,CAAuB,EAChE,EAAS,YAAY,CAAC,GAAK,CAAC,oBAAoB,EAAE,AAAU,GAAV,EAAc,CAAC,CAAC,EAClE,EAAS,YAAY,CAAC,GAAK,CAAC,oBAAoB,EAAE,AAAU,GAAV,EAAc,CAAC,CAAC,EAClE,EAAS,YAAY,CAAC,EAAG,CAAA,EAAG,EAAc,KAAK,CAAA,EAAG,EAAA,CAAuB,EAEzE,EAAI,SAAS,GACb,EAAI,MAAM,CAAC,EAAK,CAAC,CAAE,EAAK,CAAC,EACzB,EAAI,MAAM,CAAC,EAAc,CAAC,CAAE,EAAc,CAAC,EAC3C,EAAI,WAAW,CAAG,EAClB,EAAI,SAAS,CAAG,EAAI,AAAa,IAAb,EACpB,EAAI,MAAM,GAGN,AAAgB,IAAhB,KAAK,MAAM,GAAW,CACtB,IAAM,EAAI,KAAK,MAAM,GACf,EAAI,EAAK,CAAC,CAAG,AAAC,CAAA,EAAc,CAAC,CAAG,EAAK,CAAA,AAAA,EAAK,EAC1C,EAAI,EAAK,CAAC,CAAG,AAAC,CAAA,EAAc,CAAC,CAAG,EAAK,CAAA,AAAA,EAAK,EAEhD,EAAI,SAAS,GACb,EAAI,GAAG,CAAC,EAAG,EAAG,GAAK,EAAG,AAAU,EAAV,KAAK,EAAE,EAC7B,EAAI,SAAS,CAAG,CAAC,oBAAoB,EAAE,EAAQ,CAAC,CAAC,CACjD,EAAI,IAAI,EACZ,CACJ,CACJ,EACJ,GACJ,CAAA,IAII,sBAAsB,EAC1B,EAEA,OAAO,gBAAgB,CAAC,SAAU,GAClC,IACA,GACJ,KA8pBQ,IACA,QAAQ,GAAG,CAAC,wCACZ,AA3pBR,eAqBQ,EAEA,EAtBJ,QAAQ,GAAG,CAAC,iCACZ,IAAM,EAAS,SAAS,cAAc,CAAC,oBACvC,GAAI,CAAC,EAAQ,OACT,QAAQ,KAAK,CAAC,+BAGlB,QAAQ,GAAG,CAAC,iDAEZ,IAAM,EAAM,EAAO,UAAU,CAAC,MAC9B,GAAI,CAAC,EAAK,OACN,QAAQ,KAAK,CAAC,kDAIlB,IAAM,EAAQ,CAAE,EAAG,EAAG,EAAG,CAAE,EAC3B,OAAO,gBAAgB,CAAC,YAAa,AAAA,IACjC,EAAM,CAAC,CAAG,EAAE,OAAO,CACnB,EAAM,CAAC,CAAG,EAAE,OAAO,AACvB,GAGA,IAAI,EAAO,EAIL,EAAY,CACd,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,KAAM,MAC3C,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxC,MAAO,OAAQ,MAAO,MAAO,OAAQ,OAAQ,MAC7C,MAAO,MAAO,OAAQ,KAAM,MAAO,MAAO,MAC1C,MAAO,MAAO,MAAO,MAAO,OAAQ,OACvC,CAEK,EAAe,KACjB,EAAO,KAAK,CAAG,OAAO,UAAU,CAChC,EAAO,MAAM,CAAG,OAAO,WAAW,CAElC,EAAY,EAAE,CAEd,IAAK,IAAI,EAAI,EAAG,EADM,IACa,IAAK,CACpC,IAAM,EAAW,AAAgB,IAAhB,KAAK,MAAM,GAC5B,EAAU,IAAI,CAAC,CACX,EAAG,KAAK,MAAM,GAAK,EAAO,KAAK,CAC/B,EAAG,KAAK,MAAM,GAAK,EAAO,MAAM,CAChC,MAAO,AAAgB,EAAhB,KAAK,MAAM,GAAS,GAC3B,KAAM,AAAgB,EAAhB,KAAK,MAAM,GAAS,EAC1B,OAAQ,AAAgB,GAAhB,KAAK,MAAM,GAAU,GAC7B,QAAS,AAAgB,GAAhB,KAAK,MAAM,GAAW,GAC/B,KAAM,EAAW,SAAW,OAC5B,OAAQ,CAAS,CAAC,KAAK,KAAK,CAAC,KAAK,MAAM,GAAK,EAAU,MAAM,EAAE,CAC/D,MAAO,KAAK,MAAM,GAAK,GAAM,UAAY,UACzC,MAAO,KAAK,MAAM,GAAK,KAAK,EAAE,CAC9B,WAAY,KAAK,MAAM,GAAK,KAAK,EAAE,CAAG,EACtC,WAAY,KAAK,MAAM,GAAK,IAC5B,YAAa,AAAgB,IAAhB,KAAK,MAAM,GACxB,eAAgB,GAChB,cAAe,AAAgB,GAAhB,KAAK,MAAM,GAAW,EACzC,EACJ,CAGA,EAAS,EAAE,CACX,IAAK,IAAI,EAAI,EAAG,EAAI,GAAI,IACpB,EAAO,IAAI,CAAC,CACR,EAAG,KAAK,MAAM,GAAK,EAAO,KAAK,CAC/B,EAAG,EAAO,MAAM,CAAG,AAAgB,GAAhB,KAAK,MAAM,GAC9B,OAAQ,CAAS,CAAC,KAAK,KAAK,CAAC,KAAK,MAAM,GAAK,EAAU,MAAM,EAAE,CAC/D,MAAO,AAAgB,IAAhB,KAAK,MAAM,GAClB,MAAO,KAAK,MAAM,GAAK,GAAM,UAAY,SAC7C,EAER,EAkKM,EAAU,KACZ,AAjKS,CAAA,KACT,GAAK,GAwGL,GAvGA,EAAI,SAAS,CAAC,EAAG,EAAG,EAAO,KAAK,CAAE,EAAO,MAAM,EAC/C,GAAQ,IAGR,EAAO,OAAO,CAAC,AAAA,IACX,EAAK,KAAK,GACN,EAAK,KAAK,EAAI,IACd,EAAK,CAAC,EAAI,GACV,EAAI,IAAI,CAAG,iBACX,EAAI,SAAS,CAAG,CAAA,EAAG,EAAK,KAAK,CAAC,EAAE,CAAC,CACjC,EAAI,SAAS,CAAG,SAChB,EAAI,QAAQ,CAAC,EAAK,MAAM,CAAE,EAAK,CAAC,CAAE,EAAK,CAAC,EAEhD,GAEA,EAAU,OAAO,CAAC,AAAA,IACd,EAAE,CAAC,EAAI,EAAE,KAAK,CACd,EAAE,KAAK,EAAI,IAGX,IAAM,EAAO,AAAgC,EAAhC,KAAK,GAAG,CAAC,EAAO,EAAE,UAAU,CACzC,CAAA,EAAE,CAAC,EAAI,AAAO,IAAP,EAGP,EAAE,CAAC,EAAK,AAAA,CAAA,KAAK,MAAM,GAAK,EAAA,EAAO,GAE3B,EAAE,CAAC,CAAG,CAAC,EAAE,MAAM,GACf,EAAE,CAAC,CAAG,EAAO,MAAM,CAAG,EAAE,MAAM,CAC9B,EAAE,CAAC,CAAG,KAAK,MAAM,GAAK,EAAO,KAAK,CAClC,EAAE,UAAU,CAAG,KAAK,MAAM,GAAK,IAC/B,EAAE,cAAc,CAAG,EAAE,MAAM,CACvB,EAAE,UAAU,EACZ,CAAA,EAAE,MAAM,CAAG,KADf,GAOJ,IAAM,EAAiB,KAAK,GAAG,CAAC,EAAG,EAAI,AADnB,KAAK,IAAI,CAAC,KAAK,GAAG,CAAC,EAAE,CAAC,CAAG,EAAM,CAAC,CAAE,GAAK,KAAK,GAAG,CAAC,EAAE,CAAC,CAAG,EAAM,CAAC,CAAE,IAC9B,KAK/C,EAAe,AAFG,CAAA,EAAE,OAAO,CAAG,AAAiB,GAAjB,CAApC,EAEwC,CAAA,GAAM,AAAc,GADvC,CAAA,AAAA,CAAA,KAAK,GAAG,CAAC,EAAE,KAAK,EAAI,CAAA,EAAK,CAAA,CACc,EAAO,EAAE,aAAa,CAElF,GAAI,AAAW,SAAX,EAAE,IAAI,CAAa,CAEnB,IAAM,EAAiB,AAAuD,IAAvD,KAAK,KAAK,CAAC,AAAe,IAAf,GAAoB,QAAQ,CAAC,IAAI,MAAM,CAAS,IAAM,KAAK,KAAK,CAAC,AAAe,IAAf,GAAoB,QAAQ,CAAC,IAAM,KAAK,KAAK,CAAC,AAAe,IAAf,GAAoB,QAAQ,CAAC,IACxK,EAAW,EAAI,oBAAoB,CAAC,EAAE,CAAC,CAAE,EAAE,CAAC,CAAE,EAAE,CAAC,CAAE,EAAE,CAAC,CAAG,EAAE,MAAM,EACvE,EAAS,YAAY,CAAC,EAAG,CAAA,EAAG,EAAE,KAAK,CAAA,EAAG,EAAA,CAAgB,EACtD,EAAS,YAAY,CAAC,GAAK,CAAC,oBAAoB,EAAE,AAAe,GAAf,EAAmB,CAAC,CAAC,EACvE,EAAS,YAAY,CAAC,GAAK,CAAC,oBAAoB,EAAE,EAAa,CAAC,CAAC,EACjE,EAAS,YAAY,CAAC,GAAK,CAAC,oBAAoB,EAAE,AAAe,GAAf,EAAmB,CAAC,CAAC,EACvE,EAAS,YAAY,CAAC,EAAG,CAAA,EAAG,EAAE,KAAK,CAAA,EAAG,EAAA,CAAgB,EAEtD,EAAI,SAAS,GACb,EAAI,MAAM,CAAC,EAAE,CAAC,CAAE,EAAE,CAAC,EACnB,EAAI,MAAM,CAAC,EAAE,CAAC,CAAE,EAAE,CAAC,CAAG,EAAE,MAAM,EAC9B,EAAI,WAAW,CAAG,EAClB,EAAI,SAAS,CAAG,EAAE,IAAI,CAAG,AAAiB,IAAjB,EACzB,EAAI,MAAM,GAGN,EAAiB,KACjB,EAAI,SAAS,GACb,EAAI,MAAM,CAAC,EAAE,CAAC,CAAE,EAAE,CAAC,EACnB,EAAI,MAAM,CAAC,EAAE,CAAC,CAAE,EAAE,CAAC,CAAG,EAAE,MAAM,EAC9B,EAAI,WAAW,CAAG,CAAC,oBAAoB,EAAE,AAAiB,GAAjB,EAAqB,CAAC,CAAC,CAChE,EAAI,SAAS,CAAG,EAAE,IAAI,CAAG,AAAiB,EAAjB,EACzB,EAAI,MAAM,GAElB,KAAO,CAEH,EAAI,IAAI,CAAG,CAAA,EAAG,AAAS,EAAT,EAAE,IAAI,CAAK,2BAA2B,CAAC,CACrD,IAAM,EAAmB,AAAuD,IAAvD,KAAK,KAAK,CAAC,AAAe,IAAf,GAAoB,QAAQ,CAAC,IAAI,MAAM,CAAS,IAAM,KAAK,KAAK,CAAC,AAAe,IAAf,GAAoB,QAAQ,CAAC,IAAM,KAAK,KAAK,CAAC,AAAe,IAAf,GAAoB,QAAQ,CAAC,GAG5K,CAAA,EAAE,UAAU,CACZ,EAAI,SAAS,CAAG,CAAC,gBAAgB,EAAE,EAAa,CAAC,CAAC,CAElD,EAAI,SAAS,CAAG,CAAA,EAAG,EAAE,KAAK,CAAA,EAAG,EAAA,CAAkB,CAGnD,EAAI,SAAS,CAAG,SAChB,EAAI,QAAQ,CAAC,EAAE,MAAM,CAAE,EAAE,CAAC,CAAE,EAAE,CAAC,EAG3B,EAAiB,KACjB,EAAI,IAAI,CAAG,CAAA,EAAG,AAAS,EAAT,EAAE,IAAI,CAAK,2BAA2B,CAAC,CACrD,EAAI,SAAS,CAAG,CAAC,oBAAoB,EAAE,AAAiB,GAAjB,EAAqB,CAAC,CAAC,CAC9D,EAAI,QAAQ,CAAC,EAAE,MAAM,CAAE,EAAE,CAAC,CAAE,EAAE,CAAC,EAEvC,CAGI,EAAiB,GACjB,EAAE,KAAK,CAAG,KAAK,GAAG,CAAC,AAAU,KAAV,EAAE,KAAK,CAAS,GAEnC,EAAE,KAAK,CAAG,KAAK,GAAG,CAAC,AAAU,KAAV,EAAE,KAAK,CAAU,GAE5C,GAGI,AAAgB,IAAhB,KAAK,MAAM,GAAW,CACtB,IAAM,EAAW,KAAK,MAAM,GAAK,EAAO,KAAK,CACvC,EAAW,KAAK,MAAM,GAAK,EAAO,MAAM,CAGxC,EAAW,EAAI,oBAAoB,CAAC,EAAU,EAAU,EAAG,EAAU,EAAU,GACrF,EAAS,YAAY,CAAC,EAAG,wBACzB,EAAS,YAAY,CAAC,GAAK,wBAC3B,EAAS,YAAY,CAAC,EAAG,eAEzB,EAAI,SAAS,GACb,EAAI,GAAG,CAAC,EAAU,EAAU,EAAG,EAAG,AAAU,EAAV,KAAK,EAAE,EACzC,EAAI,SAAS,CAAG,EAChB,EAAI,IAAI,GAER,EAAI,IAAI,CAAG,iBACX,EAAI,SAAS,CAAG,uBAChB,EAAI,SAAS,CAAG,SAChB,EAAI,QAAQ,CAAC,MAAO,EAAU,EAAW,GAC7C,CAGA,GAAI,AAAgB,KAAhB,KAAK,MAAM,GAAY,CACvB,IAAM,EAAU,KAAK,MAAM,GAAK,EAAO,KAAK,CACtC,EAAU,EAAO,MAAM,CAGvB,EAAW,EAAI,oBAAoB,CAAC,EAAS,EAAS,EAAG,EAAS,EAAS,GACjF,EAAS,YAAY,CAAC,EAAG,wBACzB,EAAS,YAAY,CAAC,GAAK,wBAC3B,EAAS,YAAY,CAAC,EAAG,eAEzB,EAAI,SAAS,GACb,EAAI,GAAG,CAAC,EAAS,EAAS,EAAG,EAAG,AAAU,EAAV,KAAK,EAAE,EACvC,EAAI,SAAS,CAAG,EAChB,EAAI,IAAI,GAER,EAAI,IAAI,CAAG,iBACX,EAAI,SAAS,CAAG,uBAChB,EAAI,SAAS,CAAG,SAChB,EAAI,QAAQ,CAAC,MAAO,EAAS,EAAU,GAC3C,CAGA,GAAI,AAAgB,IAAhB,KAAK,MAAM,GAAW,CACtB,IAAM,EAAU,KAAK,MAAM,GAAK,EAAO,KAAK,CAC5C,IAAK,IAAI,EAAI,EAAG,EAAI,GAAI,IACpB,EAAI,SAAS,GACb,EAAI,GAAG,CAAC,EAAW,AAAA,CAAA,KAAK,MAAM,GAAK,EAAA,EAAO,GAAI,EAAO,MAAM,CAAG,AAAI,GAAJ,EAAQ,EAAG,EAAG,AAAU,EAAV,KAAK,EAAE,EACnF,EAAI,SAAS,CAAG,CAAC,oBAAoB,EAAE,GAAM,AAAI,IAAJ,EAAS,CAAC,CAAC,CACxD,EAAI,IAAI,EAEhB,EACJ,CAAA,IAII,sBAAsB,EAC1B,EAEA,OAAO,gBAAgB,CAAC,SAAU,GAClC,IACA,GACJ,KA0aQ,IACA,QAAQ,GAAG,CAAC,uCACZ,AAvaR,eAqBQ,EACA,EACA,EACA,EAvBJ,QAAQ,GAAG,CAAC,iCACZ,IAAM,EAAS,SAAS,cAAc,CAAC,mBACvC,GAAI,CAAC,EAAQ,OACT,QAAQ,KAAK,CAAC,8BAGlB,QAAQ,GAAG,CAAC,gDAEZ,IAAM,EAAM,EAAO,UAAU,CAAC,MAC9B,GAAI,CAAC,EAAK,OACN,QAAQ,KAAK,CAAC,iDAIlB,IAAM,EAAQ,CAAE,EAAG,EAAG,EAAG,CAAE,EAC3B,OAAO,gBAAgB,CAAC,YAAa,AAAA,IACjC,EAAM,CAAC,CAAG,EAAE,OAAO,CACnB,EAAM,CAAC,CAAG,EAAE,OAAO,AACvB,GAMA,IAAI,EAAO,EAGL,EAAe,CACjB,oBACA,qBACA,iBACA,IACA,kBACA,oBACA,sBACA,MACA,IACA,gBACA,uBACA,yBACA,MACA,KACA,mBACA,mBACA,IACA,gCACA,gBACA,IACA,QACA,uBACA,oBACA,wBACA,IACA,4BACA,6BACA,KACA,sBACA,6BACA,oBACA,oBACA,UACH,CAEK,EAAY,CACd,WAAY,SAAU,YAAa,YACnC,eAAgB,YAAa,WAAY,SACzC,iBAAkB,WAAY,WAAY,YAC1C,WAAY,eAAgB,aAAc,cAC7C,CAEK,EAAe,KACjB,EAAO,KAAK,CAAG,OAAO,UAAU,CAChC,EAAO,MAAM,CAAG,OAAO,WAAW,CAGlC,EAAY,EAAE,CAEd,IAAK,IAAI,EAAI,EAAG,EADE,GACa,IAC3B,EAAU,IAAI,CAAC,CACX,EAAG,KAAK,MAAM,GAAK,EAAO,KAAK,CAC/B,EAAG,KAAK,MAAM,GAAK,EAAO,MAAM,CAChC,KAAM,CAAY,CAAC,KAAK,KAAK,CAAC,KAAK,MAAM,GAAK,EAAa,MAAM,EAAE,CACnE,QAAS,AAAgB,GAAhB,KAAK,MAAM,GAAW,GAC/B,MAAO,AAAgB,GAAhB,KAAK,MAAM,GAAW,GAC7B,eAAgB,EAChB,kBAAmB,CAAY,CAAC,KAAK,KAAK,CAAC,KAAK,MAAM,GAAK,EAAa,MAAM,EAAE,CAAC,MAAM,CACvF,MAAO,KAAK,MAAM,GAAK,GAAM,UAAY,UACzC,SAAU,AAAgB,EAAhB,KAAK,MAAM,GAAS,GAC9B,cAAe,AAAgB,GAAhB,KAAK,MAAM,GAAW,GACrC,WAAY,KAAK,MAAM,GAAK,GAAM,WAAa,UACnD,GAIJ,EAAU,EAAE,CAEZ,IAAK,IAAI,EAAI,EAAG,EADI,GACa,IAC7B,EAAQ,IAAI,CAAC,CACT,EAAG,KAAK,MAAM,GAAK,EAAO,KAAK,CAC/B,EAAG,KAAK,MAAM,GAAK,EAAO,MAAM,CAChC,QAAS,CAAC,OAAO,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,MAAM,CAAC,EAAG,GAAA,CAAI,CAC5D,KAAM,EACN,QAAS,AAAgB,IAAhB,KAAK,MAAM,GAAW,IAC/B,KAAM,AAAgB,IAAhB,KAAK,MAAM,GAAW,IAC5B,GAAK,AAAA,CAAA,KAAK,MAAM,GAAK,EAAA,EAAO,IAC5B,GAAK,AAAA,CAAA,KAAK,MAAM,GAAK,EAAA,EAAO,IAC5B,MAAO,KAAK,MAAM,GAAK,GAAM,UAAY,UACzC,cAAe,AAAgB,GAAhB,KAAK,MAAM,GAAW,EACzC,GAIJ,EAAe,EAAE,CAEjB,IAAK,IAAI,EAAI,EAAG,EADE,EACa,IAC3B,EAAa,IAAI,CAAC,CACd,EAAG,KAAK,MAAM,GAAK,EAAO,KAAK,CAC/B,EAAG,KAAK,MAAM,GAAK,EAAO,MAAM,CAChC,KAAM,CAAC,KAAK,EAAE,EAAI,EAAA,CAAG,CACrB,KAAM,AAAgB,GAAhB,KAAK,MAAM,GAAU,GAC3B,MAAO,KAAK,MAAM,GAAK,KAAK,EAAE,CAC9B,YAAa,EAAE,CACf,MAAO,KAAK,KAAK,CAAC,AAAgB,GAAhB,KAAK,MAAM,IAAW,EACxC,MAAO,KAAK,MAAM,GAAK,GAAM,UAAY,UACzC,cAAe,AAAgB,GAAhB,KAAK,MAAM,GAAW,GACrC,SAAU,KAAK,MAAM,GAAK,EAC9B,GAIJ,EAAa,OAAO,CAAC,CAAC,EAAM,KACxB,EAAa,OAAO,CAAC,CAAC,EAAW,KACzB,IAAM,GAAK,KAAK,MAAM,GAAK,IAC3B,EAAK,WAAW,CAAC,IAAI,CAAC,EAE9B,EACJ,GAGA,EAAQ,EAAE,CAEV,IAAK,IAAI,EAAI,EAAG,EADE,GACa,IAC3B,EAAM,IAAI,CAAC,CACP,EAAG,KAAK,MAAM,GAAK,EAAO,KAAK,CAC/B,EAAG,KAAK,MAAM,GAAK,EAAO,MAAM,CAChC,KAAM,CAAS,CAAC,KAAK,KAAK,CAAC,KAAK,MAAM,GAAK,EAAU,MAAM,EAAE,CAC7D,KAAM,AAAgB,EAAhB,KAAK,MAAM,GAAS,IAC1B,QAAS,AAAgB,GAAhB,KAAK,MAAM,GAAW,GAC/B,GAAK,AAAA,CAAA,KAAK,MAAM,GAAK,EAAA,EAAO,IAC5B,GAAK,AAAA,CAAA,KAAK,MAAM,GAAK,EAAA,EAAO,IAC5B,SAAU,KAAK,MAAM,GAAK,IAC1B,WAAY,KAAK,KAAK,CAAC,KAAK,MAAM,GAAK,EAAa,MAAM,EAC1D,MAAO,KAAK,MAAM,GAAK,GAAM,UAAY,UACzC,cAAe,AAAgB,GAAhB,KAAK,MAAM,GAAW,EACzC,EAER,EAiOM,EAAU,KA9NZ,GAAK,GAoML,GAnMA,EAAI,SAAS,CAAC,EAAG,EAAG,EAAO,KAAK,CAAE,EAAO,MAAM,EAC/C,GAAQ,KAGR,EAAa,OAAO,CAAC,CAAC,EAAM,KACxB,EAAK,KAAK,EAAI,KACd,IAAM,EAAe,AAAA,CAAA,KAAK,GAAG,CAAC,EAAK,KAAK,EAAI,CAAA,EAAK,EAG3C,EAAa,EAAK,IAAI,CAAG,AAAc,GAAd,EACzB,EAAW,EAAI,oBAAoB,CAAC,EAAK,CAAC,CAAE,EAAK,CAAC,CAAE,EAAG,EAAK,CAAC,CAAE,EAAK,CAAC,CAAE,GACvE,EAAU,AAAC,CAAA,GAAM,AAAI,IAAJ,CAAI,EAAQ,EAAK,aAAa,CAC/C,EAAc,AAAkD,IAAlD,KAAK,KAAK,CAAC,AAAU,IAAV,GAAe,QAAQ,CAAC,IAAI,MAAM,CAAS,IAAM,KAAK,KAAK,CAAC,AAAU,IAAV,GAAe,QAAQ,CAAC,IAAM,KAAK,KAAK,CAAC,AAAU,IAAV,GAAe,QAAQ,CAAC,IACtJ,EAAc,AAAwD,IAAxD,KAAK,KAAK,CAAC,AAAA,KAAA,GAAqB,QAAQ,CAAC,IAAI,MAAM,CAAS,IAAM,KAAK,KAAK,CAAC,AAAA,KAAA,GAAqB,QAAQ,CAAC,IAAM,KAAK,KAAK,CAAC,AAAA,KAAA,GAAqB,QAAQ,CAAC,IAC9K,EAAS,YAAY,CAAC,EAAG,CAAA,EAAG,EAAK,KAAK,CAAA,EAAG,EAAA,CAAa,EACtD,EAAS,YAAY,CAAC,GAAK,CAAA,EAAG,EAAK,KAAK,CAAA,EAAG,EAAA,CAAa,EACxD,EAAS,YAAY,CAAC,EAAG,eAEzB,EAAI,SAAS,GACb,EAAI,GAAG,CAAC,EAAK,CAAC,CAAE,EAAK,CAAC,CAAE,EAAY,EAAG,AAAU,EAAV,KAAK,EAAE,EAC9C,EAAI,SAAS,CAAG,EAChB,EAAI,IAAI,GAGR,EAAI,SAAS,GACb,EAAI,GAAG,CAAC,EAAK,CAAC,CAAE,EAAK,CAAC,CAAE,EAAK,IAAI,CAAE,EAAG,AAAU,EAAV,KAAK,EAAE,EAC7C,IAAM,EAAc,KAAK,KAAK,CAAE,AAAA,CAAA,GAAM,AAAc,GAAd,CAAc,EAAO,KACrD,EAAiB,AAAoC,IAApC,EAAY,QAAQ,CAAC,IAAI,MAAM,CAAS,IAAM,EAAY,QAAQ,CAAC,IAAM,EAAY,QAAQ,CAAC,GACrH,CAAA,EAAI,SAAS,CAAG,CAAA,EAAG,EAAK,KAAK,CAAA,EAAG,EAAA,CAAgB,CAChD,EAAI,IAAI,GAGR,EAAI,SAAS,GACb,EAAI,GAAG,CAAC,EAAK,CAAC,CAAG,AAAY,IAAZ,EAAK,IAAI,CAAS,EAAK,CAAC,CAAG,AAAY,IAAZ,EAAK,IAAI,CAAS,AAAY,GAAZ,EAAK,IAAI,CAAQ,EAAG,AAAU,EAAV,KAAK,EAAE,EACzF,EAAI,SAAS,CAAG,CAAC,oBAAoB,EAAE,GAAM,AAAc,GAAd,EAAkB,CAAC,CAAC,CACjE,EAAI,IAAI,GAGR,EAAI,IAAI,CAAG,iBACX,EAAI,SAAS,CAAG,CAAC,oBAAoB,EAAE,GAAM,AAAc,GAAd,EAAkB,CAAC,CAAC,CACjE,EAAI,SAAS,CAAG,SAChB,EAAI,QAAQ,CAAC,EAAK,IAAI,CAAE,EAAK,CAAC,CAAE,EAAK,CAAC,CAAG,GAGzC,EAAI,IAAI,CAAG,iBACX,EAAI,SAAS,CAAG,CAAC,oBAAoB,EAAE,GAAM,AAAc,GAAd,EAAkB,CAAC,CAAC,CACjE,EAAI,QAAQ,CAAC,CAAA,EAAG,EAAK,KAAK,CAAC,MAAM,CAAC,CAAE,EAAK,CAAC,CAAE,EAAK,CAAC,CAAG,IAGjD,EAAK,QAAQ,GACb,EAAI,SAAS,GACb,EAAI,GAAG,CAAC,EAAK,CAAC,CAAG,EAAK,IAAI,CAAG,EAAG,EAAK,CAAC,CAAG,EAAK,IAAI,CAAG,EAAG,EAAG,EAAG,AAAU,EAAV,KAAK,EAAE,EACrE,EAAI,SAAS,CAAG,CAAC,gBAAgB,EAAE,AAAc,GAAd,EAAkB,CAAC,CAAC,CACvD,EAAI,IAAI,GAEhB,GAGA,EAAa,OAAO,CAAC,CAAC,EAAM,KACxB,EAAK,WAAW,CAAC,OAAO,CAAC,AAAC,IACtB,IAAM,EAAgB,CAAY,CAAC,EAAgB,CAC7C,EAAO,KAAK,IAAI,CAAC,KAAK,GAAG,CAAC,EAAK,CAAC,CAAG,EAAc,CAAC,CAAE,GAAK,KAAK,GAAG,CAAC,EAAK,CAAC,CAAG,EAAc,CAAC,CAAE,IAElG,GAAI,EAAO,IAAK,CAEZ,IAAM,EAAa,AAA2C,GAA3C,KAAK,GAAG,CAAC,AAAO,EAAP,EAAW,EAAI,GAAyB,GAEpE,EAAI,SAAS,GACb,EAAI,MAAM,CAAC,EAAK,CAAC,CAAE,EAAK,CAAC,EACzB,EAAI,MAAM,CAAC,EAAc,CAAC,CAAE,EAAc,CAAC,EAC3C,EAAI,WAAW,CAAG,CAAC,oBAAoB,EAAE,AANxB,CAAA,EAAI,EAAO,GAAA,EAAO,GAMgB,EAAW,CAAC,CAAC,CAChE,EAAI,SAAS,CAAG,EAAI,AAAa,EAAb,EACpB,EAAI,MAAM,EACd,CACJ,EACJ,GAGA,EAAM,OAAO,CAAC,AAAA,IACV,EAAK,CAAC,EAAI,EAAK,EAAE,CACjB,EAAK,CAAC,EAAI,EAAK,EAAE,CAEb,CAAA,EAAK,CAAC,CAAG,GAAK,EAAK,CAAC,CAAG,EAAO,KAAK,AAAL,GAAO,CAAA,EAAK,EAAE,EAAI,EAApD,EACI,CAAA,EAAK,CAAC,CAAG,GAAK,EAAK,CAAC,CAAG,EAAO,MAAM,AAAN,GAAQ,CAAA,EAAK,EAAE,EAAI,EAArD,EAGA,IAAM,EAAiB,EAAK,IAAI,CAAG,EAC7B,EAAe,EAAI,oBAAoB,CAAC,EAAK,CAAC,CAAE,EAAK,CAAC,CAAE,EAAG,EAAK,CAAC,CAAE,EAAK,CAAC,CAAE,GAC3E,EAAc,EAAK,QAAQ,CAAG,GAAM,EAAK,OAAO,CAChD,EAAiB,AAAsD,IAAtD,KAAK,KAAK,CAAC,AAAc,IAAd,GAAmB,QAAQ,CAAC,IAAI,MAAM,CAAS,IAAM,KAAK,KAAK,CAAC,AAAc,IAAd,GAAmB,QAAQ,CAAC,IAAM,KAAK,KAAK,CAAC,AAAc,IAAd,GAAmB,QAAQ,CAAC,IAC3K,EAAa,YAAY,CAAC,EAAG,CAAA,EAAG,EAAK,KAAK,CAAA,EAAG,EAAA,CAAgB,EAC7D,EAAa,YAAY,CAAC,EAAG,eAE7B,EAAI,SAAS,GACb,EAAI,GAAG,CAAC,EAAK,CAAC,CAAE,EAAK,CAAC,CAAE,EAAgB,EAAG,AAAU,EAAV,KAAK,EAAE,EAClD,EAAI,SAAS,CAAG,EAChB,EAAI,IAAI,GAGR,EAAI,SAAS,GACb,EAAI,IAAI,CAAC,EAAK,CAAC,CAAG,EAAK,IAAI,CAAE,EAAK,CAAC,CAAG,EAAK,IAAI,CAAE,AAAY,EAAZ,EAAK,IAAI,CAAM,AAAY,EAAZ,EAAK,IAAI,EACzE,EAAI,SAAS,CAAG,EAAK,QAAQ,CACzB,CAAC,kBAAkB,EAAE,EAAK,OAAO,CAAC,CAAC,CAAC,CACpC,CAAC,oBAAoB,EAAE,EAAK,OAAO,CAAC,CAAC,CAAC,CAC1C,EAAI,IAAI,GAGR,EAAI,IAAI,CAAG,gBACX,EAAI,SAAS,CAAG,CAAC,oBAAoB,EAAE,EAAK,OAAO,CAAC,CAAC,CAAC,CACtD,EAAI,SAAS,CAAG,SAChB,EAAI,QAAQ,CAAC,EAAK,IAAI,CAAE,EAAK,CAAC,CAAE,EAAK,CAAC,CAAG,EAAK,IAAI,CAAG,IAGjD,EAAK,QAAQ,GACb,EAAI,SAAS,GACb,EAAI,GAAG,CAAC,EAAK,CAAC,CAAG,EAAK,IAAI,CAAE,EAAK,CAAC,CAAG,EAAK,IAAI,CAAE,EAAG,EAAG,AAAU,EAAV,KAAK,EAAE,EAC7D,EAAI,SAAS,CAAG,uBAChB,EAAI,IAAI,GAEhB,GAGA,EAAU,OAAO,CAAC,AAAA,IACd,EAAK,cAAc,EAAI,EAAK,KAAK,CAC7B,EAAK,cAAc,CAAG,EAAK,iBAAiB,GAC5C,EAAK,cAAc,CAAG,EACtB,EAAK,IAAI,CAAG,CAAY,CAAC,KAAK,KAAK,CAAC,KAAK,MAAM,GAAK,EAAa,MAAM,EAAE,CACzE,EAAK,iBAAiB,CAAG,EAAK,IAAI,CAAC,MAAM,CACzC,EAAK,UAAU,CAAG,KAAK,MAAM,GAAK,GAAM,WAAa,YAGzD,IAAM,EAAc,EAAK,IAAI,CAAC,SAAS,CAAC,EAAG,KAAK,KAAK,CAAC,EAAK,cAAc,GACnE,EAAS,EAAK,cAAc,CAAG,EAAK,iBAAiB,CAAG,IAAM,EAEpE,CAAA,EAAI,IAAI,CAAG,CAAA,EAAG,EAAK,QAAQ,CAAC,2BAA2B,CAAC,CACxD,IAAM,EAAiB,AAAuD,IAAvD,KAAK,KAAK,CAAC,AAAe,IAAf,EAAK,OAAO,EAAQ,QAAQ,CAAC,IAAI,MAAM,CAAS,IAAM,KAAK,KAAK,CAAC,AAAe,IAAf,EAAK,OAAO,EAAQ,QAAQ,CAAC,IAAM,KAAK,KAAK,CAAC,AAAe,IAAf,EAAK,OAAO,EAAQ,QAAQ,CAAC,GAG1K,AAAoB,CAAA,aAApB,EAAK,UAAU,EAAoB,CAAA,EAAY,QAAQ,CAAC,aAAe,EAAY,QAAQ,CAAC,UAAY,EAAY,QAAQ,CAAC,UAAY,EAAY,QAAQ,CAAC,SAAA,EAC9J,EAAI,SAAS,CAAG,CAAC,kBAAkB,EAAE,EAAK,OAAO,CAAC,CAAC,CAAC,CAEpD,EAAI,SAAS,CAAG,CAAA,EAAG,EAAK,KAAK,CAAA,EAAG,EAAA,CAAgB,CAGpD,EAAI,SAAS,CAAG,OAChB,EAAI,QAAQ,CAAC,EAAc,EAAQ,EAAK,CAAC,CAAE,EAAK,CAAC,EAG7C,EAAK,cAAc,CAAG,EAAK,iBAAiB,GAC5C,EAAI,SAAS,CAAG,CAAC,oBAAoB,EAAE,AAAe,GAAf,EAAK,OAAO,CAAO,CAAC,CAAC,CAC5D,EAAI,QAAQ,CAAC,EAAc,EAAQ,EAAK,CAAC,CAAE,EAAK,CAAC,EAEzD,GAGA,EAAQ,OAAO,CAAC,CAAC,EAAQ,KACrB,EAAO,IAAI,EAAI,KACf,EAAO,CAAC,EAAI,EAAO,EAAE,CACrB,EAAO,CAAC,EAAI,EAAO,EAAE,CAEjB,EAAO,IAAI,CAAG,EAAO,OAAO,GAC5B,EAAO,IAAI,CAAG,EACd,EAAO,CAAC,CAAG,KAAK,MAAM,GAAK,EAAO,KAAK,CACvC,EAAO,CAAC,CAAG,KAAK,MAAM,GAAK,EAAO,MAAM,CACxC,EAAO,OAAO,CAAG,CAAC,OAAO,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,MAAM,CAAC,EAAG,GAAA,CAAI,EAGxE,IAAM,EAAS,AAAA,CAAA,EAAI,EAAO,IAAI,CAAG,EAAO,OAAO,AAAP,EAAW,GAG7C,EAAmB,EAAO,IAAI,CAAG,EACjC,EAAiB,EAAI,oBAAoB,CAAC,EAAO,CAAC,CAAE,EAAO,CAAC,CAAE,EAAG,EAAO,CAAC,CAAE,EAAO,CAAC,CAAE,GACrF,EAAmB,AAAgD,IAAhD,KAAK,KAAK,CAAC,AAAQ,IAAR,GAAa,QAAQ,CAAC,IAAI,MAAM,CAAS,IAAM,KAAK,KAAK,CAAC,AAAQ,IAAR,GAAa,QAAQ,CAAC,IAAM,KAAK,KAAK,CAAC,AAAQ,IAAR,GAAa,QAAQ,CAAC,IAC3J,EAAe,YAAY,CAAC,EAAG,CAAA,EAAG,EAAO,KAAK,CAAA,EAAG,EAAA,CAAkB,EACnE,EAAe,YAAY,CAAC,EAAG,eAE/B,EAAI,SAAS,GACb,EAAI,GAAG,CAAC,EAAO,CAAC,CAAE,EAAO,CAAC,CAAE,EAAkB,EAAG,AAAU,EAAV,KAAK,EAAE,EACxD,EAAI,SAAS,CAAG,EAChB,EAAI,IAAI,GAGR,EAAI,SAAS,GACb,EAAI,GAAG,CAAC,EAAO,CAAC,CAAE,EAAO,CAAC,CAAE,EAAO,IAAI,CAAE,EAAG,AAAU,EAAV,KAAK,EAAE,EACnD,EAAI,SAAS,CAAG,CAAC,gBAAgB,EAAE,EAAM,CAAC,CAAC,CAC3C,EAAI,IAAI,GAGR,EAAI,IAAI,CAAG,iBACX,EAAI,SAAS,CAAG,CAAC,gBAAgB,EAAE,EAAM,CAAC,CAAC,CAC3C,EAAI,SAAS,CAAG,SAChB,EAAI,QAAQ,CAAC,EAAO,OAAO,CAAE,EAAO,CAAC,CAAE,EAAO,CAAC,CAAG,EAAO,IAAI,CAAG,GACpE,GAGI,AAAgB,KAAhB,KAAK,MAAM,GAAY,CACvB,IAAM,EAAY,CACd,EAAG,KAAK,MAAM,GAAK,EAAO,KAAK,CAC/B,EAAG,EAAO,MAAM,CAChB,QAAS,CAAC,OAAO,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,MAAM,CAAC,EAAG,GAAA,CAAI,CAC5D,KAAM,EACN,QAAS,IACT,KAAM,IACN,GAAK,AAAA,CAAA,KAAK,MAAM,GAAK,EAAA,EAAO,IAC5B,GAAI,KACJ,MAAO,KAAK,MAAM,GAAK,GAAM,UAAY,UACzC,cAAe,AAAgB,GAAhB,KAAK,MAAM,GAAW,EACzC,EACA,EAAQ,IAAI,CAAC,EACjB,CAGA,GAAI,AAAgB,KAAhB,KAAK,MAAM,GAAY,CACvB,IAAM,EAAa,CAAK,CAAC,KAAK,KAAK,CAAC,KAAK,MAAM,GAAK,EAAM,MAAM,EAAE,AAClE,CAAA,EAAW,QAAQ,CAAG,CAAA,EACtB,WAAW,KACP,EAAW,QAAQ,CAAG,CAAA,CAC1B,EAAG,IACP,EAKA,sBAAsB,EAC1B,EAEA,OAAO,gBAAgB,CAAC,SAAU,GAClC,IACA,GACJ,KA5pCI,IAAM,EAAe,SAAS,gBAAgB,CAAc,kBACtD,EAAU,SAAS,cAAc,CAAC,UAEpC,CAAA,GAAW,EAAa,MAAM,CAAG,GACjC,EAAa,OAAO,CAAC,AAAA,IAEjB,IAAM,EAAc,AADF,EACY,OAAO,CAAC,OAAO,EAAI,GAE3C,EAAc,KAChB,EAAQ,WAAW,CAAG,EACtB,EAAQ,SAAS,CAAC,GAAG,CAAC,WAEtB,AAAA,GAPc,EAOa,EAAS,CAChC,UAAW,MACX,WAAY,CAAC,AAAA,GAAO,GAAI,AAAA,KAAQ,AAAA,GAAM,CAAE,QAAS,CAAE,GAAG,AAC1D,GAAG,IAAI,CAAC,CAAC,CAAA,EAAE,CAAC,CAAA,EAAE,CAAC,CAAE,IACb,OAAO,MAAM,CAAC,EAAQ,KAAK,CAAE,CACzB,KAAM,CAAA,EAAG,EAAE,EAAE,CAAC,CACd,IAAK,CAAA,EAAG,EAAE,EAAE,CAAC,AACjB,EACJ,EACJ,EAEM,EAAc,KAChB,EAAQ,SAAS,CAAC,MAAM,CAAC,UAC7B,EAEA,AAtBkB,EAsBR,gBAAgB,CAAC,aAAc,GACzC,AAvBkB,EAuBR,gBAAgB,CAAC,aAAc,GACzC,AAxBkB,EAwBR,gBAAgB,CAAC,QAAS,GACpC,AAzBkB,EAyBR,gBAAgB,CAAC,OAAQ,EACvC,GA5FJ,IAAM,EAAY,SAAS,aAAa,CAAiB,cACnD,EAAU,SAAS,aAAa,CAAiB,aACjD,EAAW,SAAS,gBAAgB,CAAoB,aAE9D,GAAW,iBAAiB,QAAS,KACjC,EAAU,SAAS,CAAC,MAAM,CAAC,UAC3B,GAAS,UAAU,OAAO,SAC9B,GAGA,EAAS,OAAO,CAAC,AAAA,IACb,EAAK,gBAAgB,CAAC,QAAS,KAC3B,GAAW,UAAU,OAAO,UAC5B,GAAS,UAAU,OAAO,SAC9B,EACJ,GA4BA,IAAM,EAAe,SAAS,cAAc,CAAC,kBACxC,IAEL,OAAO,gBAAgB,CAAC,SAAU,KAC1B,OAAO,OAAO,CAAG,IACjB,EAAa,SAAS,CAAC,GAAG,CAAC,WAE3B,EAAa,SAAS,CAAC,MAAM,CAAC,UAEtC,GAEA,EAAa,gBAAgB,CAAC,QAAS,AAAC,IACpC,EAAE,cAAc,GAChB,OAAO,QAAQ,CAAC,CAAE,IAAK,EAAG,SAAU,QAAS,EACjD,IAusCA,KA7uCA,IAAM,EAAc,OAAO,QAAQ,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,GAAG,IAAM,aAGjE,AAFiB,SAAS,gBAAgB,CAAoB,eAErD,OAAO,CAAC,AAAA,IAET,AADa,EAAK,YAAY,CAAC,UAClB,GACb,EAAK,SAAS,CAAC,GAAG,CAAC,SAE3B,GAIA,IAAM,EAAS,SAAS,aAAa,CAAc,WAEnD,OAAO,gBAAgB,CAAC,SAAU,KAC1B,OAAO,OAAO,CAAG,IACjB,GAAQ,UAAU,IAAI,YAEtB,GAAQ,UAAU,OAAO,WAEjC,GAguCI,OAAO,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,eAClC,KAEA,OAAO,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,iBAItC,QAAQ,GAAG,CAAC,2BAChB,GAGA,MAAM,GAAQ,SAAS,aAAa,CAAC,QACrC,CAAA,GAAM,WAAW,CAAG;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;AA4DpB,CAAC,CAED,SAAS,IAAI,CAAC,WAAW,CAAC","sources":["<anon>","script.ts","node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.js","node_modules/@floating-ui/core/dist/floating-ui.core.esm.js","node_modules/@floating-ui/utils/dist/floating-ui.utils.esm.js","node_modules/@floating-ui/utils/dom/floating-ui.utils.dom.esm.js"],"sourcesContent":["/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */ const $10310cf078d13212$export$832b6fa47fa053d2 = [\n    'top',\n    'right',\n    'bottom',\n    'left'\n];\nconst $10310cf078d13212$export$27b07d8a310ed8b5 = [\n    'start',\n    'end'\n];\nconst $10310cf078d13212$export$803cd8101b6c182b = /*#__PURE__*/ $10310cf078d13212$export$832b6fa47fa053d2.reduce((acc, side)=>acc.concat(side, side + \"-\" + $10310cf078d13212$export$27b07d8a310ed8b5[0], side + \"-\" + $10310cf078d13212$export$27b07d8a310ed8b5[1]), []);\nconst $10310cf078d13212$export$96ec731ed4dcb222 = Math.min;\nconst $10310cf078d13212$export$8960430cfd85939f = Math.max;\nconst $10310cf078d13212$export$2077e0241d6afd3c = Math.round;\nconst $10310cf078d13212$export$a3fe094919f356fd = Math.floor;\nconst $10310cf078d13212$export$a397704b5e280835 = (v)=>({\n        x: v,\n        y: v\n    });\nconst $10310cf078d13212$var$oppositeSideMap = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n};\nconst $10310cf078d13212$var$oppositeAlignmentMap = {\n    start: 'end',\n    end: 'start'\n};\nfunction $10310cf078d13212$export$7d15b64cf5a3a4c4(start, value, end) {\n    return $10310cf078d13212$export$8960430cfd85939f(start, $10310cf078d13212$export$96ec731ed4dcb222(value, end));\n}\nfunction $10310cf078d13212$export$fef61f332f2c0afc(value, param) {\n    return typeof value === 'function' ? value(param) : value;\n}\nfunction $10310cf078d13212$export$3c915306cb7fc97a(placement) {\n    return placement.split('-')[0];\n}\nfunction $10310cf078d13212$export$f0989780f32bfcda(placement) {\n    return placement.split('-')[1];\n}\nfunction $10310cf078d13212$export$8a000a963141ac32(axis) {\n    return axis === 'x' ? 'y' : 'x';\n}\nfunction $10310cf078d13212$export$320bd9d53520c68a(axis) {\n    return axis === 'y' ? 'height' : 'width';\n}\nconst $10310cf078d13212$var$yAxisSides = /*#__PURE__*/ new Set([\n    'top',\n    'bottom'\n]);\nfunction $10310cf078d13212$export$f28e8f882010718a(placement) {\n    return $10310cf078d13212$var$yAxisSides.has($10310cf078d13212$export$3c915306cb7fc97a(placement)) ? 'y' : 'x';\n}\nfunction $10310cf078d13212$export$2b57e0052a6d6d4c(placement) {\n    return $10310cf078d13212$export$8a000a963141ac32($10310cf078d13212$export$f28e8f882010718a(placement));\n}\nfunction $10310cf078d13212$export$be42861551f17911(placement, rects, rtl) {\n    if (rtl === void 0) rtl = false;\n    const alignment = $10310cf078d13212$export$f0989780f32bfcda(placement);\n    const alignmentAxis = $10310cf078d13212$export$2b57e0052a6d6d4c(placement);\n    const length = $10310cf078d13212$export$320bd9d53520c68a(alignmentAxis);\n    let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n    if (rects.reference[length] > rects.floating[length]) mainAlignmentSide = $10310cf078d13212$export$9c5e28bad23365fa(mainAlignmentSide);\n    return [\n        mainAlignmentSide,\n        $10310cf078d13212$export$9c5e28bad23365fa(mainAlignmentSide)\n    ];\n}\nfunction $10310cf078d13212$export$496432a3699e50b1(placement) {\n    const oppositePlacement = $10310cf078d13212$export$9c5e28bad23365fa(placement);\n    return [\n        $10310cf078d13212$export$2b182c584985588b(placement),\n        oppositePlacement,\n        $10310cf078d13212$export$2b182c584985588b(oppositePlacement)\n    ];\n}\nfunction $10310cf078d13212$export$2b182c584985588b(placement) {\n    return placement.replace(/start|end/g, (alignment)=>$10310cf078d13212$var$oppositeAlignmentMap[alignment]);\n}\nconst $10310cf078d13212$var$lrPlacement = [\n    'left',\n    'right'\n];\nconst $10310cf078d13212$var$rlPlacement = [\n    'right',\n    'left'\n];\nconst $10310cf078d13212$var$tbPlacement = [\n    'top',\n    'bottom'\n];\nconst $10310cf078d13212$var$btPlacement = [\n    'bottom',\n    'top'\n];\nfunction $10310cf078d13212$var$getSideList(side, isStart, rtl) {\n    switch(side){\n        case 'top':\n        case 'bottom':\n            if (rtl) return isStart ? $10310cf078d13212$var$rlPlacement : $10310cf078d13212$var$lrPlacement;\n            return isStart ? $10310cf078d13212$var$lrPlacement : $10310cf078d13212$var$rlPlacement;\n        case 'left':\n        case 'right':\n            return isStart ? $10310cf078d13212$var$tbPlacement : $10310cf078d13212$var$btPlacement;\n        default:\n            return [];\n    }\n}\nfunction $10310cf078d13212$export$a9b6fb18fd92c3ec(placement, flipAlignment, direction, rtl) {\n    const alignment = $10310cf078d13212$export$f0989780f32bfcda(placement);\n    let list = $10310cf078d13212$var$getSideList($10310cf078d13212$export$3c915306cb7fc97a(placement), direction === 'start', rtl);\n    if (alignment) {\n        list = list.map((side)=>side + \"-\" + alignment);\n        if (flipAlignment) list = list.concat(list.map($10310cf078d13212$export$2b182c584985588b));\n    }\n    return list;\n}\nfunction $10310cf078d13212$export$9c5e28bad23365fa(placement) {\n    return placement.replace(/left|right|bottom|top/g, (side)=>$10310cf078d13212$var$oppositeSideMap[side]);\n}\nfunction $10310cf078d13212$export$1c66dbf1a9e34223(padding) {\n    return {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0,\n        ...padding\n    };\n}\nfunction $10310cf078d13212$export$598c291c29bc2e71(padding) {\n    return typeof padding !== 'number' ? $10310cf078d13212$export$1c66dbf1a9e34223(padding) : {\n        top: padding,\n        right: padding,\n        bottom: padding,\n        left: padding\n    };\n}\nfunction $10310cf078d13212$export$ee05aea0aeecbad4(rect) {\n    const { x: x, y: y, width: width, height: height } = rect;\n    return {\n        width: width,\n        height: height,\n        top: y,\n        left: x,\n        right: x + width,\n        bottom: y + height,\n        x: x,\n        y: y\n    };\n}\n\n\nfunction $973e4da43f2a375d$var$computeCoordsFromPlacement(_ref, placement, rtl) {\n    let { reference: reference, floating: floating } = _ref;\n    const sideAxis = (0, $10310cf078d13212$export$f28e8f882010718a)(placement);\n    const alignmentAxis = (0, $10310cf078d13212$export$2b57e0052a6d6d4c)(placement);\n    const alignLength = (0, $10310cf078d13212$export$320bd9d53520c68a)(alignmentAxis);\n    const side = (0, $10310cf078d13212$export$3c915306cb7fc97a)(placement);\n    const isVertical = sideAxis === 'y';\n    const commonX = reference.x + reference.width / 2 - floating.width / 2;\n    const commonY = reference.y + reference.height / 2 - floating.height / 2;\n    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n    let coords;\n    switch(side){\n        case 'top':\n            coords = {\n                x: commonX,\n                y: reference.y - floating.height\n            };\n            break;\n        case 'bottom':\n            coords = {\n                x: commonX,\n                y: reference.y + reference.height\n            };\n            break;\n        case 'right':\n            coords = {\n                x: reference.x + reference.width,\n                y: commonY\n            };\n            break;\n        case 'left':\n            coords = {\n                x: reference.x - floating.width,\n                y: commonY\n            };\n            break;\n        default:\n            coords = {\n                x: reference.x,\n                y: reference.y\n            };\n    }\n    switch((0, $10310cf078d13212$export$f0989780f32bfcda)(placement)){\n        case 'start':\n            coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n            break;\n        case 'end':\n            coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n            break;\n    }\n    return coords;\n}\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */ const $973e4da43f2a375d$export$48a53dcb22e581d0 = async (reference, floating, config)=>{\n    const { placement: placement = 'bottom', strategy: strategy = 'absolute', middleware: middleware = [], platform: platform } = config;\n    const validMiddleware = middleware.filter(Boolean);\n    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n    let rects = await platform.getElementRects({\n        reference: reference,\n        floating: floating,\n        strategy: strategy\n    });\n    let { x: x, y: y } = $973e4da43f2a375d$var$computeCoordsFromPlacement(rects, placement, rtl);\n    let statefulPlacement = placement;\n    let middlewareData = {};\n    let resetCount = 0;\n    for(let i = 0; i < validMiddleware.length; i++){\n        const { name: name, fn: fn } = validMiddleware[i];\n        const { x: nextX, y: nextY, data: data, reset: reset } = await fn({\n            x: x,\n            y: y,\n            initialPlacement: placement,\n            placement: statefulPlacement,\n            strategy: strategy,\n            middlewareData: middlewareData,\n            rects: rects,\n            platform: platform,\n            elements: {\n                reference: reference,\n                floating: floating\n            }\n        });\n        x = nextX != null ? nextX : x;\n        y = nextY != null ? nextY : y;\n        middlewareData = {\n            ...middlewareData,\n            [name]: {\n                ...middlewareData[name],\n                ...data\n            }\n        };\n        if (reset && resetCount <= 50) {\n            resetCount++;\n            if (typeof reset === 'object') {\n                if (reset.placement) statefulPlacement = reset.placement;\n                if (reset.rects) rects = reset.rects === true ? await platform.getElementRects({\n                    reference: reference,\n                    floating: floating,\n                    strategy: strategy\n                }) : reset.rects;\n                ({ x: x, y: y } = $973e4da43f2a375d$var$computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n            }\n            i = -1;\n        }\n    }\n    return {\n        x: x,\n        y: y,\n        placement: statefulPlacement,\n        strategy: strategy,\n        middlewareData: middlewareData\n    };\n};\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */ async function $973e4da43f2a375d$export$37b6bde19b108ecc(state, options) {\n    var _await$platform$isEle;\n    if (options === void 0) options = {};\n    const { x: x, y: y, platform: platform, rects: rects, elements: elements, strategy: strategy } = state;\n    const { boundary: boundary = 'clippingAncestors', rootBoundary: rootBoundary = 'viewport', elementContext: elementContext = 'floating', altBoundary: altBoundary = false, padding: padding = 0 } = (0, $10310cf078d13212$export$fef61f332f2c0afc)(options, state);\n    const paddingObject = (0, $10310cf078d13212$export$598c291c29bc2e71)(padding);\n    const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n    const element = elements[altBoundary ? altContext : elementContext];\n    const clippingClientRect = (0, $10310cf078d13212$export$ee05aea0aeecbad4)(await platform.getClippingRect({\n        element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating)),\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        strategy: strategy\n    }));\n    const rect = elementContext === 'floating' ? {\n        x: x,\n        y: y,\n        width: rects.floating.width,\n        height: rects.floating.height\n    } : rects.reference;\n    const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n    const offsetScale = await (platform.isElement == null ? void 0 : platform.isElement(offsetParent)) ? await (platform.getScale == null ? void 0 : platform.getScale(offsetParent)) || {\n        x: 1,\n        y: 1\n    } : {\n        x: 1,\n        y: 1\n    };\n    const elementClientRect = (0, $10310cf078d13212$export$ee05aea0aeecbad4)(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n        elements: elements,\n        rect: rect,\n        offsetParent: offsetParent,\n        strategy: strategy\n    }) : rect);\n    return {\n        top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n        bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n        left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n        right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n    };\n}\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */ const $973e4da43f2a375d$export$f2120bbfa5450bd2 = (options)=>({\n        name: 'arrow',\n        options: options,\n        async fn (state) {\n            const { x: x, y: y, placement: placement, rects: rects, platform: platform, elements: elements, middlewareData: middlewareData } = state;\n            // Since `element` is required, we don't Partial<> the type.\n            const { element: element, padding: padding = 0 } = (0, $10310cf078d13212$export$fef61f332f2c0afc)(options, state) || {};\n            if (element == null) return {};\n            const paddingObject = (0, $10310cf078d13212$export$598c291c29bc2e71)(padding);\n            const coords = {\n                x: x,\n                y: y\n            };\n            const axis = (0, $10310cf078d13212$export$2b57e0052a6d6d4c)(placement);\n            const length = (0, $10310cf078d13212$export$320bd9d53520c68a)(axis);\n            const arrowDimensions = await platform.getDimensions(element);\n            const isYAxis = axis === 'y';\n            const minProp = isYAxis ? 'top' : 'left';\n            const maxProp = isYAxis ? 'bottom' : 'right';\n            const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n            const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n            const startDiff = coords[axis] - rects.reference[axis];\n            const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n            let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n            // DOM platform can return `window` as the `offsetParent`.\n            if (!clientSize || !await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent))) clientSize = elements.floating[clientProp] || rects.floating[length];\n            const centerToReference = endDiff / 2 - startDiff / 2;\n            // If the padding is large enough that it causes the arrow to no longer be\n            // centered, modify the padding so that it is centered.\n            const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n            const minPadding = (0, $10310cf078d13212$export$96ec731ed4dcb222)(paddingObject[minProp], largestPossiblePadding);\n            const maxPadding = (0, $10310cf078d13212$export$96ec731ed4dcb222)(paddingObject[maxProp], largestPossiblePadding);\n            // Make sure the arrow doesn't overflow the floating element if the center\n            // point is outside the floating element's bounds.\n            const min$1 = minPadding;\n            const max = clientSize - arrowDimensions[length] - maxPadding;\n            const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n            const offset = (0, $10310cf078d13212$export$7d15b64cf5a3a4c4)(min$1, center, max);\n            // If the reference is small enough that the arrow's padding causes it to\n            // to point to nothing for an aligned placement, adjust the offset of the\n            // floating element itself. To ensure `shift()` continues to take action,\n            // a single reset is performed when this is true.\n            const shouldAddOffset = !middlewareData.arrow && (0, $10310cf078d13212$export$f0989780f32bfcda)(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n            const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n            return {\n                [axis]: coords[axis] + alignmentOffset,\n                data: {\n                    [axis]: offset,\n                    centerOffset: center - offset - alignmentOffset,\n                    ...shouldAddOffset && {\n                        alignmentOffset: alignmentOffset\n                    }\n                },\n                reset: shouldAddOffset\n            };\n        }\n    });\nfunction $973e4da43f2a375d$var$getPlacementList(alignment, autoAlignment, allowedPlacements) {\n    const allowedPlacementsSortedByAlignment = alignment ? [\n        ...allowedPlacements.filter((placement)=>(0, $10310cf078d13212$export$f0989780f32bfcda)(placement) === alignment),\n        ...allowedPlacements.filter((placement)=>(0, $10310cf078d13212$export$f0989780f32bfcda)(placement) !== alignment)\n    ] : allowedPlacements.filter((placement)=>(0, $10310cf078d13212$export$3c915306cb7fc97a)(placement) === placement);\n    return allowedPlacementsSortedByAlignment.filter((placement)=>{\n        if (alignment) return (0, $10310cf078d13212$export$f0989780f32bfcda)(placement) === alignment || (autoAlignment ? (0, $10310cf078d13212$export$2b182c584985588b)(placement) !== placement : false);\n        return true;\n    });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */ const $973e4da43f2a375d$export$91fb6ecbd551914 = function(options) {\n    if (options === void 0) options = {};\n    return {\n        name: 'autoPlacement',\n        options: options,\n        async fn (state) {\n            var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n            const { rects: rects, middlewareData: middlewareData, placement: placement, platform: platform, elements: elements } = state;\n            const { crossAxis: crossAxis = false, alignment: alignment, allowedPlacements: allowedPlacements = (0, $10310cf078d13212$export$803cd8101b6c182b), autoAlignment: autoAlignment = true, ...detectOverflowOptions } = (0, $10310cf078d13212$export$fef61f332f2c0afc)(options, state);\n            const placements$1 = alignment !== undefined || allowedPlacements === (0, $10310cf078d13212$export$803cd8101b6c182b) ? $973e4da43f2a375d$var$getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n            const overflow = await $973e4da43f2a375d$export$37b6bde19b108ecc(state, detectOverflowOptions);\n            const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n            const currentPlacement = placements$1[currentIndex];\n            if (currentPlacement == null) return {};\n            const alignmentSides = (0, $10310cf078d13212$export$be42861551f17911)(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n            // Make `computeCoords` start from the right place.\n            if (placement !== currentPlacement) return {\n                reset: {\n                    placement: placements$1[0]\n                }\n            };\n            const currentOverflows = [\n                overflow[(0, $10310cf078d13212$export$3c915306cb7fc97a)(currentPlacement)],\n                overflow[alignmentSides[0]],\n                overflow[alignmentSides[1]]\n            ];\n            const allOverflows = [\n                ...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [],\n                {\n                    placement: currentPlacement,\n                    overflows: currentOverflows\n                }\n            ];\n            const nextPlacement = placements$1[currentIndex + 1];\n            // There are more placements to check.\n            if (nextPlacement) return {\n                data: {\n                    index: currentIndex + 1,\n                    overflows: allOverflows\n                },\n                reset: {\n                    placement: nextPlacement\n                }\n            };\n            const placementsSortedByMostSpace = allOverflows.map((d)=>{\n                const alignment = (0, $10310cf078d13212$export$f0989780f32bfcda)(d.placement);\n                return [\n                    d.placement,\n                    alignment && crossAxis ? // Check along the mainAxis and main crossAxis side.\n                    d.overflows.slice(0, 2).reduce((acc, v)=>acc + v, 0) : // Check only the mainAxis.\n                    d.overflows[0],\n                    d.overflows\n                ];\n            }).sort((a, b)=>a[1] - b[1]);\n            const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d)=>d[2].slice(0, // Aligned placements should not check their opposite crossAxis\n                // side.\n                (0, $10310cf078d13212$export$f0989780f32bfcda)(d[0]) ? 2 : 3).every((v)=>v <= 0));\n            const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n            if (resetPlacement !== placement) return {\n                data: {\n                    index: currentIndex + 1,\n                    overflows: allOverflows\n                },\n                reset: {\n                    placement: resetPlacement\n                }\n            };\n            return {};\n        }\n    };\n};\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */ const $973e4da43f2a375d$export$8a83211c878a3f1f = function(options) {\n    if (options === void 0) options = {};\n    return {\n        name: 'flip',\n        options: options,\n        async fn (state) {\n            var _middlewareData$arrow, _middlewareData$flip;\n            const { placement: placement, middlewareData: middlewareData, rects: rects, initialPlacement: initialPlacement, platform: platform, elements: elements } = state;\n            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true, fallbackPlacements: specifiedFallbackPlacements, fallbackStrategy: fallbackStrategy = 'bestFit', fallbackAxisSideDirection: fallbackAxisSideDirection = 'none', flipAlignment: flipAlignment = true, ...detectOverflowOptions } = (0, $10310cf078d13212$export$fef61f332f2c0afc)(options, state);\n            // If a reset by the arrow was caused due to an alignment offset being\n            // added, we should skip any logic now since `flip()` has already done its\n            // work.\n            // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n            if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) return {};\n            const side = (0, $10310cf078d13212$export$3c915306cb7fc97a)(placement);\n            const initialSideAxis = (0, $10310cf078d13212$export$f28e8f882010718a)(initialPlacement);\n            const isBasePlacement = (0, $10310cf078d13212$export$3c915306cb7fc97a)(initialPlacement) === initialPlacement;\n            const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n            const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [\n                (0, $10310cf078d13212$export$9c5e28bad23365fa)(initialPlacement)\n            ] : (0, $10310cf078d13212$export$496432a3699e50b1)(initialPlacement));\n            const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n            if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) fallbackPlacements.push(...(0, $10310cf078d13212$export$a9b6fb18fd92c3ec)(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n            const placements = [\n                initialPlacement,\n                ...fallbackPlacements\n            ];\n            const overflow = await $973e4da43f2a375d$export$37b6bde19b108ecc(state, detectOverflowOptions);\n            const overflows = [];\n            let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n            if (checkMainAxis) overflows.push(overflow[side]);\n            if (checkCrossAxis) {\n                const sides = (0, $10310cf078d13212$export$be42861551f17911)(placement, rects, rtl);\n                overflows.push(overflow[sides[0]], overflow[sides[1]]);\n            }\n            overflowsData = [\n                ...overflowsData,\n                {\n                    placement: placement,\n                    overflows: overflows\n                }\n            ];\n            // One or more sides is overflowing.\n            if (!overflows.every((side)=>side <= 0)) {\n                var _middlewareData$flip2, _overflowsData$filter;\n                const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n                const nextPlacement = placements[nextIndex];\n                if (nextPlacement) {\n                    const ignoreCrossAxisOverflow = checkCrossAxis === 'alignment' ? initialSideAxis !== (0, $10310cf078d13212$export$f28e8f882010718a)(nextPlacement) : false;\n                    if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis\n                    // overflows the main axis.\n                    overflowsData.every((d)=>d.overflows[0] > 0 && (0, $10310cf078d13212$export$f28e8f882010718a)(d.placement) === initialSideAxis)) // Try next placement and re-run the lifecycle.\n                    return {\n                        data: {\n                            index: nextIndex,\n                            overflows: overflowsData\n                        },\n                        reset: {\n                            placement: nextPlacement\n                        }\n                    };\n                }\n                // First, find the candidates that fit on the mainAxis side of overflow,\n                // then find the placement that fits the best on the main crossAxis side.\n                let resetPlacement = (_overflowsData$filter = overflowsData.filter((d)=>d.overflows[0] <= 0).sort((a, b)=>a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n                // Otherwise fallback.\n                if (!resetPlacement) switch(fallbackStrategy){\n                    case 'bestFit':\n                        {\n                            var _overflowsData$filter2;\n                            const placement = (_overflowsData$filter2 = overflowsData.filter((d)=>{\n                                if (hasFallbackAxisSideDirection) {\n                                    const currentSideAxis = (0, $10310cf078d13212$export$f28e8f882010718a)(d.placement);\n                                    return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal\n                                    // reading directions favoring greater width.\n                                    currentSideAxis === 'y';\n                                }\n                                return true;\n                            }).map((d)=>[\n                                    d.placement,\n                                    d.overflows.filter((overflow)=>overflow > 0).reduce((acc, overflow)=>acc + overflow, 0)\n                                ]).sort((a, b)=>a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                            if (placement) resetPlacement = placement;\n                            break;\n                        }\n                    case 'initialPlacement':\n                        resetPlacement = initialPlacement;\n                        break;\n                }\n                if (placement !== resetPlacement) return {\n                    reset: {\n                        placement: resetPlacement\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\nfunction $973e4da43f2a375d$var$getSideOffsets(overflow, rect) {\n    return {\n        top: overflow.top - rect.height,\n        right: overflow.right - rect.width,\n        bottom: overflow.bottom - rect.height,\n        left: overflow.left - rect.width\n    };\n}\nfunction $973e4da43f2a375d$var$isAnySideFullyClipped(overflow) {\n    return (0, $10310cf078d13212$export$832b6fa47fa053d2).some((side)=>overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */ const $973e4da43f2a375d$export$fe8985bb6374093c = function(options) {\n    if (options === void 0) options = {};\n    return {\n        name: 'hide',\n        options: options,\n        async fn (state) {\n            const { rects: rects } = state;\n            const { strategy: strategy = 'referenceHidden', ...detectOverflowOptions } = (0, $10310cf078d13212$export$fef61f332f2c0afc)(options, state);\n            switch(strategy){\n                case 'referenceHidden':\n                    {\n                        const overflow = await $973e4da43f2a375d$export$37b6bde19b108ecc(state, {\n                            ...detectOverflowOptions,\n                            elementContext: 'reference'\n                        });\n                        const offsets = $973e4da43f2a375d$var$getSideOffsets(overflow, rects.reference);\n                        return {\n                            data: {\n                                referenceHiddenOffsets: offsets,\n                                referenceHidden: $973e4da43f2a375d$var$isAnySideFullyClipped(offsets)\n                            }\n                        };\n                    }\n                case 'escaped':\n                    {\n                        const overflow = await $973e4da43f2a375d$export$37b6bde19b108ecc(state, {\n                            ...detectOverflowOptions,\n                            altBoundary: true\n                        });\n                        const offsets = $973e4da43f2a375d$var$getSideOffsets(overflow, rects.floating);\n                        return {\n                            data: {\n                                escapedOffsets: offsets,\n                                escaped: $973e4da43f2a375d$var$isAnySideFullyClipped(offsets)\n                            }\n                        };\n                    }\n                default:\n                    return {};\n            }\n        }\n    };\n};\nfunction $973e4da43f2a375d$var$getBoundingRect(rects) {\n    const minX = (0, $10310cf078d13212$export$96ec731ed4dcb222)(...rects.map((rect)=>rect.left));\n    const minY = (0, $10310cf078d13212$export$96ec731ed4dcb222)(...rects.map((rect)=>rect.top));\n    const maxX = (0, $10310cf078d13212$export$8960430cfd85939f)(...rects.map((rect)=>rect.right));\n    const maxY = (0, $10310cf078d13212$export$8960430cfd85939f)(...rects.map((rect)=>rect.bottom));\n    return {\n        x: minX,\n        y: minY,\n        width: maxX - minX,\n        height: maxY - minY\n    };\n}\nfunction $973e4da43f2a375d$var$getRectsByLine(rects) {\n    const sortedRects = rects.slice().sort((a, b)=>a.y - b.y);\n    const groups = [];\n    let prevRect = null;\n    for(let i = 0; i < sortedRects.length; i++){\n        const rect = sortedRects[i];\n        if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) groups.push([\n            rect\n        ]);\n        else groups[groups.length - 1].push(rect);\n        prevRect = rect;\n    }\n    return groups.map((rect)=>(0, $10310cf078d13212$export$ee05aea0aeecbad4)($973e4da43f2a375d$var$getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */ const $973e4da43f2a375d$export$18c8ad048e32c7d5 = function(options) {\n    if (options === void 0) options = {};\n    return {\n        name: 'inline',\n        options: options,\n        async fn (state) {\n            const { placement: placement, elements: elements, rects: rects, platform: platform, strategy: strategy } = state;\n            // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n            // ClientRect's bounds, despite the event listener being triggered. A\n            // padding of 2 seems to handle this issue.\n            const { padding: padding = 2, x: x, y: y } = (0, $10310cf078d13212$export$fef61f332f2c0afc)(options, state);\n            const nativeClientRects = Array.from(await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference)) || []);\n            const clientRects = $973e4da43f2a375d$var$getRectsByLine(nativeClientRects);\n            const fallback = (0, $10310cf078d13212$export$ee05aea0aeecbad4)($973e4da43f2a375d$var$getBoundingRect(nativeClientRects));\n            const paddingObject = (0, $10310cf078d13212$export$598c291c29bc2e71)(padding);\n            function getBoundingClientRect() {\n                // There are two rects and they are disjoined.\n                if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) // Find the first rect in which the point is fully inside.\n                return clientRects.find((rect)=>x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n                // There are 2 or more connected rects.\n                if (clientRects.length >= 2) {\n                    if ((0, $10310cf078d13212$export$f28e8f882010718a)(placement) === 'y') {\n                        const firstRect = clientRects[0];\n                        const lastRect = clientRects[clientRects.length - 1];\n                        const isTop = (0, $10310cf078d13212$export$3c915306cb7fc97a)(placement) === 'top';\n                        const top = firstRect.top;\n                        const bottom = lastRect.bottom;\n                        const left = isTop ? firstRect.left : lastRect.left;\n                        const right = isTop ? firstRect.right : lastRect.right;\n                        const width = right - left;\n                        const height = bottom - top;\n                        return {\n                            top: top,\n                            bottom: bottom,\n                            left: left,\n                            right: right,\n                            width: width,\n                            height: height,\n                            x: left,\n                            y: top\n                        };\n                    }\n                    const isLeftSide = (0, $10310cf078d13212$export$3c915306cb7fc97a)(placement) === 'left';\n                    const maxRight = (0, $10310cf078d13212$export$8960430cfd85939f)(...clientRects.map((rect)=>rect.right));\n                    const minLeft = (0, $10310cf078d13212$export$96ec731ed4dcb222)(...clientRects.map((rect)=>rect.left));\n                    const measureRects = clientRects.filter((rect)=>isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n                    const top = measureRects[0].top;\n                    const bottom = measureRects[measureRects.length - 1].bottom;\n                    const left = minLeft;\n                    const right = maxRight;\n                    const width = right - left;\n                    const height = bottom - top;\n                    return {\n                        top: top,\n                        bottom: bottom,\n                        left: left,\n                        right: right,\n                        width: width,\n                        height: height,\n                        x: left,\n                        y: top\n                    };\n                }\n                return fallback;\n            }\n            const resetRects = await platform.getElementRects({\n                reference: {\n                    getBoundingClientRect: getBoundingClientRect\n                },\n                floating: elements.floating,\n                strategy: strategy\n            });\n            if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) return {\n                reset: {\n                    rects: resetRects\n                }\n            };\n            return {};\n        }\n    };\n};\nconst $973e4da43f2a375d$var$originSides = /*#__PURE__*/ new Set([\n    'left',\n    'top'\n]);\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\nasync function $973e4da43f2a375d$var$convertValueToCoords(state, options) {\n    const { placement: placement, platform: platform, elements: elements } = state;\n    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n    const side = (0, $10310cf078d13212$export$3c915306cb7fc97a)(placement);\n    const alignment = (0, $10310cf078d13212$export$f0989780f32bfcda)(placement);\n    const isVertical = (0, $10310cf078d13212$export$f28e8f882010718a)(placement) === 'y';\n    const mainAxisMulti = $973e4da43f2a375d$var$originSides.has(side) ? -1 : 1;\n    const crossAxisMulti = rtl && isVertical ? -1 : 1;\n    const rawValue = (0, $10310cf078d13212$export$fef61f332f2c0afc)(options, state);\n    // eslint-disable-next-line prefer-const\n    let { mainAxis: mainAxis, crossAxis: crossAxis, alignmentAxis: alignmentAxis } = typeof rawValue === 'number' ? {\n        mainAxis: rawValue,\n        crossAxis: 0,\n        alignmentAxis: null\n    } : {\n        mainAxis: rawValue.mainAxis || 0,\n        crossAxis: rawValue.crossAxis || 0,\n        alignmentAxis: rawValue.alignmentAxis\n    };\n    if (alignment && typeof alignmentAxis === 'number') crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n    return isVertical ? {\n        x: crossAxis * crossAxisMulti,\n        y: mainAxis * mainAxisMulti\n    } : {\n        x: mainAxis * mainAxisMulti,\n        y: crossAxis * crossAxisMulti\n    };\n}\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */ const $973e4da43f2a375d$export$cc800923e997bb8 = function(options) {\n    if (options === void 0) options = 0;\n    return {\n        name: 'offset',\n        options: options,\n        async fn (state) {\n            var _middlewareData$offse, _middlewareData$arrow;\n            const { x: x, y: y, placement: placement, middlewareData: middlewareData } = state;\n            const diffCoords = await $973e4da43f2a375d$var$convertValueToCoords(state, options);\n            // If the placement is the same and the arrow caused an alignment offset\n            // then we don't need to change the positioning coordinates.\n            if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) return {};\n            return {\n                x: x + diffCoords.x,\n                y: y + diffCoords.y,\n                data: {\n                    ...diffCoords,\n                    placement: placement\n                }\n            };\n        }\n    };\n};\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */ const $973e4da43f2a375d$export$fba63a578e423eb = function(options) {\n    if (options === void 0) options = {};\n    return {\n        name: 'shift',\n        options: options,\n        async fn (state) {\n            const { x: x, y: y, placement: placement } = state;\n            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = false, limiter: limiter = {\n                fn: (_ref)=>{\n                    let { x: x, y: y } = _ref;\n                    return {\n                        x: x,\n                        y: y\n                    };\n                }\n            }, ...detectOverflowOptions } = (0, $10310cf078d13212$export$fef61f332f2c0afc)(options, state);\n            const coords = {\n                x: x,\n                y: y\n            };\n            const overflow = await $973e4da43f2a375d$export$37b6bde19b108ecc(state, detectOverflowOptions);\n            const crossAxis = (0, $10310cf078d13212$export$f28e8f882010718a)((0, $10310cf078d13212$export$3c915306cb7fc97a)(placement));\n            const mainAxis = (0, $10310cf078d13212$export$8a000a963141ac32)(crossAxis);\n            let mainAxisCoord = coords[mainAxis];\n            let crossAxisCoord = coords[crossAxis];\n            if (checkMainAxis) {\n                const minSide = mainAxis === 'y' ? 'top' : 'left';\n                const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n                const min = mainAxisCoord + overflow[minSide];\n                const max = mainAxisCoord - overflow[maxSide];\n                mainAxisCoord = (0, $10310cf078d13212$export$7d15b64cf5a3a4c4)(min, mainAxisCoord, max);\n            }\n            if (checkCrossAxis) {\n                const minSide = crossAxis === 'y' ? 'top' : 'left';\n                const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n                const min = crossAxisCoord + overflow[minSide];\n                const max = crossAxisCoord - overflow[maxSide];\n                crossAxisCoord = (0, $10310cf078d13212$export$7d15b64cf5a3a4c4)(min, crossAxisCoord, max);\n            }\n            const limitedCoords = limiter.fn({\n                ...state,\n                [mainAxis]: mainAxisCoord,\n                [crossAxis]: crossAxisCoord\n            });\n            return {\n                ...limitedCoords,\n                data: {\n                    x: limitedCoords.x - x,\n                    y: limitedCoords.y - y,\n                    enabled: {\n                        [mainAxis]: checkMainAxis,\n                        [crossAxis]: checkCrossAxis\n                    }\n                }\n            };\n        }\n    };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */ const $973e4da43f2a375d$export$7bf07e38f3dc4b69 = function(options) {\n    if (options === void 0) options = {};\n    return {\n        options: options,\n        fn (state) {\n            const { x: x, y: y, placement: placement, rects: rects, middlewareData: middlewareData } = state;\n            const { offset: offset = 0, mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true } = (0, $10310cf078d13212$export$fef61f332f2c0afc)(options, state);\n            const coords = {\n                x: x,\n                y: y\n            };\n            const crossAxis = (0, $10310cf078d13212$export$f28e8f882010718a)(placement);\n            const mainAxis = (0, $10310cf078d13212$export$8a000a963141ac32)(crossAxis);\n            let mainAxisCoord = coords[mainAxis];\n            let crossAxisCoord = coords[crossAxis];\n            const rawOffset = (0, $10310cf078d13212$export$fef61f332f2c0afc)(offset, state);\n            const computedOffset = typeof rawOffset === 'number' ? {\n                mainAxis: rawOffset,\n                crossAxis: 0\n            } : {\n                mainAxis: 0,\n                crossAxis: 0,\n                ...rawOffset\n            };\n            if (checkMainAxis) {\n                const len = mainAxis === 'y' ? 'height' : 'width';\n                const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n                const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n                if (mainAxisCoord < limitMin) mainAxisCoord = limitMin;\n                else if (mainAxisCoord > limitMax) mainAxisCoord = limitMax;\n            }\n            if (checkCrossAxis) {\n                var _middlewareData$offse, _middlewareData$offse2;\n                const len = mainAxis === 'y' ? 'width' : 'height';\n                const isOriginSide = $973e4da43f2a375d$var$originSides.has((0, $10310cf078d13212$export$3c915306cb7fc97a)(placement));\n                const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n                const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n                if (crossAxisCoord < limitMin) crossAxisCoord = limitMin;\n                else if (crossAxisCoord > limitMax) crossAxisCoord = limitMax;\n            }\n            return {\n                [mainAxis]: mainAxisCoord,\n                [crossAxis]: crossAxisCoord\n            };\n        }\n    };\n};\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */ const $973e4da43f2a375d$export$346677f925de839c = function(options) {\n    if (options === void 0) options = {};\n    return {\n        name: 'size',\n        options: options,\n        async fn (state) {\n            var _state$middlewareData, _state$middlewareData2;\n            const { placement: placement, rects: rects, platform: platform, elements: elements } = state;\n            const { apply: apply = ()=>{}, ...detectOverflowOptions } = (0, $10310cf078d13212$export$fef61f332f2c0afc)(options, state);\n            const overflow = await $973e4da43f2a375d$export$37b6bde19b108ecc(state, detectOverflowOptions);\n            const side = (0, $10310cf078d13212$export$3c915306cb7fc97a)(placement);\n            const alignment = (0, $10310cf078d13212$export$f0989780f32bfcda)(placement);\n            const isYAxis = (0, $10310cf078d13212$export$f28e8f882010718a)(placement) === 'y';\n            const { width: width, height: height } = rects.floating;\n            let heightSide;\n            let widthSide;\n            if (side === 'top' || side === 'bottom') {\n                heightSide = side;\n                widthSide = alignment === (await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)) ? 'start' : 'end') ? 'left' : 'right';\n            } else {\n                widthSide = side;\n                heightSide = alignment === 'end' ? 'top' : 'bottom';\n            }\n            const maximumClippingHeight = height - overflow.top - overflow.bottom;\n            const maximumClippingWidth = width - overflow.left - overflow.right;\n            const overflowAvailableHeight = (0, $10310cf078d13212$export$96ec731ed4dcb222)(height - overflow[heightSide], maximumClippingHeight);\n            const overflowAvailableWidth = (0, $10310cf078d13212$export$96ec731ed4dcb222)(width - overflow[widthSide], maximumClippingWidth);\n            const noShift = !state.middlewareData.shift;\n            let availableHeight = overflowAvailableHeight;\n            let availableWidth = overflowAvailableWidth;\n            if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) availableWidth = maximumClippingWidth;\n            if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) availableHeight = maximumClippingHeight;\n            if (noShift && !alignment) {\n                const xMin = (0, $10310cf078d13212$export$8960430cfd85939f)(overflow.left, 0);\n                const xMax = (0, $10310cf078d13212$export$8960430cfd85939f)(overflow.right, 0);\n                const yMin = (0, $10310cf078d13212$export$8960430cfd85939f)(overflow.top, 0);\n                const yMax = (0, $10310cf078d13212$export$8960430cfd85939f)(overflow.bottom, 0);\n                if (isYAxis) availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : (0, $10310cf078d13212$export$8960430cfd85939f)(overflow.left, overflow.right));\n                else availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : (0, $10310cf078d13212$export$8960430cfd85939f)(overflow.top, overflow.bottom));\n            }\n            await apply({\n                ...state,\n                availableWidth: availableWidth,\n                availableHeight: availableHeight\n            });\n            const nextDimensions = await platform.getDimensions(elements.floating);\n            if (width !== nextDimensions.width || height !== nextDimensions.height) return {\n                reset: {\n                    rects: true\n                }\n            };\n            return {};\n        }\n    };\n};\n\n\n\nfunction $238ac70369f38756$var$hasWindow() {\n    return typeof window !== 'undefined';\n}\nfunction $238ac70369f38756$export$651544f548703224(node) {\n    if ($238ac70369f38756$export$8ee0fc9ee280b4ee(node)) return (node.nodeName || '').toLowerCase();\n    // Mocked nodes in testing environments may not be instances of Node. By\n    // returning `#document` an infinite loop won't occur.\n    // https://github.com/floating-ui/floating-ui/issues/2317\n    return '#document';\n}\nfunction $238ac70369f38756$export$38b2d434cce3ea22(node) {\n    var _node$ownerDocument;\n    return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction $238ac70369f38756$export$e495491855dc5418(node) {\n    var _ref;\n    return (_ref = ($238ac70369f38756$export$8ee0fc9ee280b4ee(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction $238ac70369f38756$export$8ee0fc9ee280b4ee(value) {\n    if (!$238ac70369f38756$var$hasWindow()) return false;\n    return value instanceof Node || value instanceof $238ac70369f38756$export$38b2d434cce3ea22(value).Node;\n}\nfunction $238ac70369f38756$export$45a5e7f76e0caa8d(value) {\n    if (!$238ac70369f38756$var$hasWindow()) return false;\n    return value instanceof Element || value instanceof $238ac70369f38756$export$38b2d434cce3ea22(value).Element;\n}\nfunction $238ac70369f38756$export$1b3bfaa9684536aa(value) {\n    if (!$238ac70369f38756$var$hasWindow()) return false;\n    return value instanceof HTMLElement || value instanceof $238ac70369f38756$export$38b2d434cce3ea22(value).HTMLElement;\n}\nfunction $238ac70369f38756$export$af51f0f06c0f328a(value) {\n    if (!$238ac70369f38756$var$hasWindow() || typeof ShadowRoot === 'undefined') return false;\n    return value instanceof ShadowRoot || value instanceof $238ac70369f38756$export$38b2d434cce3ea22(value).ShadowRoot;\n}\nconst $238ac70369f38756$var$invalidOverflowDisplayValues = /*#__PURE__*/ new Set([\n    'inline',\n    'contents'\n]);\nfunction $238ac70369f38756$export$989e911fa9af580a(element) {\n    const { overflow: overflow, overflowX: overflowX, overflowY: overflowY, display: display } = $238ac70369f38756$export$3735103072e4a80(element);\n    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !$238ac70369f38756$var$invalidOverflowDisplayValues.has(display);\n}\nconst $238ac70369f38756$var$tableElements = /*#__PURE__*/ new Set([\n    'table',\n    'td',\n    'th'\n]);\nfunction $238ac70369f38756$export$71535ffaa902797f(element) {\n    return $238ac70369f38756$var$tableElements.has($238ac70369f38756$export$651544f548703224(element));\n}\nconst $238ac70369f38756$var$topLayerSelectors = [\n    ':popover-open',\n    ':modal'\n];\nfunction $238ac70369f38756$export$89e651af02346cd4(element) {\n    return $238ac70369f38756$var$topLayerSelectors.some((selector)=>{\n        try {\n            return element.matches(selector);\n        } catch (_e) {\n            return false;\n        }\n    });\n}\nconst $238ac70369f38756$var$transformProperties = [\n    'transform',\n    'translate',\n    'scale',\n    'rotate',\n    'perspective'\n];\nconst $238ac70369f38756$var$willChangeValues = [\n    'transform',\n    'translate',\n    'scale',\n    'rotate',\n    'perspective',\n    'filter'\n];\nconst $238ac70369f38756$var$containValues = [\n    'paint',\n    'layout',\n    'strict',\n    'content'\n];\nfunction $238ac70369f38756$export$d6c4e8150c35fed1(elementOrCss) {\n    const webkit = $238ac70369f38756$export$78551043582a6a98();\n    const css = $238ac70369f38756$export$45a5e7f76e0caa8d(elementOrCss) ? $238ac70369f38756$export$3735103072e4a80(elementOrCss) : elementOrCss;\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    // https://drafts.csswg.org/css-transforms-2/#individual-transforms\n    return $238ac70369f38756$var$transformProperties.some((value)=>css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || $238ac70369f38756$var$willChangeValues.some((value)=>(css.willChange || '').includes(value)) || $238ac70369f38756$var$containValues.some((value)=>(css.contain || '').includes(value));\n}\nfunction $238ac70369f38756$export$940d8225183e1404(element) {\n    let currentNode = $238ac70369f38756$export$4e12058fc4d51d56(element);\n    while($238ac70369f38756$export$1b3bfaa9684536aa(currentNode) && !$238ac70369f38756$export$d1162fb0b6d4cd51(currentNode)){\n        if ($238ac70369f38756$export$d6c4e8150c35fed1(currentNode)) return currentNode;\n        else if ($238ac70369f38756$export$89e651af02346cd4(currentNode)) return null;\n        currentNode = $238ac70369f38756$export$4e12058fc4d51d56(currentNode);\n    }\n    return null;\n}\nfunction $238ac70369f38756$export$78551043582a6a98() {\n    if (typeof CSS === 'undefined' || !CSS.supports) return false;\n    return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nconst $238ac70369f38756$var$lastTraversableNodeNames = /*#__PURE__*/ new Set([\n    'html',\n    'body',\n    '#document'\n]);\nfunction $238ac70369f38756$export$d1162fb0b6d4cd51(node) {\n    return $238ac70369f38756$var$lastTraversableNodeNames.has($238ac70369f38756$export$651544f548703224(node));\n}\nfunction $238ac70369f38756$export$3735103072e4a80(element) {\n    return $238ac70369f38756$export$38b2d434cce3ea22(element).getComputedStyle(element);\n}\nfunction $238ac70369f38756$export$dc8fc79fa2800137(element) {\n    if ($238ac70369f38756$export$45a5e7f76e0caa8d(element)) return {\n        scrollLeft: element.scrollLeft,\n        scrollTop: element.scrollTop\n    };\n    return {\n        scrollLeft: element.scrollX,\n        scrollTop: element.scrollY\n    };\n}\nfunction $238ac70369f38756$export$4e12058fc4d51d56(node) {\n    if ($238ac70369f38756$export$651544f548703224(node) === 'html') return node;\n    const result = // Step into the shadow DOM of the parent of a slotted node.\n    node.assignedSlot || // DOM Element detected.\n    node.parentNode || // ShadowRoot detected.\n    $238ac70369f38756$export$af51f0f06c0f328a(node) && node.host || // Fallback.\n    $238ac70369f38756$export$e495491855dc5418(node);\n    return $238ac70369f38756$export$af51f0f06c0f328a(result) ? result.host : result;\n}\nfunction $238ac70369f38756$export$7cd01a57c8ca906c(node) {\n    const parentNode = $238ac70369f38756$export$4e12058fc4d51d56(node);\n    if ($238ac70369f38756$export$d1162fb0b6d4cd51(parentNode)) return node.ownerDocument ? node.ownerDocument.body : node.body;\n    if ($238ac70369f38756$export$1b3bfaa9684536aa(parentNode) && $238ac70369f38756$export$989e911fa9af580a(parentNode)) return parentNode;\n    return $238ac70369f38756$export$7cd01a57c8ca906c(parentNode);\n}\nfunction $238ac70369f38756$export$3b57c1601291186b(node, list, traverseIframes) {\n    var _node$ownerDocument2;\n    if (list === void 0) list = [];\n    if (traverseIframes === void 0) traverseIframes = true;\n    const scrollableAncestor = $238ac70369f38756$export$7cd01a57c8ca906c(node);\n    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n    const win = $238ac70369f38756$export$38b2d434cce3ea22(scrollableAncestor);\n    if (isBody) {\n        const frameElement = $238ac70369f38756$export$7bf1f8740e3e34af(win);\n        return list.concat(win, win.visualViewport || [], $238ac70369f38756$export$989e911fa9af580a(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? $238ac70369f38756$export$3b57c1601291186b(frameElement) : []);\n    }\n    return list.concat(scrollableAncestor, $238ac70369f38756$export$3b57c1601291186b(scrollableAncestor, [], traverseIframes));\n}\nfunction $238ac70369f38756$export$7bf1f8740e3e34af(win) {\n    return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\n\nfunction $461947879dcdbcd4$var$getCssDimensions(element) {\n    const css = (0, $238ac70369f38756$export$3735103072e4a80)(element);\n    // In testing environments, the `width` and `height` properties are empty\n    // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n    let width = parseFloat(css.width) || 0;\n    let height = parseFloat(css.height) || 0;\n    const hasOffset = (0, $238ac70369f38756$export$1b3bfaa9684536aa)(element);\n    const offsetWidth = hasOffset ? element.offsetWidth : width;\n    const offsetHeight = hasOffset ? element.offsetHeight : height;\n    const shouldFallback = (0, $10310cf078d13212$export$2077e0241d6afd3c)(width) !== offsetWidth || (0, $10310cf078d13212$export$2077e0241d6afd3c)(height) !== offsetHeight;\n    if (shouldFallback) {\n        width = offsetWidth;\n        height = offsetHeight;\n    }\n    return {\n        width: width,\n        height: height,\n        $: shouldFallback\n    };\n}\nfunction $461947879dcdbcd4$var$unwrapElement(element) {\n    return !(0, $238ac70369f38756$export$45a5e7f76e0caa8d)(element) ? element.contextElement : element;\n}\nfunction $461947879dcdbcd4$var$getScale(element) {\n    const domElement = $461947879dcdbcd4$var$unwrapElement(element);\n    if (!(0, $238ac70369f38756$export$1b3bfaa9684536aa)(domElement)) return (0, $10310cf078d13212$export$a397704b5e280835)(1);\n    const rect = domElement.getBoundingClientRect();\n    const { width: width, height: height, $: $ } = $461947879dcdbcd4$var$getCssDimensions(domElement);\n    let x = ($ ? (0, $10310cf078d13212$export$2077e0241d6afd3c)(rect.width) : rect.width) / width;\n    let y = ($ ? (0, $10310cf078d13212$export$2077e0241d6afd3c)(rect.height) : rect.height) / height;\n    // 0, NaN, or Infinity should always fallback to 1.\n    if (!x || !Number.isFinite(x)) x = 1;\n    if (!y || !Number.isFinite(y)) y = 1;\n    return {\n        x: x,\n        y: y\n    };\n}\nconst $461947879dcdbcd4$var$noOffsets = /*#__PURE__*/ (0, $10310cf078d13212$export$a397704b5e280835)(0);\nfunction $461947879dcdbcd4$var$getVisualOffsets(element) {\n    const win = (0, $238ac70369f38756$export$38b2d434cce3ea22)(element);\n    if (!(0, $238ac70369f38756$export$78551043582a6a98)() || !win.visualViewport) return $461947879dcdbcd4$var$noOffsets;\n    return {\n        x: win.visualViewport.offsetLeft,\n        y: win.visualViewport.offsetTop\n    };\n}\nfunction $461947879dcdbcd4$var$shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n    if (isFixed === void 0) isFixed = false;\n    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== (0, $238ac70369f38756$export$38b2d434cce3ea22)(element)) return false;\n    return isFixed;\n}\nfunction $461947879dcdbcd4$var$getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n    if (includeScale === void 0) includeScale = false;\n    if (isFixedStrategy === void 0) isFixedStrategy = false;\n    const clientRect = element.getBoundingClientRect();\n    const domElement = $461947879dcdbcd4$var$unwrapElement(element);\n    let scale = (0, $10310cf078d13212$export$a397704b5e280835)(1);\n    if (includeScale) {\n        if (offsetParent) {\n            if ((0, $238ac70369f38756$export$45a5e7f76e0caa8d)(offsetParent)) scale = $461947879dcdbcd4$var$getScale(offsetParent);\n        } else scale = $461947879dcdbcd4$var$getScale(element);\n    }\n    const visualOffsets = $461947879dcdbcd4$var$shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? $461947879dcdbcd4$var$getVisualOffsets(domElement) : (0, $10310cf078d13212$export$a397704b5e280835)(0);\n    let x = (clientRect.left + visualOffsets.x) / scale.x;\n    let y = (clientRect.top + visualOffsets.y) / scale.y;\n    let width = clientRect.width / scale.x;\n    let height = clientRect.height / scale.y;\n    if (domElement) {\n        const win = (0, $238ac70369f38756$export$38b2d434cce3ea22)(domElement);\n        const offsetWin = offsetParent && (0, $238ac70369f38756$export$45a5e7f76e0caa8d)(offsetParent) ? (0, $238ac70369f38756$export$38b2d434cce3ea22)(offsetParent) : offsetParent;\n        let currentWin = win;\n        let currentIFrame = (0, $238ac70369f38756$export$7bf1f8740e3e34af)(currentWin);\n        while(currentIFrame && offsetParent && offsetWin !== currentWin){\n            const iframeScale = $461947879dcdbcd4$var$getScale(currentIFrame);\n            const iframeRect = currentIFrame.getBoundingClientRect();\n            const css = (0, $238ac70369f38756$export$3735103072e4a80)(currentIFrame);\n            const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n            const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n            x *= iframeScale.x;\n            y *= iframeScale.y;\n            width *= iframeScale.x;\n            height *= iframeScale.y;\n            x += left;\n            y += top;\n            currentWin = (0, $238ac70369f38756$export$38b2d434cce3ea22)(currentIFrame);\n            currentIFrame = (0, $238ac70369f38756$export$7bf1f8740e3e34af)(currentWin);\n        }\n    }\n    return (0, $10310cf078d13212$export$ee05aea0aeecbad4)({\n        width: width,\n        height: height,\n        x: x,\n        y: y\n    });\n}\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction $461947879dcdbcd4$var$getWindowScrollBarX(element, rect) {\n    const leftScroll = (0, $238ac70369f38756$export$dc8fc79fa2800137)(element).scrollLeft;\n    if (!rect) return $461947879dcdbcd4$var$getBoundingClientRect((0, $238ac70369f38756$export$e495491855dc5418)(element)).left + leftScroll;\n    return rect.left + leftScroll;\n}\nfunction $461947879dcdbcd4$var$getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {\n    if (ignoreScrollbarX === void 0) ignoreScrollbarX = false;\n    const htmlRect = documentElement.getBoundingClientRect();\n    const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : // RTL <body> scrollbar.\n    $461947879dcdbcd4$var$getWindowScrollBarX(documentElement, htmlRect));\n    const y = htmlRect.top + scroll.scrollTop;\n    return {\n        x: x,\n        y: y\n    };\n}\nfunction $461947879dcdbcd4$var$convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n    let { elements: elements, rect: rect, offsetParent: offsetParent, strategy: strategy } = _ref;\n    const isFixed = strategy === 'fixed';\n    const documentElement = (0, $238ac70369f38756$export$e495491855dc5418)(offsetParent);\n    const topLayer = elements ? (0, $238ac70369f38756$export$89e651af02346cd4)(elements.floating) : false;\n    if (offsetParent === documentElement || topLayer && isFixed) return rect;\n    let scroll = {\n        scrollLeft: 0,\n        scrollTop: 0\n    };\n    let scale = (0, $10310cf078d13212$export$a397704b5e280835)(1);\n    const offsets = (0, $10310cf078d13212$export$a397704b5e280835)(0);\n    const isOffsetParentAnElement = (0, $238ac70369f38756$export$1b3bfaa9684536aa)(offsetParent);\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n        if ((0, $238ac70369f38756$export$651544f548703224)(offsetParent) !== 'body' || (0, $238ac70369f38756$export$989e911fa9af580a)(documentElement)) scroll = (0, $238ac70369f38756$export$dc8fc79fa2800137)(offsetParent);\n        if ((0, $238ac70369f38756$export$1b3bfaa9684536aa)(offsetParent)) {\n            const offsetRect = $461947879dcdbcd4$var$getBoundingClientRect(offsetParent);\n            scale = $461947879dcdbcd4$var$getScale(offsetParent);\n            offsets.x = offsetRect.x + offsetParent.clientLeft;\n            offsets.y = offsetRect.y + offsetParent.clientTop;\n        }\n    }\n    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? $461947879dcdbcd4$var$getHTMLOffset(documentElement, scroll, true) : (0, $10310cf078d13212$export$a397704b5e280835)(0);\n    return {\n        width: rect.width * scale.x,\n        height: rect.height * scale.y,\n        x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n        y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n    };\n}\nfunction $461947879dcdbcd4$var$getClientRects(element) {\n    return Array.from(element.getClientRects());\n}\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction $461947879dcdbcd4$var$getDocumentRect(element) {\n    const html = (0, $238ac70369f38756$export$e495491855dc5418)(element);\n    const scroll = (0, $238ac70369f38756$export$dc8fc79fa2800137)(element);\n    const body = element.ownerDocument.body;\n    const width = (0, $10310cf078d13212$export$8960430cfd85939f)(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n    const height = (0, $10310cf078d13212$export$8960430cfd85939f)(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n    let x = -scroll.scrollLeft + $461947879dcdbcd4$var$getWindowScrollBarX(element);\n    const y = -scroll.scrollTop;\n    if ((0, $238ac70369f38756$export$3735103072e4a80)(body).direction === 'rtl') x += (0, $10310cf078d13212$export$8960430cfd85939f)(html.clientWidth, body.clientWidth) - width;\n    return {\n        width: width,\n        height: height,\n        x: x,\n        y: y\n    };\n}\nfunction $461947879dcdbcd4$var$getViewportRect(element, strategy) {\n    const win = (0, $238ac70369f38756$export$38b2d434cce3ea22)(element);\n    const html = (0, $238ac70369f38756$export$e495491855dc5418)(element);\n    const visualViewport = win.visualViewport;\n    let width = html.clientWidth;\n    let height = html.clientHeight;\n    let x = 0;\n    let y = 0;\n    if (visualViewport) {\n        width = visualViewport.width;\n        height = visualViewport.height;\n        const visualViewportBased = (0, $238ac70369f38756$export$78551043582a6a98)();\n        if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n            x = visualViewport.offsetLeft;\n            y = visualViewport.offsetTop;\n        }\n    }\n    return {\n        width: width,\n        height: height,\n        x: x,\n        y: y\n    };\n}\nconst $461947879dcdbcd4$var$absoluteOrFixed = /*#__PURE__*/ new Set([\n    'absolute',\n    'fixed'\n]);\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction $461947879dcdbcd4$var$getInnerBoundingClientRect(element, strategy) {\n    const clientRect = $461947879dcdbcd4$var$getBoundingClientRect(element, true, strategy === 'fixed');\n    const top = clientRect.top + element.clientTop;\n    const left = clientRect.left + element.clientLeft;\n    const scale = (0, $238ac70369f38756$export$1b3bfaa9684536aa)(element) ? $461947879dcdbcd4$var$getScale(element) : (0, $10310cf078d13212$export$a397704b5e280835)(1);\n    const width = element.clientWidth * scale.x;\n    const height = element.clientHeight * scale.y;\n    const x = left * scale.x;\n    const y = top * scale.y;\n    return {\n        width: width,\n        height: height,\n        x: x,\n        y: y\n    };\n}\nfunction $461947879dcdbcd4$var$getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n    let rect;\n    if (clippingAncestor === 'viewport') rect = $461947879dcdbcd4$var$getViewportRect(element, strategy);\n    else if (clippingAncestor === 'document') rect = $461947879dcdbcd4$var$getDocumentRect((0, $238ac70369f38756$export$e495491855dc5418)(element));\n    else if ((0, $238ac70369f38756$export$45a5e7f76e0caa8d)(clippingAncestor)) rect = $461947879dcdbcd4$var$getInnerBoundingClientRect(clippingAncestor, strategy);\n    else {\n        const visualOffsets = $461947879dcdbcd4$var$getVisualOffsets(element);\n        rect = {\n            x: clippingAncestor.x - visualOffsets.x,\n            y: clippingAncestor.y - visualOffsets.y,\n            width: clippingAncestor.width,\n            height: clippingAncestor.height\n        };\n    }\n    return (0, $10310cf078d13212$export$ee05aea0aeecbad4)(rect);\n}\nfunction $461947879dcdbcd4$var$hasFixedPositionAncestor(element, stopNode) {\n    const parentNode = (0, $238ac70369f38756$export$4e12058fc4d51d56)(element);\n    if (parentNode === stopNode || !(0, $238ac70369f38756$export$45a5e7f76e0caa8d)(parentNode) || (0, $238ac70369f38756$export$d1162fb0b6d4cd51)(parentNode)) return false;\n    return (0, $238ac70369f38756$export$3735103072e4a80)(parentNode).position === 'fixed' || $461947879dcdbcd4$var$hasFixedPositionAncestor(parentNode, stopNode);\n}\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction $461947879dcdbcd4$var$getClippingElementAncestors(element, cache) {\n    const cachedResult = cache.get(element);\n    if (cachedResult) return cachedResult;\n    let result = (0, $238ac70369f38756$export$3b57c1601291186b)(element, [], false).filter((el)=>(0, $238ac70369f38756$export$45a5e7f76e0caa8d)(el) && (0, $238ac70369f38756$export$651544f548703224)(el) !== 'body');\n    let currentContainingBlockComputedStyle = null;\n    const elementIsFixed = (0, $238ac70369f38756$export$3735103072e4a80)(element).position === 'fixed';\n    let currentNode = elementIsFixed ? (0, $238ac70369f38756$export$4e12058fc4d51d56)(element) : element;\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    while((0, $238ac70369f38756$export$45a5e7f76e0caa8d)(currentNode) && !(0, $238ac70369f38756$export$d1162fb0b6d4cd51)(currentNode)){\n        const computedStyle = (0, $238ac70369f38756$export$3735103072e4a80)(currentNode);\n        const currentNodeIsContaining = (0, $238ac70369f38756$export$d6c4e8150c35fed1)(currentNode);\n        if (!currentNodeIsContaining && computedStyle.position === 'fixed') currentContainingBlockComputedStyle = null;\n        const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && $461947879dcdbcd4$var$absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || (0, $238ac70369f38756$export$989e911fa9af580a)(currentNode) && !currentNodeIsContaining && $461947879dcdbcd4$var$hasFixedPositionAncestor(element, currentNode);\n        if (shouldDropCurrentNode) // Drop non-containing blocks.\n        result = result.filter((ancestor)=>ancestor !== currentNode);\n        else // Record last containing block for next iteration.\n        currentContainingBlockComputedStyle = computedStyle;\n        currentNode = (0, $238ac70369f38756$export$4e12058fc4d51d56)(currentNode);\n    }\n    cache.set(element, result);\n    return result;\n}\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction $461947879dcdbcd4$var$getClippingRect(_ref) {\n    let { element: element, boundary: boundary, rootBoundary: rootBoundary, strategy: strategy } = _ref;\n    const elementClippingAncestors = boundary === 'clippingAncestors' ? (0, $238ac70369f38756$export$89e651af02346cd4)(element) ? [] : $461947879dcdbcd4$var$getClippingElementAncestors(element, this._c) : [].concat(boundary);\n    const clippingAncestors = [\n        ...elementClippingAncestors,\n        rootBoundary\n    ];\n    const firstClippingAncestor = clippingAncestors[0];\n    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor)=>{\n        const rect = $461947879dcdbcd4$var$getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n        accRect.top = (0, $10310cf078d13212$export$8960430cfd85939f)(rect.top, accRect.top);\n        accRect.right = (0, $10310cf078d13212$export$96ec731ed4dcb222)(rect.right, accRect.right);\n        accRect.bottom = (0, $10310cf078d13212$export$96ec731ed4dcb222)(rect.bottom, accRect.bottom);\n        accRect.left = (0, $10310cf078d13212$export$8960430cfd85939f)(rect.left, accRect.left);\n        return accRect;\n    }, $461947879dcdbcd4$var$getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n    return {\n        width: clippingRect.right - clippingRect.left,\n        height: clippingRect.bottom - clippingRect.top,\n        x: clippingRect.left,\n        y: clippingRect.top\n    };\n}\nfunction $461947879dcdbcd4$var$getDimensions(element) {\n    const { width: width, height: height } = $461947879dcdbcd4$var$getCssDimensions(element);\n    return {\n        width: width,\n        height: height\n    };\n}\nfunction $461947879dcdbcd4$var$getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n    const isOffsetParentAnElement = (0, $238ac70369f38756$export$1b3bfaa9684536aa)(offsetParent);\n    const documentElement = (0, $238ac70369f38756$export$e495491855dc5418)(offsetParent);\n    const isFixed = strategy === 'fixed';\n    const rect = $461947879dcdbcd4$var$getBoundingClientRect(element, true, isFixed, offsetParent);\n    let scroll = {\n        scrollLeft: 0,\n        scrollTop: 0\n    };\n    const offsets = (0, $10310cf078d13212$export$a397704b5e280835)(0);\n    // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n    // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n    function setLeftRTLScrollbarOffset() {\n        offsets.x = $461947879dcdbcd4$var$getWindowScrollBarX(documentElement);\n    }\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n        if ((0, $238ac70369f38756$export$651544f548703224)(offsetParent) !== 'body' || (0, $238ac70369f38756$export$989e911fa9af580a)(documentElement)) scroll = (0, $238ac70369f38756$export$dc8fc79fa2800137)(offsetParent);\n        if (isOffsetParentAnElement) {\n            const offsetRect = $461947879dcdbcd4$var$getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n            offsets.x = offsetRect.x + offsetParent.clientLeft;\n            offsets.y = offsetRect.y + offsetParent.clientTop;\n        } else if (documentElement) setLeftRTLScrollbarOffset();\n    }\n    if (isFixed && !isOffsetParentAnElement && documentElement) setLeftRTLScrollbarOffset();\n    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? $461947879dcdbcd4$var$getHTMLOffset(documentElement, scroll) : (0, $10310cf078d13212$export$a397704b5e280835)(0);\n    const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n    const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n    return {\n        x: x,\n        y: y,\n        width: rect.width,\n        height: rect.height\n    };\n}\nfunction $461947879dcdbcd4$var$isStaticPositioned(element) {\n    return (0, $238ac70369f38756$export$3735103072e4a80)(element).position === 'static';\n}\nfunction $461947879dcdbcd4$var$getTrueOffsetParent(element, polyfill) {\n    if (!(0, $238ac70369f38756$export$1b3bfaa9684536aa)(element) || (0, $238ac70369f38756$export$3735103072e4a80)(element).position === 'fixed') return null;\n    if (polyfill) return polyfill(element);\n    let rawOffsetParent = element.offsetParent;\n    // Firefox returns the <html> element as the offsetParent if it's non-static,\n    // while Chrome and Safari return the <body> element. The <body> element must\n    // be used to perform the correct calculations even if the <html> element is\n    // non-static.\n    if ((0, $238ac70369f38756$export$e495491855dc5418)(element) === rawOffsetParent) rawOffsetParent = rawOffsetParent.ownerDocument.body;\n    return rawOffsetParent;\n}\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction $461947879dcdbcd4$var$getOffsetParent(element, polyfill) {\n    const win = (0, $238ac70369f38756$export$38b2d434cce3ea22)(element);\n    if ((0, $238ac70369f38756$export$89e651af02346cd4)(element)) return win;\n    if (!(0, $238ac70369f38756$export$1b3bfaa9684536aa)(element)) {\n        let svgOffsetParent = (0, $238ac70369f38756$export$4e12058fc4d51d56)(element);\n        while(svgOffsetParent && !(0, $238ac70369f38756$export$d1162fb0b6d4cd51)(svgOffsetParent)){\n            if ((0, $238ac70369f38756$export$45a5e7f76e0caa8d)(svgOffsetParent) && !$461947879dcdbcd4$var$isStaticPositioned(svgOffsetParent)) return svgOffsetParent;\n            svgOffsetParent = (0, $238ac70369f38756$export$4e12058fc4d51d56)(svgOffsetParent);\n        }\n        return win;\n    }\n    let offsetParent = $461947879dcdbcd4$var$getTrueOffsetParent(element, polyfill);\n    while(offsetParent && (0, $238ac70369f38756$export$71535ffaa902797f)(offsetParent) && $461947879dcdbcd4$var$isStaticPositioned(offsetParent))offsetParent = $461947879dcdbcd4$var$getTrueOffsetParent(offsetParent, polyfill);\n    if (offsetParent && (0, $238ac70369f38756$export$d1162fb0b6d4cd51)(offsetParent) && $461947879dcdbcd4$var$isStaticPositioned(offsetParent) && !(0, $238ac70369f38756$export$d6c4e8150c35fed1)(offsetParent)) return win;\n    return offsetParent || (0, $238ac70369f38756$export$940d8225183e1404)(element) || win;\n}\nconst $461947879dcdbcd4$var$getElementRects = async function(data) {\n    const getOffsetParentFn = this.getOffsetParent || $461947879dcdbcd4$var$getOffsetParent;\n    const getDimensionsFn = this.getDimensions;\n    const floatingDimensions = await getDimensionsFn(data.floating);\n    return {\n        reference: $461947879dcdbcd4$var$getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n        floating: {\n            x: 0,\n            y: 0,\n            width: floatingDimensions.width,\n            height: floatingDimensions.height\n        }\n    };\n};\nfunction $461947879dcdbcd4$var$isRTL(element) {\n    return (0, $238ac70369f38756$export$3735103072e4a80)(element).direction === 'rtl';\n}\nconst $461947879dcdbcd4$export$722a64dea1b767dc = {\n    convertOffsetParentRelativeRectToViewportRelativeRect: $461947879dcdbcd4$var$convertOffsetParentRelativeRectToViewportRelativeRect,\n    getDocumentElement: $238ac70369f38756$export$e495491855dc5418,\n    getClippingRect: $461947879dcdbcd4$var$getClippingRect,\n    getOffsetParent: $461947879dcdbcd4$var$getOffsetParent,\n    getElementRects: $461947879dcdbcd4$var$getElementRects,\n    getClientRects: $461947879dcdbcd4$var$getClientRects,\n    getDimensions: $461947879dcdbcd4$var$getDimensions,\n    getScale: $461947879dcdbcd4$var$getScale,\n    isElement: $238ac70369f38756$export$45a5e7f76e0caa8d,\n    isRTL: $461947879dcdbcd4$var$isRTL\n};\nfunction $461947879dcdbcd4$var$rectsAreEqual(a, b) {\n    return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n}\n// https://samthor.au/2021/observing-dom/\nfunction $461947879dcdbcd4$var$observeMove(element, onMove) {\n    let io = null;\n    let timeoutId;\n    const root = (0, $238ac70369f38756$export$e495491855dc5418)(element);\n    function cleanup() {\n        var _io;\n        clearTimeout(timeoutId);\n        (_io = io) == null || _io.disconnect();\n        io = null;\n    }\n    function refresh(skip, threshold) {\n        if (skip === void 0) skip = false;\n        if (threshold === void 0) threshold = 1;\n        cleanup();\n        const elementRectForRootMargin = element.getBoundingClientRect();\n        const { left: left, top: top, width: width, height: height } = elementRectForRootMargin;\n        if (!skip) onMove();\n        if (!width || !height) return;\n        const insetTop = (0, $10310cf078d13212$export$a3fe094919f356fd)(top);\n        const insetRight = (0, $10310cf078d13212$export$a3fe094919f356fd)(root.clientWidth - (left + width));\n        const insetBottom = (0, $10310cf078d13212$export$a3fe094919f356fd)(root.clientHeight - (top + height));\n        const insetLeft = (0, $10310cf078d13212$export$a3fe094919f356fd)(left);\n        const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n        const options = {\n            rootMargin: rootMargin,\n            threshold: (0, $10310cf078d13212$export$8960430cfd85939f)(0, (0, $10310cf078d13212$export$96ec731ed4dcb222)(1, threshold)) || 1\n        };\n        let isFirstUpdate = true;\n        function handleObserve(entries) {\n            const ratio = entries[0].intersectionRatio;\n            if (ratio !== threshold) {\n                if (!isFirstUpdate) return refresh();\n                if (!ratio) // If the reference is clipped, the ratio is 0. Throttle the refresh\n                // to prevent an infinite loop of updates.\n                timeoutId = setTimeout(()=>{\n                    refresh(false, 1e-7);\n                }, 1000);\n                else refresh(false, ratio);\n            }\n            if (ratio === 1 && !$461947879dcdbcd4$var$rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) // It's possible that even though the ratio is reported as 1, the\n            // element is not actually fully within the IntersectionObserver's root\n            // area anymore. This can happen under performance constraints. This may\n            // be a bug in the browser's IntersectionObserver implementation. To\n            // work around this, we compare the element's bounding rect now with\n            // what it was at the time we created the IntersectionObserver. If they\n            // are not equal then the element moved, so we refresh.\n            refresh();\n            isFirstUpdate = false;\n        }\n        // Older browsers don't support a `document` as the root and will throw an\n        // error.\n        try {\n            io = new IntersectionObserver(handleObserve, {\n                ...options,\n                // Handle <iframe>s\n                root: root.ownerDocument\n            });\n        } catch (_e) {\n            io = new IntersectionObserver(handleObserve, options);\n        }\n        io.observe(element);\n    }\n    refresh(true);\n    return cleanup;\n}\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */ function $461947879dcdbcd4$export$deee3a793edee05f(reference, floating, update, options) {\n    if (options === void 0) options = {};\n    const { ancestorScroll: ancestorScroll = true, ancestorResize: ancestorResize = true, elementResize: elementResize = typeof ResizeObserver === 'function', layoutShift: layoutShift = typeof IntersectionObserver === 'function', animationFrame: animationFrame = false } = options;\n    const referenceEl = $461947879dcdbcd4$var$unwrapElement(reference);\n    const ancestors = ancestorScroll || ancestorResize ? [\n        ...referenceEl ? (0, $238ac70369f38756$export$3b57c1601291186b)(referenceEl) : [],\n        ...(0, $238ac70369f38756$export$3b57c1601291186b)(floating)\n    ] : [];\n    ancestors.forEach((ancestor)=>{\n        ancestorScroll && ancestor.addEventListener('scroll', update, {\n            passive: true\n        });\n        ancestorResize && ancestor.addEventListener('resize', update);\n    });\n    const cleanupIo = referenceEl && layoutShift ? $461947879dcdbcd4$var$observeMove(referenceEl, update) : null;\n    let reobserveFrame = -1;\n    let resizeObserver = null;\n    if (elementResize) {\n        resizeObserver = new ResizeObserver((_ref)=>{\n            let [firstEntry] = _ref;\n            if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n                // Prevent update loops when using the `size` middleware.\n                // https://github.com/floating-ui/floating-ui/issues/1740\n                resizeObserver.unobserve(floating);\n                cancelAnimationFrame(reobserveFrame);\n                reobserveFrame = requestAnimationFrame(()=>{\n                    var _resizeObserver;\n                    (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n                });\n            }\n            update();\n        });\n        if (referenceEl && !animationFrame) resizeObserver.observe(referenceEl);\n        resizeObserver.observe(floating);\n    }\n    let frameId;\n    let prevRefRect = animationFrame ? $461947879dcdbcd4$var$getBoundingClientRect(reference) : null;\n    if (animationFrame) frameLoop();\n    function frameLoop() {\n        const nextRefRect = $461947879dcdbcd4$var$getBoundingClientRect(reference);\n        if (prevRefRect && !$461947879dcdbcd4$var$rectsAreEqual(prevRefRect, nextRefRect)) update();\n        prevRefRect = nextRefRect;\n        frameId = requestAnimationFrame(frameLoop);\n    }\n    update();\n    return ()=>{\n        var _resizeObserver2;\n        ancestors.forEach((ancestor)=>{\n            ancestorScroll && ancestor.removeEventListener('scroll', update);\n            ancestorResize && ancestor.removeEventListener('resize', update);\n        });\n        cleanupIo == null || cleanupIo();\n        (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n        resizeObserver = null;\n        if (animationFrame) cancelAnimationFrame(frameId);\n    };\n}\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */ const $461947879dcdbcd4$export$37b6bde19b108ecc = (0, $973e4da43f2a375d$export$37b6bde19b108ecc);\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */ const $461947879dcdbcd4$export$cc800923e997bb8 = (0, $973e4da43f2a375d$export$cc800923e997bb8);\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */ const $461947879dcdbcd4$export$91fb6ecbd551914 = (0, $973e4da43f2a375d$export$91fb6ecbd551914);\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */ const $461947879dcdbcd4$export$fba63a578e423eb = (0, $973e4da43f2a375d$export$fba63a578e423eb);\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */ const $461947879dcdbcd4$export$8a83211c878a3f1f = (0, $973e4da43f2a375d$export$8a83211c878a3f1f);\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */ const $461947879dcdbcd4$export$346677f925de839c = (0, $973e4da43f2a375d$export$346677f925de839c);\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */ const $461947879dcdbcd4$export$fe8985bb6374093c = (0, $973e4da43f2a375d$export$fe8985bb6374093c);\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */ const $461947879dcdbcd4$export$f2120bbfa5450bd2 = (0, $973e4da43f2a375d$export$f2120bbfa5450bd2);\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */ const $461947879dcdbcd4$export$18c8ad048e32c7d5 = (0, $973e4da43f2a375d$export$18c8ad048e32c7d5);\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */ const $461947879dcdbcd4$export$7bf07e38f3dc4b69 = (0, $973e4da43f2a375d$export$7bf07e38f3dc4b69);\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */ const $461947879dcdbcd4$export$48a53dcb22e581d0 = (reference, floating, options)=>{\n    // This caches the expensive `getClippingElementAncestors` function so that\n    // multiple lifecycle resets re-use the same result. It only lives for a\n    // single call. If other functions become expensive, we can add them as well.\n    const cache = new Map();\n    const mergedOptions = {\n        platform: $461947879dcdbcd4$export$722a64dea1b767dc,\n        ...options\n    };\n    const platformWithCache = {\n        ...mergedOptions.platform,\n        _c: cache\n    };\n    return (0, $973e4da43f2a375d$export$48a53dcb22e581d0)(reference, floating, {\n        ...mergedOptions,\n        platform: platformWithCache\n    });\n};\n\n\n// DOM Elements\nconst $48731e7e213a0ef5$var$hamburger = document.querySelector('.hamburger');\nconst $48731e7e213a0ef5$var$navMenu = document.querySelector('.nav-menu');\nconst $48731e7e213a0ef5$var$navLinks = document.querySelectorAll('.nav-link');\nconst $48731e7e213a0ef5$var$navbar = document.querySelector('.navbar');\nconst $48731e7e213a0ef5$var$hero = document.querySelector('.hero');\n// Custom Cursor Logic\nconst $48731e7e213a0ef5$var$backToTopBtn = document.querySelector('.back-to-top-btn');\nconst $48731e7e213a0ef5$var$tooltip = document.querySelector('#tooltip');\n// Tooltip Logic\nconst $48731e7e213a0ef5$var$elementsWithTooltip = document.querySelectorAll('[data-tooltip]');\n$48731e7e213a0ef5$var$elementsWithTooltip.forEach((element)=>{\n    const reference = element;\n    const tooltipText = reference.dataset.tooltip || '';\n    const showTooltip = ()=>{\n        if (!$48731e7e213a0ef5$var$tooltip) return;\n        $48731e7e213a0ef5$var$tooltip.textContent = tooltipText;\n        $48731e7e213a0ef5$var$tooltip.classList.add('visible');\n        (0, $461947879dcdbcd4$export$48a53dcb22e581d0)(reference, $48731e7e213a0ef5$var$tooltip, {\n            placement: 'top',\n            middleware: [\n                (0, $461947879dcdbcd4$export$cc800923e997bb8)(8),\n                (0, $461947879dcdbcd4$export$8a83211c878a3f1f)(),\n                (0, $461947879dcdbcd4$export$fba63a578e423eb)({\n                    padding: 5\n                })\n            ]\n        }).then(({ x: x, y: y })=>{\n            Object.assign($48731e7e213a0ef5$var$tooltip.style, {\n                left: `${x}px`,\n                top: `${y}px`\n            });\n        });\n    };\n    const hideTooltip = ()=>{\n        if ($48731e7e213a0ef5$var$tooltip) $48731e7e213a0ef5$var$tooltip.classList.remove('visible');\n    };\n    reference.addEventListener('mouseenter', showTooltip);\n    reference.addEventListener('mouseleave', hideTooltip);\n    reference.addEventListener('focus', showTooltip);\n    reference.addEventListener('blur', hideTooltip);\n});\n// Back to Top Button Logic\nwindow.addEventListener('scroll', ()=>{\n    if (window.scrollY > 300) $48731e7e213a0ef5$var$backToTopBtn?.classList.add('visible');\n    else $48731e7e213a0ef5$var$backToTopBtn?.classList.remove('visible');\n});\n$48731e7e213a0ef5$var$backToTopBtn?.addEventListener('click', (e)=>{\n    e.preventDefault();\n    document.querySelector('#home')?.scrollIntoView({\n        behavior: 'smooth'\n    });\n});\n// Mobile Navigation Toggle\nfunction $48731e7e213a0ef5$var$toggleMobileMenu() {\n    // Only toggle mobile menu on devices with width <= 1024px\n    if (window.innerWidth <= 1024) {\n        $48731e7e213a0ef5$var$hamburger?.classList.toggle('active');\n        $48731e7e213a0ef5$var$navMenu?.classList.toggle('active');\n        // Prevent body scroll when menu is open\n        if ($48731e7e213a0ef5$var$navMenu?.classList.contains('active')) document.body.style.overflow = 'hidden';\n        else document.body.style.overflow = 'auto';\n    }\n}\nfunction $48731e7e213a0ef5$var$closeMobileMenu() {\n    // Only close mobile menu on devices where it might be active\n    if (window.innerWidth <= 1024) {\n        $48731e7e213a0ef5$var$hamburger?.classList.remove('active');\n        $48731e7e213a0ef5$var$navMenu?.classList.remove('active');\n        document.body.style.overflow = 'auto';\n    }\n}\n$48731e7e213a0ef5$var$hamburger?.addEventListener('click', (e)=>{\n    e.preventDefault();\n    e.stopPropagation();\n    $48731e7e213a0ef5$var$toggleMobileMenu();\n});\n// Add touch support for mobile devices\n$48731e7e213a0ef5$var$hamburger?.addEventListener('touchstart', (e)=>{\n    e.preventDefault();\n    e.stopPropagation();\n}, {\n    passive: false\n});\n$48731e7e213a0ef5$var$hamburger?.addEventListener('touchend', (e)=>{\n    e.preventDefault();\n    e.stopPropagation();\n    $48731e7e213a0ef5$var$toggleMobileMenu();\n}, {\n    passive: false\n});\n// Close mobile menu when clicking on a link\n$48731e7e213a0ef5$var$navLinks.forEach((link)=>{\n    link.addEventListener('click', $48731e7e213a0ef5$var$closeMobileMenu);\n    // Add touch support for navigation links\n    link.addEventListener('touchend', (e)=>{\n        // Small delay to ensure smooth transition\n        setTimeout($48731e7e213a0ef5$var$closeMobileMenu, 100);\n    }, {\n        passive: true\n    });\n});\n// Close mobile menu when clicking outside\ndocument.addEventListener('click', (e)=>{\n    const target = e.target;\n    if (window.innerWidth <= 1024 && $48731e7e213a0ef5$var$navMenu?.classList.contains('active') && !$48731e7e213a0ef5$var$navMenu.contains(target) && !$48731e7e213a0ef5$var$hamburger?.contains(target)) $48731e7e213a0ef5$var$closeMobileMenu();\n});\n// Close mobile menu when touching outside (mobile)\ndocument.addEventListener('touchstart', (e)=>{\n    const target = e.target;\n    if (window.innerWidth <= 1024 && $48731e7e213a0ef5$var$navMenu?.classList.contains('active') && !$48731e7e213a0ef5$var$navMenu.contains(target) && !$48731e7e213a0ef5$var$hamburger?.contains(target)) $48731e7e213a0ef5$var$closeMobileMenu();\n}, {\n    passive: true\n});\n// Handle window resize\nwindow.addEventListener('resize', ()=>{\n    if (window.innerWidth > 1024) {\n        $48731e7e213a0ef5$var$closeMobileMenu();\n        // Ensure navbar is in correct state for desktop\n        document.body.style.overflow = 'auto';\n        $48731e7e213a0ef5$var$hamburger?.classList.remove('active');\n        $48731e7e213a0ef5$var$navMenu?.classList.remove('active');\n    }\n});\n// Handle escape key to close mobile menu\ndocument.addEventListener('keydown', (e)=>{\n    if (e.key === 'Escape' && window.innerWidth <= 1024 && $48731e7e213a0ef5$var$navMenu?.classList.contains('active')) $48731e7e213a0ef5$var$closeMobileMenu();\n});\n// Prevent scrolling on mobile when menu is open\nlet $48731e7e213a0ef5$var$startY = 0;\ndocument.addEventListener('touchstart', (e)=>{\n    if (window.innerWidth <= 1024 && $48731e7e213a0ef5$var$navMenu?.classList.contains('active')) $48731e7e213a0ef5$var$startY = e.touches[0].clientY;\n}, {\n    passive: true\n});\ndocument.addEventListener('touchmove', (e)=>{\n    if (window.innerWidth <= 1024 && $48731e7e213a0ef5$var$navMenu?.classList.contains('active')) {\n        const target = e.target;\n        if (!$48731e7e213a0ef5$var$navMenu.contains(target)) e.preventDefault();\n    }\n}, {\n    passive: false\n});\n// Navbar Background on Scroll\nwindow.addEventListener('scroll', ()=>{\n    if (window.scrollY > 100) $48731e7e213a0ef5$var$navbar?.classList.add('scrolled');\n    else $48731e7e213a0ef5$var$navbar?.classList.remove('scrolled');\n});\n// Active Navigation Link Highlighting\nwindow.addEventListener('scroll', ()=>{\n    const scrollY = window.scrollY;\n    let currentSectionId = \"\";\n    const sections = document.querySelectorAll('section[id]');\n    sections.forEach((section)=>{\n        const sectionTop = section.offsetTop - 85; // Offset per l'altezza della navbar + buffer\n        if (scrollY >= sectionTop) currentSectionId = section.getAttribute('id') || \"\";\n    });\n    // Gestisce il caso in cui si arriva in fondo alla pagina\n    if (window.innerHeight + window.scrollY >= document.body.scrollHeight - 2) {\n        const lastSection = sections[sections.length - 1];\n        if (lastSection) currentSectionId = lastSection.getAttribute('id') || \"\";\n    }\n    $48731e7e213a0ef5$var$navLinks.forEach((link)=>{\n        link.classList.remove('active');\n        if (link.getAttribute('href') === `#${currentSectionId}`) link.classList.add('active');\n    });\n});\n// Animated Counter for Stats\nfunction $48731e7e213a0ef5$var$animateCounter(element, target, duration = 2000, suffix = '') {\n    let start = 0;\n    const increment = target / (duration / 16);\n    const timer = setInterval(()=>{\n        start += increment;\n        if (start >= target) {\n            element.textContent = target.toString() + suffix;\n            clearInterval(timer);\n        } else element.textContent = Math.floor(start).toString() + suffix;\n    }, 16);\n}\n// Intersection Observer for Animations\nconst $48731e7e213a0ef5$var$observerOptions = {\n    threshold: 0.1,\n    rootMargin: '0px 0px -50px 0px'\n};\nconst $48731e7e213a0ef5$var$observer = new IntersectionObserver((entries)=>{\n    entries.forEach((entry)=>{\n        if (entry.isIntersecting) {\n            entry.target.classList.add('animate');\n            // Text animation for section headers\n            if (entry.target.classList.contains('section-header')) {\n                const spans = entry.target.querySelectorAll('h2 span, p span');\n                spans.forEach((span, index)=>{\n                    span.style.transitionDelay = `${index * 0.03}s`;\n                    span.style.opacity = '1';\n                    span.style.transform = 'translateY(0) scale(1)';\n                });\n            }\n            // Animate counters when stats section is visible\n            if (entry.target.classList.contains('stats')) {\n                const statNumbers = entry.target.querySelectorAll('.stat h4');\n                statNumbers.forEach((stat)=>{\n                    const target = parseInt(stat.dataset.target || '0');\n                    const suffix = stat.dataset.suffix || '';\n                    if (!isNaN(target)) $48731e7e213a0ef5$var$animateCounter(stat, target, 2000, suffix);\n                });\n                // Unobserve the stats section after animation to prevent re-triggering\n                $48731e7e213a0ef5$var$observer.unobserve(entry.target);\n            }\n        }\n    });\n}, $48731e7e213a0ef5$var$observerOptions);\nfunction $48731e7e213a0ef5$var$calculateAge(birthDate) {\n    const today = new Date();\n    let age = today.getFullYear() - birthDate.getFullYear();\n    const m = today.getMonth() - birthDate.getMonth();\n    if (m < 0 || m === 0 && today.getDate() < birthDate.getDate()) age--;\n    return age;\n}\n// Typing animation for hero text\nfunction $48731e7e213a0ef5$var$typeWriter(element, text, speed = 100) {\n    let i = 0;\n    function type() {\n        if (i < text.length) {\n            if (element) element.textContent += text.charAt(i);\n            i++;\n            setTimeout(type, speed);\n        }\n    }\n    type();\n}\nfunction $48731e7e213a0ef5$var$initInteractiveParticles(canvas) {\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    let width = canvas.offsetWidth;\n    let height = canvas.offsetHeight;\n    canvas.width = width;\n    canvas.height = height;\n    const mouse = {\n        x: width / 2,\n        y: height / 2\n    };\n    canvas.addEventListener('mousemove', (event)=>{\n        const rect = canvas.getBoundingClientRect();\n        mouse.x = event.clientX - rect.left;\n        mouse.y = event.clientY - rect.top;\n    });\n    canvas.addEventListener('mouseleave', ()=>{\n        mouse.x = width / 2;\n        mouse.y = height / 2;\n    });\n    window.addEventListener('resize', ()=>{\n        width = canvas.offsetWidth;\n        height = canvas.offsetHeight;\n        canvas.width = width;\n        canvas.height = height;\n    });\n    class Particle {\n        constructor(){\n            this.x = Math.random() * width;\n            this.y = Math.random() * height;\n            this.size = Math.random() * 2 + 1;\n            this.speedX = (Math.random() * 2 - 1) * 0.5;\n            this.speedY = (Math.random() * 2 - 1) * 0.5;\n        }\n        update() {\n            this.x += this.speedX;\n            this.y += this.speedY;\n            // Interazione con il mouse\n            let dx = this.x - mouse.x;\n            let dy = this.y - mouse.y;\n            let distance = Math.sqrt(dx * dx + dy * dy);\n            if (distance < 100) {\n                this.x += dx / distance * 2;\n                this.y += dy / distance * 2;\n            }\n            // Mantieni le particelle all'interno dei bordi con un margine\n            const margin = 10;\n            if (this.x < margin) {\n                this.x = margin;\n                this.speedX = Math.abs(this.speedX);\n            }\n            if (this.x > width - margin) {\n                this.x = width - margin;\n                this.speedX = -Math.abs(this.speedX);\n            }\n            if (this.y < margin) {\n                this.y = margin;\n                this.speedY = Math.abs(this.speedY);\n            }\n            if (this.y > height - margin) {\n                this.y = height - margin;\n                this.speedY = -Math.abs(this.speedY);\n            }\n        }\n        draw() {\n            if (!ctx) return;\n            ctx.fillStyle = 'rgba(237, 242, 244, 0.8)';\n            ctx.beginPath();\n            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n            ctx.fill();\n        }\n    }\n    let particlesArray = [];\n    function initParticles() {\n        particlesArray = [];\n        const numberOfParticles = 80;\n        for(let i = 0; i < numberOfParticles; i++)particlesArray.push(new Particle());\n    }\n    initParticles();\n    function handleParticles() {\n        for(let i = 0; i < particlesArray.length; i++){\n            particlesArray[i].update();\n            particlesArray[i].draw();\n            for(let j = i; j < particlesArray.length; j++){\n                const dx = particlesArray[i].x - particlesArray[j].x;\n                const dy = particlesArray[i].y - particlesArray[j].y;\n                const distance = Math.sqrt(dx * dx + dy * dy);\n                if (distance < 100) {\n                    if (!ctx) return;\n                    ctx.beginPath();\n                    ctx.strokeStyle = `rgba(248, 112, 96, ${1 - distance / 100})`;\n                    ctx.lineWidth = 0.5;\n                    ctx.moveTo(particlesArray[i].x, particlesArray[i].y);\n                    ctx.lineTo(particlesArray[j].x, particlesArray[j].y);\n                    ctx.stroke();\n                }\n            }\n        }\n    }\n    function animate() {\n        if (!ctx) return;\n        ctx.clearRect(0, 0, width, height);\n        handleParticles();\n        requestAnimationFrame(animate);\n    }\n    animate();\n}\nfunction $48731e7e213a0ef5$var$initPlexusAnimation(canvas) {\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    let points = [];\n    let snake = [];\n    let snakeTarget = 0;\n    const easing = 0.05; // Fattore di easing per un movimento pi fluido\n    const setup = ()=>{\n        canvas.width = canvas.offsetWidth;\n        canvas.height = canvas.offsetHeight;\n        points = [];\n        const pointCount = Math.floor(canvas.width * canvas.height / 9000); // Leggermente meno punti\n        for(let i = 0; i < pointCount; i++)points.push({\n            x: Math.random() * canvas.width,\n            y: Math.random() * canvas.height,\n            vx: (Math.random() - 0.5) * 0.4,\n            vy: (Math.random() - 0.5) * 0.4,\n            impactRadius: 0,\n            impactOpacity: 0\n        });\n        snake = [\n            {\n                x: canvas.width / 2,\n                y: canvas.height / 2\n            }\n        ];\n        for(let i = 1; i < 15; i++)snake.push({\n            x: snake[0].x,\n            y: snake[0].y\n        });\n        findNewTarget();\n    };\n    const findNewTarget = ()=>{\n        let newTarget;\n        do newTarget = Math.floor(Math.random() * points.length);\n        while (newTarget === snakeTarget);\n        snakeTarget = newTarget;\n    };\n    const updateSnake = ()=>{\n        if (points.length === 0 || !points[snakeTarget]) return;\n        const target = points[snakeTarget];\n        const head = snake[0];\n        const dx = target.x - head.x;\n        const dy = target.y - head.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        if (distance < 10) {\n            // \"Colpito\" il target: crea effetto impatto\n            points[snakeTarget].impactRadius = 15;\n            points[snakeTarget].impactOpacity = 1;\n            findNewTarget();\n        } else {\n            // Muovi la testa con easing\n            head.x += dx * easing;\n            head.y += dy * easing;\n        }\n        // La coda segue la testa\n        for(let i = 1; i < snake.length; i++){\n            const leader = snake[i - 1];\n            const segment = snake[i];\n            const segDx = leader.x - segment.x;\n            const segDy = leader.y - segment.y;\n            segment.x += segDx * 0.5; // La coda segue in modo pi \"morbido\"\n            segment.y += segDy * 0.5;\n        }\n    };\n    const draw = ()=>{\n        if (!ctx) return;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        // Disegna e aggiorna i punti e gli impatti\n        points.forEach((p)=>{\n            p.x += p.vx;\n            p.y += p.vy;\n            if (p.x < 0 || p.x > canvas.width) p.vx *= -1;\n            if (p.y < 0 || p.y > canvas.height) p.vy *= -1;\n            ctx.beginPath();\n            ctx.fillStyle = 'rgba(248, 112, 96, 0.8)';\n            ctx.arc(p.x, p.y, 1.5, 0, Math.PI * 2);\n            ctx.fill();\n            // Disegna l'effetto impatto\n            if (p.impactRadius > 0) {\n                ctx.beginPath();\n                ctx.strokeStyle = `rgba(248, 112, 96, ${p.impactOpacity})`;\n                ctx.lineWidth = 2;\n                ctx.arc(p.x, p.y, p.impactRadius, 0, Math.PI * 2);\n                ctx.stroke();\n                p.impactRadius += 0.5; // L'onda si espande\n                p.impactOpacity -= 0.02; // E svanisce\n                if (p.impactOpacity <= 0) {\n                    p.impactRadius = 0;\n                    p.impactOpacity = 0;\n                }\n            }\n        });\n        // Disegna le connessioni tra punti (plexus)\n        for(let i = 0; i < points.length; i++)for(let j = i + 1; j < points.length; j++){\n            const dist = Math.hypot(points[i].x - points[j].x, points[i].y - points[j].y);\n            if (dist < 100) {\n                ctx.beginPath();\n                ctx.moveTo(points[i].x, points[i].y);\n                ctx.lineTo(points[j].x, points[j].y);\n                ctx.lineWidth = (1 - dist / 100) * 0.4;\n                ctx.strokeStyle = 'rgba(248, 112, 96, 0.2)';\n                ctx.stroke();\n            }\n        }\n        updateSnake();\n        // Disegna il proiettile (serpente)\n        for(let i = 0; i < snake.length; i++){\n            const segment = snake[i];\n            const opacity = 1 - i / snake.length * 0.8;\n            const size = 5 - i / snake.length * 4; // La coda si restringe\n            ctx.beginPath();\n            ctx.fillStyle = `rgba(248, 112, 96, ${opacity})`;\n            ctx.arc(segment.x, segment.y, Math.max(1, size), 0, Math.PI * 2);\n            ctx.fill();\n        }\n        // Disegna un alone attorno al punto target\n        if (points[snakeTarget]) {\n            const target = points[snakeTarget];\n            ctx.beginPath();\n            ctx.strokeStyle = 'rgba(248, 112, 96, 0.5)';\n            ctx.lineWidth = 1;\n            ctx.arc(target.x, target.y, 10, 0, Math.PI * 2);\n            ctx.stroke();\n        }\n        requestAnimationFrame(draw);\n    };\n    let animationFrameId = null;\n    const projectsSection = document.getElementById('projects');\n    const plexusObserver = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            if (entry.isIntersecting) {\n                if (!animationFrameId) {\n                    setup();\n                    animationFrameId = requestAnimationFrame(draw);\n                }\n            } else if (animationFrameId) {\n                cancelAnimationFrame(animationFrameId);\n                animationFrameId = null;\n            }\n        });\n    }, {\n        threshold: 0.1\n    });\n    if (projectsSection) plexusObserver.observe(projectsSection);\n    window.addEventListener('resize', setup);\n}\nfunction $48731e7e213a0ef5$var$initTechArt() {\n    const container = document.getElementById('tech-art-container');\n    if (!container) return;\n    const canvas = document.createElement('canvas');\n    container.appendChild(canvas);\n    const ctx = canvas.getContext('2d');\n    let width = container.clientWidth;\n    let height = container.clientHeight;\n    canvas.width = width;\n    canvas.height = height;\n    const particles = [];\n    const particleCount = Math.min(Math.floor(width / 20), 30);\n    const maxDistance = 100;\n    class TechParticle {\n        constructor(){\n            this.x = Math.random() * width;\n            this.y = Math.random() * height;\n            this.size = Math.random() * 2 + 1;\n            this.speedX = (Math.random() - 0.5) * 0.5;\n            this.speedY = (Math.random() - 0.5) * 0.5;\n        }\n        update() {\n            this.x += this.speedX;\n            this.y += this.speedY;\n            // Mantieni le particelle all'interno dei bordi con un margine\n            const margin = 5;\n            if (this.x < margin) {\n                this.x = margin;\n                this.speedX = Math.abs(this.speedX);\n            }\n            if (this.x > width - margin) {\n                this.x = width - margin;\n                this.speedX = -Math.abs(this.speedX);\n            }\n            if (this.y < margin) {\n                this.y = margin;\n                this.speedY = Math.abs(this.speedY);\n            }\n            if (this.y > height - margin) {\n                this.y = height - margin;\n                this.speedY = -Math.abs(this.speedY);\n            }\n        }\n        draw() {\n            if (!ctx) return;\n            ctx.fillStyle = '#F87060';\n            ctx.beginPath();\n            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n            ctx.fill();\n        }\n    }\n    function initParticles() {\n        particles.length = 0;\n        for(let i = 0; i < particleCount; i++)particles.push(new TechParticle());\n    }\n    function handleParticles() {\n        if (!ctx) return;\n        for(let i = 0; i < particles.length; i++){\n            particles[i].update();\n            particles[i].draw();\n            for(let j = i + 1; j < particles.length; j++){\n                const dx = particles[i].x - particles[j].x;\n                const dy = particles[i].y - particles[j].y;\n                const distance = Math.sqrt(dx * dx + dy * dy);\n                if (distance < maxDistance) {\n                    ctx.beginPath();\n                    ctx.strokeStyle = `rgba(248, 112, 96, ${1 - distance / maxDistance})`;\n                    ctx.lineWidth = 0.5;\n                    ctx.moveTo(particles[i].x, particles[i].y);\n                    ctx.lineTo(particles[j].x, particles[j].y);\n                    ctx.stroke();\n                }\n            }\n        }\n    }\n    function animate() {\n        if (!ctx) return;\n        ctx.clearRect(0, 0, width, height);\n        handleParticles();\n        requestAnimationFrame(animate);\n    }\n    window.addEventListener('resize', ()=>{\n        width = container.clientWidth;\n        height = container.clientHeight;\n        canvas.width = width;\n        canvas.height = height;\n        initParticles();\n    });\n    initParticles();\n    animate();\n}\nfunction $48731e7e213a0ef5$var$initSubtleBackground() {\n    const canvas = document.getElementById('matrix-canvas');\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    let width = canvas.width = window.innerWidth;\n    let height = canvas.height = window.innerHeight;\n    const dots = [];\n    const dotCount = Math.floor(width * height / 15000); // Densit molto bassa\n    // Inizializza i punti fluttuanti\n    for(let i = 0; i < dotCount; i++)dots.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        size: Math.random() * 2 + 1,\n        speedX: (Math.random() - 0.5) * 0.2,\n        speedY: (Math.random() - 0.5) * 0.2,\n        opacity: Math.random() * 0.3 + 0.1,\n        pulseSpeed: Math.random() * 0.02 + 0.01,\n        pulsePhase: Math.random() * Math.PI * 2\n    });\n    function draw() {\n        if (!ctx) return;\n        ctx.clearRect(0, 0, width, height);\n        dots.forEach((dot)=>{\n            // Aggiorna posizione\n            dot.x += dot.speedX;\n            dot.y += dot.speedY;\n            // Rimbalzo sui bordi\n            if (dot.x < 0 || dot.x > width) dot.speedX *= -1;\n            if (dot.y < 0 || dot.y > height) dot.speedY *= -1;\n            // Effetto pulsazione\n            dot.pulsePhase += dot.pulseSpeed;\n            const pulseOpacity = dot.opacity * (0.5 + 0.5 * Math.sin(dot.pulsePhase));\n            // Disegna il punto con gradiente\n            const gradient = ctx.createRadialGradient(dot.x, dot.y, 0, dot.x, dot.y, dot.size * 3);\n            gradient.addColorStop(0, `rgba(248, 112, 96, ${pulseOpacity})`);\n            gradient.addColorStop(1, 'rgba(248, 112, 96, 0)');\n            ctx.fillStyle = gradient;\n            ctx.beginPath();\n            ctx.arc(dot.x, dot.y, dot.size * 3, 0, Math.PI * 2);\n            ctx.fill();\n        });\n        // Disegna connessioni sottili tra punti vicini\n        ctx.strokeStyle = 'rgba(248, 112, 96, 0.1)';\n        ctx.lineWidth = 0.5;\n        for(let i = 0; i < dots.length; i++)for(let j = i + 1; j < dots.length; j++){\n            const dx = dots[i].x - dots[j].x;\n            const dy = dots[i].y - dots[j].y;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            if (distance < 150) {\n                const opacity = (1 - distance / 150) * 0.1;\n                ctx.strokeStyle = `rgba(248, 112, 96, ${opacity})`;\n                ctx.beginPath();\n                ctx.moveTo(dots[i].x, dots[i].y);\n                ctx.lineTo(dots[j].x, dots[j].y);\n                ctx.stroke();\n            }\n        }\n        requestAnimationFrame(draw);\n    }\n    window.addEventListener('resize', ()=>{\n        width = canvas.width = window.innerWidth;\n        height = canvas.height = window.innerHeight;\n        // Ricalcola il numero di punti in base alla nuova dimensione\n        const newDotCount = Math.floor(width * height / 15000);\n        while(dots.length > newDotCount)dots.pop();\n        while(dots.length < newDotCount)dots.push({\n            x: Math.random() * width,\n            y: Math.random() * height,\n            size: Math.random() * 2 + 1,\n            speedX: (Math.random() - 0.5) * 0.2,\n            speedY: (Math.random() - 0.5) * 0.2,\n            opacity: Math.random() * 0.3 + 0.1,\n            pulseSpeed: Math.random() * 0.02 + 0.01,\n            pulsePhase: Math.random() * Math.PI * 2\n        });\n    });\n    draw();\n}\nfunction $48731e7e213a0ef5$var$initTypingAnimation() {\n    const nameSpan = document.querySelector('.hero-text h1 .highlight');\n    if (nameSpan?.textContent) {\n        const textToType = nameSpan.textContent;\n        nameSpan.textContent = '';\n        setTimeout(()=>{\n            if (nameSpan) $48731e7e213a0ef5$var$typeWriter(nameSpan, textToType, 100);\n        }, 1000);\n    }\n}\nfunction $48731e7e213a0ef5$var$initHamburgerMenu() {\n    const hamburger = document.querySelector('.hamburger');\n    const navMenu = document.querySelector('.nav-menu');\n    const navLinks = document.querySelectorAll('.nav-link');\n    hamburger?.addEventListener('click', ()=>{\n        hamburger.classList.toggle('active');\n        navMenu?.classList.toggle('active');\n    });\n    // Close mobile menu when clicking on a link\n    navLinks.forEach((link)=>{\n        link.addEventListener('click', ()=>{\n            hamburger?.classList.remove('active');\n            navMenu?.classList.remove('active');\n        });\n    });\n}\nfunction $48731e7e213a0ef5$var$initNavbarActiveLink() {\n    const currentPage = window.location.pathname.split('/').pop() || 'index.html';\n    const navLinks = document.querySelectorAll('.nav-menu a');\n    navLinks.forEach((link)=>{\n        const linkPage = link.getAttribute('href');\n        if (linkPage === currentPage) link.classList.add('active');\n    });\n}\nfunction $48731e7e213a0ef5$var$initNavbarScroll() {\n    const navbar = document.querySelector('.navbar');\n    window.addEventListener('scroll', ()=>{\n        if (window.scrollY > 100) navbar?.classList.add('scrolled');\n        else navbar?.classList.remove('scrolled');\n    });\n}\nfunction $48731e7e213a0ef5$var$initScrollToTop() {\n    const backToTopBtn = document.getElementById('scrollToTopBtn');\n    if (!backToTopBtn) return;\n    window.addEventListener('scroll', ()=>{\n        if (window.scrollY > 300) backToTopBtn.classList.add('visible');\n        else backToTopBtn.classList.remove('visible');\n    });\n    backToTopBtn.addEventListener('click', (e)=>{\n        e.preventDefault();\n        window.scrollTo({\n            top: 0,\n            behavior: 'smooth'\n        });\n    });\n}\nfunction $48731e7e213a0ef5$var$initTooltips() {\n    const tooltipItems = document.querySelectorAll('[data-tooltip]');\n    const tooltip = document.getElementById('tooltip');\n    if (tooltip && tooltipItems.length > 0) tooltipItems.forEach((item)=>{\n        const reference = item;\n        const tooltipText = reference.dataset.tooltip || '';\n        const showTooltip = ()=>{\n            tooltip.textContent = tooltipText;\n            tooltip.classList.add('visible');\n            (0, $461947879dcdbcd4$export$48a53dcb22e581d0)(reference, tooltip, {\n                placement: 'top',\n                middleware: [\n                    (0, $461947879dcdbcd4$export$cc800923e997bb8)(8),\n                    (0, $461947879dcdbcd4$export$8a83211c878a3f1f)(),\n                    (0, $461947879dcdbcd4$export$fba63a578e423eb)({\n                        padding: 5\n                    })\n                ]\n            }).then(({ x: x, y: y })=>{\n                Object.assign(tooltip.style, {\n                    left: `${x}px`,\n                    top: `${y}px`\n                });\n            });\n        };\n        const hideTooltip = ()=>{\n            tooltip.classList.remove('visible');\n        };\n        reference.addEventListener('mouseenter', showTooltip);\n        reference.addEventListener('mouseleave', hideTooltip);\n        reference.addEventListener('focus', showTooltip);\n        reference.addEventListener('blur', hideTooltip);\n    });\n}\nfunction $48731e7e213a0ef5$var$initKeyboardAnimation() {\n// La logica per l'animazione della tastiera va qui se necessaria\n}\nfunction $48731e7e213a0ef5$var$initStatsCounters() {\n    const observer = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            if (entry.isIntersecting) {\n                if (entry.target.matches('.stats')) {\n                    const statNumbers = entry.target.querySelectorAll('.stat h4');\n                    statNumbers.forEach((stat)=>{\n                        const target = parseInt(stat.dataset.target || '0', 10);\n                        const suffix = stat.dataset.suffix || '';\n                        $48731e7e213a0ef5$var$animateCounter(stat, target, 2000, suffix);\n                    });\n                    observer.unobserve(entry.target);\n                }\n            }\n        });\n    }, {\n        threshold: 0.1\n    });\n    const statsEl = document.querySelector('.stats');\n    if (statsEl) observer.observe(statsEl);\n}\nfunction $48731e7e213a0ef5$var$initTimelineAnimation() {\n    const timelineItems = document.querySelectorAll('.timeline-item');\n    const timelineObserver = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            if (entry.isIntersecting) entry.target.classList.add('animate');\n        });\n    }, {\n        threshold: 0.1\n    });\n    timelineItems.forEach((item)=>{\n        timelineObserver.observe(item);\n    });\n}\nfunction $48731e7e213a0ef5$var$initAboutBackground() {\n    const aboutSection = document.querySelector('.about');\n    if (!aboutSection) return;\n    // Crea il canvas per le forme geometriche animate\n    const canvas = document.createElement('canvas');\n    canvas.style.position = 'absolute';\n    canvas.style.top = '0';\n    canvas.style.left = '0';\n    canvas.style.width = '100%';\n    canvas.style.height = '100%';\n    canvas.style.zIndex = '1';\n    canvas.style.pointerEvents = 'none';\n    canvas.style.opacity = '0.6';\n    aboutSection.appendChild(canvas);\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    let width = aboutSection.offsetWidth;\n    let height = aboutSection.offsetHeight;\n    canvas.width = width;\n    canvas.height = height;\n    const shapes = [];\n    const shapeCount = 8;\n    // Inizializza le forme\n    for(let i = 0; i < shapeCount; i++)shapes.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        size: Math.random() * 40 + 20,\n        speedX: (Math.random() - 0.5) * 0.3,\n        speedY: (Math.random() - 0.5) * 0.3,\n        rotation: Math.random() * Math.PI * 2,\n        rotationSpeed: (Math.random() - 0.5) * 0.01,\n        type: [\n            'circle',\n            'triangle',\n            'square'\n        ][Math.floor(Math.random() * 3)],\n        opacity: Math.random() * 0.3 + 0.1\n    });\n    function drawShape(shape) {\n        if (!ctx) return;\n        ctx.save();\n        ctx.translate(shape.x, shape.y);\n        ctx.rotate(shape.rotation);\n        ctx.globalAlpha = shape.opacity;\n        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, shape.size);\n        gradient.addColorStop(0, 'rgba(248, 112, 96, 0.3)');\n        gradient.addColorStop(1, 'rgba(248, 112, 96, 0)');\n        ctx.fillStyle = gradient;\n        ctx.strokeStyle = 'rgba(248, 112, 96, 0.2)';\n        ctx.lineWidth = 1;\n        switch(shape.type){\n            case 'circle':\n                ctx.beginPath();\n                ctx.arc(0, 0, shape.size / 2, 0, Math.PI * 2);\n                ctx.fill();\n                ctx.stroke();\n                break;\n            case 'triangle':\n                ctx.beginPath();\n                ctx.moveTo(0, -shape.size / 2);\n                ctx.lineTo(-shape.size / 2, shape.size / 2);\n                ctx.lineTo(shape.size / 2, shape.size / 2);\n                ctx.closePath();\n                ctx.fill();\n                ctx.stroke();\n                break;\n            case 'square':\n                ctx.fillRect(-shape.size / 2, -shape.size / 2, shape.size, shape.size);\n                ctx.strokeRect(-shape.size / 2, -shape.size / 2, shape.size, shape.size);\n                break;\n        }\n        ctx.restore();\n    }\n    function updateShapes() {\n        shapes.forEach((shape)=>{\n            shape.x += shape.speedX;\n            shape.y += shape.speedY;\n            shape.rotation += shape.rotationSpeed;\n            // Rimbalzo sui bordi\n            if (shape.x < -shape.size || shape.x > width + shape.size) shape.speedX *= -1;\n            if (shape.y < -shape.size || shape.y > height + shape.size) shape.speedY *= -1;\n            // Mantieni le forme all'interno dell'area\n            shape.x = Math.max(-shape.size / 2, Math.min(width + shape.size / 2, shape.x));\n            shape.y = Math.max(-shape.size / 2, Math.min(height + shape.size / 2, shape.y));\n        });\n    }\n    function animate() {\n        if (!ctx) return;\n        ctx.clearRect(0, 0, width, height);\n        updateShapes();\n        shapes.forEach(drawShape);\n        requestAnimationFrame(animate);\n    }\n    // Gestisci il ridimensionamento\n    const resizeObserver = new ResizeObserver(()=>{\n        width = aboutSection.offsetWidth;\n        height = aboutSection.offsetHeight;\n        canvas.width = width;\n        canvas.height = height;\n    });\n    resizeObserver.observe(aboutSection);\n    // Avvia l'animazione solo quando la sezione  visibile\n    const intersectionObserver = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            if (entry.isIntersecting) animate();\n        });\n    }, {\n        threshold: 0.1\n    });\n    intersectionObserver.observe(aboutSection);\n}\nfunction $48731e7e213a0ef5$var$initParallaxEffect() {\n    const parallaxElements = document.querySelectorAll('.profile-photo-container, .timeline-container');\n    if (parallaxElements.length === 0) return;\n    const handleScroll = ()=>{\n        const scrollY = window.scrollY;\n        parallaxElements.forEach((el)=>{\n            const element = el;\n            const speed = parseFloat(element.dataset.parallaxSpeed || '0.1');\n            const offset = scrollY * speed;\n            element.style.transform = `translateY(${offset}px)`;\n        });\n    };\n    window.addEventListener('scroll', handleScroll, {\n        passive: true\n    });\n}\n/**\n * Initializes a neural network animation on a canvas.\n */ function $48731e7e213a0ef5$var$initNeuralNetworkBackground() {\n    console.log('initNeuralNetworkBackground called');\n    const canvas = document.getElementById('neural-network-canvas');\n    if (!canvas) {\n        console.error('Neural network canvas not found!');\n        return;\n    }\n    console.log('Neural network canvas found, starting animation...');\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n        console.error('Could not get 2D context for neural network canvas!');\n        return;\n    }\n    const mouse = {\n        x: 0,\n        y: 0\n    };\n    window.addEventListener('mousemove', (e)=>{\n        mouse.x = e.clientX;\n        mouse.y = e.clientY;\n    });\n    let nodes;\n    let particles;\n    let impulses;\n    let time = 0;\n    const resizeCanvas = ()=>{\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        nodes = [];\n        const nodeCount = window.innerWidth < 768 ? 60 : 120;\n        for(let i = 0; i < nodeCount; i++)nodes.push({\n            x: Math.random() * canvas.width,\n            y: Math.random() * canvas.height,\n            vx: (Math.random() - 0.5) * 0.4,\n            vy: (Math.random() - 0.5) * 0.4,\n            baseRadius: Math.random() * 2.5 + 0.8,\n            pulseAngle: Math.random() * Math.PI,\n            color: Math.random() > 0.5 ? '#FF6B6B' : '#4ECDC4',\n            energy: Math.random(),\n            layer: Math.floor(Math.random() * 3),\n            processing: Math.random() > 0.6,\n            connections: [],\n            lastImpulse: 0,\n            glowIntensity: Math.random() * 0.5 + 0.5\n        });\n        // Create connections between nodes\n        nodes.forEach((node, i)=>{\n            nodes.forEach((otherNode, j)=>{\n                if (i !== j) {\n                    const dist = Math.sqrt(Math.pow(node.x - otherNode.x, 2) + Math.pow(node.y - otherNode.y, 2));\n                    if (dist < 140 && Math.random() > 0.6) node.connections.push(j);\n                }\n            });\n        });\n        particles = [];\n        const particleCount = 40;\n        for(let i = 0; i < particleCount; i++)particles.push({\n            x: Math.random() * canvas.width,\n            y: Math.random() * canvas.height,\n            vx: (Math.random() - 0.5) * 2,\n            vy: (Math.random() - 0.5) * 2,\n            life: Math.random(),\n            maxLife: Math.random() * 1 + 0.5,\n            size: Math.random() * 2 + 0.8,\n            targetNode: Math.floor(Math.random() * nodes.length),\n            color: Math.random() > 0.5 ? '#FFE66D' : '#FF6B9D'\n        });\n        impulses = [];\n    };\n    const draw = ()=>{\n        if (!ctx) return;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        time += 0.015;\n        // Draw enhanced background noise with depth\n        for(let i = 0; i < 30; i++){\n            const x = Math.random() * canvas.width;\n            const y = Math.random() * canvas.height;\n            const size = Math.random() * 1.5;\n            const alpha = Math.random() * 0.15;\n            ctx.beginPath();\n            ctx.arc(x, y, size, 0, Math.PI * 2);\n            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;\n            ctx.fill();\n        }\n        // Draw particles with enhanced movement\n        particles.forEach((particle)=>{\n            const targetNode = nodes[particle.targetNode];\n            const dx = targetNode.x - particle.x;\n            const dy = targetNode.y - particle.y;\n            const dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist > 5) {\n                particle.vx += dx * 0.002;\n                particle.vy += dy * 0.002;\n            }\n            particle.x += particle.vx;\n            particle.y += particle.vy;\n            particle.life += 0.015;\n            if (particle.life > particle.maxLife || dist < 5) {\n                particle.life = 0;\n                particle.x = Math.random() * canvas.width;\n                particle.y = Math.random() * canvas.height;\n                particle.targetNode = Math.floor(Math.random() * nodes.length);\n            }\n            const alpha = (1 - particle.life / particle.maxLife) * 0.6;\n            ctx.beginPath();\n            ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);\n            const particleOpacityHex = Math.floor(alpha * 255).toString(16).length === 1 ? '0' + Math.floor(alpha * 255).toString(16) : Math.floor(alpha * 255).toString(16);\n            ctx.fillStyle = `${particle.color}${particleOpacityHex}`;\n            ctx.fill();\n        });\n        // Draw nodes in layers with enhanced effects\n        for(let layer = 0; layer < 3; layer++)nodes.filter((node)=>node.layer === layer).forEach((node)=>{\n            node.x += node.vx;\n            node.y += node.vy;\n            node.energy += 0.015;\n            if (node.x < 0 || node.x > canvas.width) node.vx *= -1;\n            if (node.y < 0 || node.y > canvas.height) node.vy *= -1;\n            node.pulseAngle += 0.02;\n            const pulseFactor = (Math.sin(node.pulseAngle) + 1) / 2;\n            const currentRadius = node.baseRadius + pulseFactor * 1.5;\n            // Calculate distance to mouse for enhanced interaction\n            const distToMouse = Math.sqrt(Math.pow(node.x - mouse.x, 2) + Math.pow(node.y - mouse.y, 2));\n            const mouseInfluence = Math.max(0, 1 - distToMouse / 150);\n            // Processing effect with enhanced visuals\n            if (node.processing && Math.random() < 0.15) impulses.push({\n                x: node.x,\n                y: node.y,\n                life: 0,\n                maxLife: 1.5,\n                connections: [\n                    ...node.connections\n                ],\n                visited: new Set(),\n                color: node.color\n            });\n            // Enhanced glow effect with multiple layers\n            const glowRadius = currentRadius + mouseInfluence * 15 + (3 - layer) * 3;\n            const gradient = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, glowRadius);\n            const opacity = (0.4 - layer * 0.1) * node.glowIntensity;\n            const opacityHex1 = Math.floor(opacity * 255).toString(16).length === 1 ? '0' + Math.floor(opacity * 255).toString(16) : Math.floor(opacity * 255).toString(16);\n            const opacityHex2 = Math.floor(opacity * 76.5).toString(16).length === 1 ? '0' + Math.floor(opacity * 76.5).toString(16) : Math.floor(opacity * 76.5).toString(16);\n            gradient.addColorStop(0, `${node.color}${opacityHex1}`);\n            gradient.addColorStop(0.4, `${node.color}${opacityHex2}`);\n            gradient.addColorStop(1, 'transparent');\n            ctx.beginPath();\n            ctx.arc(node.x, node.y, glowRadius, 0, Math.PI * 2);\n            ctx.fillStyle = gradient;\n            ctx.fill();\n            // Main node with enhanced shading\n            ctx.beginPath();\n            ctx.arc(node.x, node.y, currentRadius, 0, Math.PI * 2);\n            const nodeOpacity = Math.floor((0.7 + pulseFactor * 0.3 + mouseInfluence * 0.3) * 255);\n            const nodeOpacityHex = nodeOpacity.toString(16).length === 1 ? '0' + nodeOpacity.toString(16) : nodeOpacity.toString(16);\n            ctx.fillStyle = `${node.color}${nodeOpacityHex}`;\n            ctx.fill();\n            // Enhanced inner highlight\n            ctx.beginPath();\n            ctx.arc(node.x - currentRadius * 0.25, node.y - currentRadius * 0.25, currentRadius * 0.4, 0, Math.PI * 2);\n            ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + pulseFactor * 0.2})`;\n            ctx.fill();\n            // Enhanced processing indicator\n            if (node.processing) {\n                ctx.beginPath();\n                ctx.arc(node.x, node.y, currentRadius + 4, 0, Math.PI * 2);\n                ctx.strokeStyle = `rgba(255, 215, 0, ${pulseFactor * 0.8})`;\n                ctx.lineWidth = 2;\n                ctx.stroke();\n            }\n        });\n        // Draw enhanced impulses\n        impulses.forEach((impulse, index)=>{\n            impulse.life += 0.025;\n            if (impulse.life > impulse.maxLife) {\n                impulses.splice(index, 1);\n                return;\n            }\n            const alpha = (1 - impulse.life / impulse.maxLife) * 0.9;\n            const radius = impulse.life * 25;\n            // Impulse glow\n            const impulseOpacityHex1 = Math.floor(alpha * 255).toString(16).length === 1 ? '0' + Math.floor(alpha * 255).toString(16) : Math.floor(alpha * 255).toString(16);\n            const impulseOpacityHex2 = Math.floor(alpha * 127.5).toString(16).length === 1 ? '0' + Math.floor(alpha * 127.5).toString(16) : Math.floor(alpha * 127.5).toString(16);\n            const gradient = ctx.createRadialGradient(impulse.x, impulse.y, 0, impulse.x, impulse.y, radius);\n            gradient.addColorStop(0, `${impulse.color}${impulseOpacityHex1}`);\n            gradient.addColorStop(0.5, `${impulse.color}${impulseOpacityHex2}`);\n            gradient.addColorStop(1, 'transparent');\n            ctx.beginPath();\n            ctx.arc(impulse.x, impulse.y, radius, 0, Math.PI * 2);\n            ctx.fillStyle = gradient;\n            ctx.fill();\n        });\n        // Draw connections with enhanced energy flow\n        nodes.forEach((node, i)=>{\n            node.connections.forEach((connectionIndex)=>{\n                const connectedNode = nodes[connectionIndex];\n                const dist = Math.sqrt(Math.pow(node.x - connectedNode.x, 2) + Math.pow(node.y - connectedNode.y, 2));\n                if (dist < 180) {\n                    const distToMouse = Math.min(Math.sqrt(Math.pow(node.x - mouse.x, 2) + Math.pow(node.y - mouse.y, 2)), Math.sqrt(Math.pow(connectedNode.x - mouse.x, 2) + Math.pow(connectedNode.y - mouse.y, 2)));\n                    let opacity = (1 - dist / 180) * 0.5;\n                    if (distToMouse < 100) opacity = Math.min(1, opacity + (1 - distToMouse / 100) * 0.8);\n                    // Enhanced energy flow effect\n                    const energyFlow = Math.sin(time * 4 + i + connectionIndex) * 0.5 + 0.5;\n                    opacity *= 0.4 + energyFlow * 0.8;\n                    // Enhanced gradient line\n                    const connectionOpacityHex1 = Math.floor(opacity * 255).toString(16).length === 1 ? '0' + Math.floor(opacity * 255).toString(16) : Math.floor(opacity * 255).toString(16);\n                    const connectionOpacityHex2 = Math.floor(opacity * 255).toString(16).length === 1 ? '0' + Math.floor(opacity * 255).toString(16) : Math.floor(opacity * 255).toString(16);\n                    const gradient = ctx.createLinearGradient(node.x, node.y, connectedNode.x, connectedNode.y);\n                    gradient.addColorStop(0, `${node.color}${connectionOpacityHex1}`);\n                    gradient.addColorStop(0.3, `rgba(255, 255, 255, ${opacity * 0.8})`);\n                    gradient.addColorStop(0.7, `rgba(255, 255, 255, ${opacity * 0.8})`);\n                    gradient.addColorStop(1, `${connectedNode.color}${connectionOpacityHex2}`);\n                    ctx.beginPath();\n                    ctx.moveTo(node.x, node.y);\n                    ctx.lineTo(connectedNode.x, connectedNode.y);\n                    ctx.strokeStyle = gradient;\n                    ctx.lineWidth = 1 + energyFlow * 2.5;\n                    ctx.stroke();\n                    // Enhanced energy particles\n                    if (Math.random() < 0.08) {\n                        const t = Math.random();\n                        const x = node.x + (connectedNode.x - node.x) * t;\n                        const y = node.y + (connectedNode.y - node.y) * t;\n                        ctx.beginPath();\n                        ctx.arc(x, y, 0.8, 0, Math.PI * 2);\n                        ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;\n                        ctx.fill();\n                    }\n                }\n            });\n        });\n    };\n    const animate = ()=>{\n        draw();\n        requestAnimationFrame(animate);\n    };\n    window.addEventListener('resize', resizeCanvas);\n    resizeCanvas();\n    animate();\n}\n/**\n * Initializes a data flow animation on a canvas.\n */ function $48731e7e213a0ef5$var$initDataFlowBackground() {\n    console.log('initDataFlowBackground called');\n    const canvas = document.getElementById('data-flow-canvas');\n    if (!canvas) {\n        console.error('Data flow canvas not found!');\n        return;\n    }\n    console.log('Data flow canvas found, starting animation...');\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n        console.error('Could not get 2D context for data flow canvas!');\n        return;\n    }\n    const mouse = {\n        x: 0,\n        y: 0\n    };\n    window.addEventListener('mousemove', (e)=>{\n        mouse.x = e.clientX;\n        mouse.y = e.clientY;\n    });\n    let particles;\n    let time = 0;\n    let buffer;\n    // Enhanced data characters\n    const dataChars = [\n        '01',\n        '10',\n        '11',\n        '00',\n        'FF',\n        'AA',\n        '55',\n        'CC',\n        'AI',\n        'ML',\n        'DL',\n        'NN',\n        'CV',\n        'NLP',\n        'RL',\n        'GAN',\n        '0x1A',\n        '0x2B',\n        '0x3C',\n        '0x4D',\n        '0x5E',\n        '0x6F',\n        'GET',\n        'POST',\n        'PUT',\n        'DEL',\n        'HTTP',\n        'JSON',\n        'XML',\n        'SQL',\n        'API',\n        'REST',\n        'WS',\n        'TCP',\n        'UDP',\n        'SSL',\n        'GPU',\n        'CPU',\n        'RAM',\n        'SSD',\n        'NVMe',\n        'PCIe'\n    ];\n    const resizeCanvas = ()=>{\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        particles = [];\n        const particleCount = 600;\n        for(let i = 0; i < particleCount; i++){\n            const isSymbol = Math.random() < 0.45;\n            particles.push({\n                x: Math.random() * canvas.width,\n                y: Math.random() * canvas.height,\n                speed: Math.random() * 2 + 0.5,\n                size: Math.random() * 2 + 1,\n                length: Math.random() * 30 + 20,\n                opacity: Math.random() * 0.8 + 0.2,\n                type: isSymbol ? 'symbol' : 'line',\n                symbol: dataChars[Math.floor(Math.random() * dataChars.length)],\n                color: Math.random() > 0.5 ? '#FF6B6B' : '#4ECDC4',\n                pulse: Math.random() * Math.PI,\n                waveOffset: Math.random() * Math.PI * 2,\n                corruption: Math.random() > 0.97,\n                bufferDelay: Math.random() * 100,\n                originalSymbol: '',\n                glowIntensity: Math.random() * 0.5 + 0.5\n            });\n        }\n        // Initialize enhanced buffer\n        buffer = [];\n        for(let i = 0; i < 30; i++)buffer.push({\n            x: Math.random() * canvas.width,\n            y: canvas.height + Math.random() * 80,\n            symbol: dataChars[Math.floor(Math.random() * dataChars.length)],\n            delay: Math.random() * 300,\n            color: Math.random() > 0.5 ? '#FF6B6B' : '#4ECDC4'\n        });\n    };\n    const draw = ()=>{\n        if (!ctx) return;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        time += 0.02;\n        // Draw enhanced buffer effects\n        buffer.forEach((buff)=>{\n            buff.delay--;\n            if (buff.delay <= 0) {\n                buff.y -= 0.8;\n                ctx.font = '14px monospace';\n                ctx.fillStyle = `${buff.color}50`;\n                ctx.textAlign = 'center';\n                ctx.fillText(buff.symbol, buff.x, buff.y);\n            }\n        });\n        particles.forEach((p)=>{\n            p.y -= p.speed;\n            p.pulse += 0.04;\n            // Enhanced wave effect with physics\n            const wave = Math.sin(time + p.waveOffset) * 2;\n            p.x += wave * 0.08;\n            // Add enhanced randomness for realism\n            p.x += (Math.random() - 0.5) * 0.3;\n            if (p.y < -p.length) {\n                p.y = canvas.height + p.length;\n                p.x = Math.random() * canvas.width;\n                p.corruption = Math.random() > 0.97;\n                p.originalSymbol = p.symbol;\n                if (p.corruption) p.symbol = 'ERR';\n            }\n            // Enhanced mouse interaction with realistic physics\n            const distToMouse = Math.sqrt(Math.pow(p.x - mouse.x, 2) + Math.pow(p.y - mouse.y, 2));\n            const mouseInfluence = Math.max(0, 1 - distToMouse / 100);\n            // Enhanced opacity with realistic falloff\n            const enhancedOpacity = p.opacity + mouseInfluence * 0.6;\n            const pulseFactor = (Math.sin(p.pulse) + 1) / 2;\n            const finalOpacity = enhancedOpacity * (0.7 + pulseFactor * 0.4) * p.glowIntensity;\n            if (p.type === 'line') {\n                // Draw enhanced line with sophisticated gradient\n                const lineOpacityHex = Math.floor(finalOpacity * 255).toString(16).length === 1 ? '0' + Math.floor(finalOpacity * 255).toString(16) : Math.floor(finalOpacity * 255).toString(16);\n                const gradient = ctx.createLinearGradient(p.x, p.y, p.x, p.y - p.length);\n                gradient.addColorStop(0, `${p.color}${lineOpacityHex}`);\n                gradient.addColorStop(0.2, `rgba(255, 255, 255, ${finalOpacity * 0.9})`);\n                gradient.addColorStop(0.5, `rgba(255, 255, 255, ${finalOpacity})`);\n                gradient.addColorStop(0.8, `rgba(255, 255, 255, ${finalOpacity * 0.9})`);\n                gradient.addColorStop(1, `${p.color}${lineOpacityHex}`);\n                ctx.beginPath();\n                ctx.moveTo(p.x, p.y);\n                ctx.lineTo(p.x, p.y - p.length);\n                ctx.strokeStyle = gradient;\n                ctx.lineWidth = p.size + mouseInfluence * 2.5;\n                ctx.stroke();\n                // Enhanced glow effect\n                if (mouseInfluence > 0.2) {\n                    ctx.beginPath();\n                    ctx.moveTo(p.x, p.y);\n                    ctx.lineTo(p.x, p.y - p.length);\n                    ctx.strokeStyle = `rgba(255, 255, 255, ${mouseInfluence * 0.6})`;\n                    ctx.lineWidth = p.size + mouseInfluence * 4;\n                    ctx.stroke();\n                }\n            } else {\n                // Draw symbol with enhanced font\n                ctx.font = `${p.size * 3}px 'Courier New', monospace`;\n                const symbolOpacityHex = Math.floor(finalOpacity * 255).toString(16).length === 1 ? '0' + Math.floor(finalOpacity * 255).toString(16) : Math.floor(finalOpacity * 255).toString(16);\n                // Enhanced corruption effect\n                if (p.corruption) ctx.fillStyle = `rgba(255, 0, 0, ${finalOpacity})`;\n                else ctx.fillStyle = `${p.color}${symbolOpacityHex}`;\n                ctx.textAlign = 'center';\n                ctx.fillText(p.symbol, p.x, p.y);\n                // Enhanced glow for symbols\n                if (mouseInfluence > 0.3) {\n                    ctx.font = `${p.size * 3}px 'Courier New', monospace`;\n                    ctx.fillStyle = `rgba(255, 255, 255, ${mouseInfluence * 0.8})`;\n                    ctx.fillText(p.symbol, p.x, p.y);\n                }\n            }\n            // Enhanced speed variation\n            if (mouseInfluence > 0.4) p.speed = Math.min(p.speed * 1.08, 4);\n            else p.speed = Math.max(p.speed * 0.998, 0.3);\n        });\n        // Enhanced data corruption and repair effects\n        if (Math.random() < 0.03) {\n            const corruptX = Math.random() * canvas.width;\n            const corruptY = Math.random() * canvas.height;\n            // Corruption glow\n            const gradient = ctx.createRadialGradient(corruptX, corruptY, 0, corruptX, corruptY, 8);\n            gradient.addColorStop(0, 'rgba(255, 0, 0, 0.8)');\n            gradient.addColorStop(0.5, 'rgba(255, 0, 0, 0.4)');\n            gradient.addColorStop(1, 'transparent');\n            ctx.beginPath();\n            ctx.arc(corruptX, corruptY, 8, 0, Math.PI * 2);\n            ctx.fillStyle = gradient;\n            ctx.fill();\n            ctx.font = '12px monospace';\n            ctx.fillStyle = 'rgba(255, 0, 0, 0.9)';\n            ctx.textAlign = 'center';\n            ctx.fillText('ERR', corruptX, corruptY + 18);\n        }\n        // Enhanced data packets\n        if (Math.random() < 0.015) {\n            const packetX = Math.random() * canvas.width;\n            const packetY = canvas.height;\n            // Packet glow\n            const gradient = ctx.createRadialGradient(packetX, packetY, 0, packetX, packetY, 6);\n            gradient.addColorStop(0, 'rgba(0, 255, 0, 0.9)');\n            gradient.addColorStop(0.5, 'rgba(0, 255, 0, 0.5)');\n            gradient.addColorStop(1, 'transparent');\n            ctx.beginPath();\n            ctx.arc(packetX, packetY, 6, 0, Math.PI * 2);\n            ctx.fillStyle = gradient;\n            ctx.fill();\n            ctx.font = '10px monospace';\n            ctx.fillStyle = 'rgba(0, 255, 0, 0.9)';\n            ctx.textAlign = 'center';\n            ctx.fillText('PKT', packetX, packetY + 12);\n        }\n        // Add occasional data streams\n        if (Math.random() < 0.01) {\n            const streamX = Math.random() * canvas.width;\n            for(let i = 0; i < 10; i++){\n                ctx.beginPath();\n                ctx.arc(streamX + (Math.random() - 0.5) * 20, canvas.height - i * 10, 1, 0, Math.PI * 2);\n                ctx.fillStyle = `rgba(255, 255, 255, ${0.8 - i * 0.08})`;\n                ctx.fill();\n            }\n        }\n    };\n    const animate = ()=>{\n        draw();\n        requestAnimationFrame(animate);\n    };\n    window.addEventListener('resize', resizeCanvas);\n    resizeCanvas();\n    animate();\n}\n/**\n * Initializes a projects development animation on a canvas.\n */ function $48731e7e213a0ef5$var$initProjectsBackground() {\n    console.log('initProjectsBackground called');\n    const canvas = document.getElementById('projects-canvas');\n    if (!canvas) {\n        console.error('Projects canvas not found!');\n        return;\n    }\n    console.log('Projects canvas found, starting animation...');\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n        console.error('Could not get 2D context for projects canvas!');\n        return;\n    }\n    const mouse = {\n        x: 0,\n        y: 0\n    };\n    window.addEventListener('mousemove', (e)=>{\n        mouse.x = e.clientX;\n        mouse.y = e.clientY;\n    });\n    let codeLines;\n    let commits;\n    let repositories;\n    let files;\n    let time = 0;\n    // Enhanced code snippets for variety\n    const codeSnippets = [\n        'function init() {',\n        '  const data = [];',\n        '  return data;',\n        '}',\n        'class Project {',\n        '  constructor() {',\n        '    this.name = \"\";',\n        '  }',\n        '}',\n        'const api = {',\n        '  get: async () => {',\n        '    return fetch(url);',\n        '  }',\n        '};',\n        'if (condition) {',\n        '  doSomething();',\n        '}',\n        'for (let i = 0; i < n; i++) {',\n        '  process(i);',\n        '}',\n        'try {',\n        '  await operation();',\n        '} catch (error) {',\n        '  console.log(error);',\n        '}',\n        'const Component = () => {',\n        '  return <div>Hello</div>;',\n        '};',\n        'export default App;',\n        'import React from \"react\";',\n        'useEffect(() => {',\n        '  // Effect logic',\n        '}, []);'\n    ];\n    const fileNames = [\n        'index.js',\n        'app.ts',\n        'style.css',\n        'README.md',\n        'package.json',\n        'config.js',\n        'utils.js',\n        'api.js',\n        'components.jsx',\n        'hooks.js',\n        'store.js',\n        'router.js',\n        'types.ts',\n        'constants.js',\n        'helpers.js',\n        'services.js'\n    ];\n    const resizeCanvas = ()=>{\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        // Initialize enhanced code lines\n        codeLines = [];\n        const lineCount = 18;\n        for(let i = 0; i < lineCount; i++)codeLines.push({\n            x: Math.random() * canvas.width,\n            y: Math.random() * canvas.height,\n            text: codeSnippets[Math.floor(Math.random() * codeSnippets.length)],\n            opacity: Math.random() * 0.7 + 0.2,\n            speed: Math.random() * 0.6 + 0.3,\n            typingProgress: 0,\n            maxTypingProgress: codeSnippets[Math.floor(Math.random() * codeSnippets.length)].length,\n            color: Math.random() > 0.5 ? '#FF6B6B' : '#4ECDC4',\n            fontSize: Math.random() * 4 + 12,\n            glowIntensity: Math.random() * 0.5 + 0.5,\n            syntaxType: Math.random() > 0.5 ? 'function' : 'variable'\n        });\n        // Initialize enhanced commits\n        commits = [];\n        const commitCount = 12;\n        for(let i = 0; i < commitCount; i++)commits.push({\n            x: Math.random() * canvas.width,\n            y: Math.random() * canvas.height,\n            message: `commit ${Math.random().toString(16).substr(2, 7)}`,\n            life: 0,\n            maxLife: Math.random() * 2.5 + 1.5,\n            size: Math.random() * 2.5 + 1.5,\n            vx: (Math.random() - 0.5) * 2.5,\n            vy: (Math.random() - 0.5) * 2.5,\n            color: Math.random() > 0.5 ? '#FFE66D' : '#FF6B9D',\n            glowIntensity: Math.random() * 0.5 + 0.5\n        });\n        // Initialize enhanced repositories\n        repositories = [];\n        const repoCount = 8;\n        for(let i = 0; i < repoCount; i++)repositories.push({\n            x: Math.random() * canvas.width,\n            y: Math.random() * canvas.height,\n            name: `repo-${i + 1}`,\n            size: Math.random() * 25 + 20,\n            pulse: Math.random() * Math.PI,\n            connections: [],\n            files: Math.floor(Math.random() * 15) + 8,\n            color: Math.random() > 0.5 ? '#FF6B6B' : '#4ECDC4',\n            glowIntensity: Math.random() * 0.5 + 0.5,\n            activity: Math.random() > 0.6\n        });\n        // Create enhanced connections between repositories\n        repositories.forEach((repo, i)=>{\n            repositories.forEach((otherRepo, j)=>{\n                if (i !== j && Math.random() > 0.6) repo.connections.push(j);\n            });\n        });\n        // Initialize enhanced files\n        files = [];\n        const fileCount = 25;\n        for(let i = 0; i < fileCount; i++)files.push({\n            x: Math.random() * canvas.width,\n            y: Math.random() * canvas.height,\n            name: fileNames[Math.floor(Math.random() * fileNames.length)],\n            size: Math.random() * 4 + 1.5,\n            opacity: Math.random() * 0.6 + 0.3,\n            vx: (Math.random() - 0.5) * 1.5,\n            vy: (Math.random() - 0.5) * 1.5,\n            modified: Math.random() > 0.85,\n            targetRepo: Math.floor(Math.random() * repositories.length),\n            color: Math.random() > 0.5 ? '#FF6B6B' : '#4ECDC4',\n            glowIntensity: Math.random() * 0.5 + 0.5\n        });\n    };\n    const draw = ()=>{\n        if (!ctx) return;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        time += 0.025;\n        // Draw enhanced repositories\n        repositories.forEach((repo, i)=>{\n            repo.pulse += 0.025;\n            const pulseFactor = (Math.sin(repo.pulse) + 1) / 2;\n            // Enhanced repository glow\n            const glowRadius = repo.size + pulseFactor * 15;\n            const gradient = ctx.createRadialGradient(repo.x, repo.y, 0, repo.x, repo.y, glowRadius);\n            const opacity = (0.4 - i * 0.05) * repo.glowIntensity;\n            const opacityHex1 = Math.floor(opacity * 255).toString(16).length === 1 ? '0' + Math.floor(opacity * 255).toString(16) : Math.floor(opacity * 255).toString(16);\n            const opacityHex2 = Math.floor(opacity * 76.5).toString(16).length === 1 ? '0' + Math.floor(opacity * 76.5).toString(16) : Math.floor(opacity * 76.5).toString(16);\n            gradient.addColorStop(0, `${repo.color}${opacityHex1}`);\n            gradient.addColorStop(0.4, `${repo.color}${opacityHex2}`);\n            gradient.addColorStop(1, 'transparent');\n            ctx.beginPath();\n            ctx.arc(repo.x, repo.y, glowRadius, 0, Math.PI * 2);\n            ctx.fillStyle = gradient;\n            ctx.fill();\n            // Enhanced repository main circle\n            ctx.beginPath();\n            ctx.arc(repo.x, repo.y, repo.size, 0, Math.PI * 2);\n            const repoOpacity = Math.floor((0.7 + pulseFactor * 0.3) * 255);\n            const repoOpacityHex = repoOpacity.toString(16).length === 1 ? '0' + repoOpacity.toString(16) : repoOpacity.toString(16);\n            ctx.fillStyle = `${repo.color}${repoOpacityHex}`;\n            ctx.fill();\n            // Enhanced inner highlight\n            ctx.beginPath();\n            ctx.arc(repo.x - repo.size * 0.25, repo.y - repo.size * 0.25, repo.size * 0.4, 0, Math.PI * 2);\n            ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + pulseFactor * 0.2})`;\n            ctx.fill();\n            // Enhanced repository name\n            ctx.font = '14px monospace';\n            ctx.fillStyle = `rgba(255, 255, 255, ${0.9 + pulseFactor * 0.1})`;\n            ctx.textAlign = 'center';\n            ctx.fillText(repo.name, repo.x, repo.y + 5);\n            // Enhanced file count\n            ctx.font = '11px monospace';\n            ctx.fillStyle = `rgba(255, 255, 255, ${0.7 + pulseFactor * 0.2})`;\n            ctx.fillText(`${repo.files} files`, repo.x, repo.y + 20);\n            // Activity indicator\n            if (repo.activity) {\n                ctx.beginPath();\n                ctx.arc(repo.x + repo.size + 3, repo.y - repo.size + 3, 3, 0, Math.PI * 2);\n                ctx.fillStyle = `rgba(0, 255, 0, ${pulseFactor * 0.8})`;\n                ctx.fill();\n            }\n        });\n        // Draw enhanced repository connections\n        repositories.forEach((repo, i)=>{\n            repo.connections.forEach((connectionIndex)=>{\n                const connectedRepo = repositories[connectionIndex];\n                const dist = Math.sqrt(Math.pow(repo.x - connectedRepo.x, 2) + Math.pow(repo.y - connectedRepo.y, 2));\n                if (dist < 250) {\n                    const opacity = (1 - dist / 250) * 0.4;\n                    const energyFlow = Math.sin(time * 3 + i + connectionIndex) * 0.5 + 0.5;\n                    ctx.beginPath();\n                    ctx.moveTo(repo.x, repo.y);\n                    ctx.lineTo(connectedRepo.x, connectedRepo.y);\n                    ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * energyFlow})`;\n                    ctx.lineWidth = 1 + energyFlow * 2;\n                    ctx.stroke();\n                }\n            });\n        });\n        // Draw enhanced files\n        files.forEach((file)=>{\n            file.x += file.vx;\n            file.y += file.vy;\n            if (file.x < 0 || file.x > canvas.width) file.vx *= -1;\n            if (file.y < 0 || file.y > canvas.height) file.vy *= -1;\n            // Enhanced file icon with glow\n            const fileGlowRadius = file.size + 2;\n            const fileGradient = ctx.createRadialGradient(file.x, file.y, 0, file.x, file.y, fileGlowRadius);\n            const fileOpacity = file.modified ? 0.8 : file.opacity;\n            const fileOpacityHex = Math.floor(fileOpacity * 255).toString(16).length === 1 ? '0' + Math.floor(fileOpacity * 255).toString(16) : Math.floor(fileOpacity * 255).toString(16);\n            fileGradient.addColorStop(0, `${file.color}${fileOpacityHex}`);\n            fileGradient.addColorStop(1, 'transparent');\n            ctx.beginPath();\n            ctx.arc(file.x, file.y, fileGlowRadius, 0, Math.PI * 2);\n            ctx.fillStyle = fileGradient;\n            ctx.fill();\n            // Main file icon\n            ctx.beginPath();\n            ctx.rect(file.x - file.size, file.y - file.size, file.size * 2, file.size * 2);\n            ctx.fillStyle = file.modified ? `rgba(255, 165, 0, ${file.opacity})` : `rgba(255, 255, 255, ${file.opacity})`;\n            ctx.fill();\n            // Enhanced file name\n            ctx.font = '9px monospace';\n            ctx.fillStyle = `rgba(255, 255, 255, ${file.opacity})`;\n            ctx.textAlign = 'center';\n            ctx.fillText(file.name, file.x, file.y + file.size + 10);\n            // Enhanced modified indicator\n            if (file.modified) {\n                ctx.beginPath();\n                ctx.arc(file.x + file.size, file.y - file.size, 3, 0, Math.PI * 2);\n                ctx.fillStyle = 'rgba(255, 0, 0, 0.9)';\n                ctx.fill();\n            }\n        });\n        // Draw enhanced code lines with typing effect\n        codeLines.forEach((line)=>{\n            line.typingProgress += line.speed;\n            if (line.typingProgress > line.maxTypingProgress) {\n                line.typingProgress = 0;\n                line.text = codeSnippets[Math.floor(Math.random() * codeSnippets.length)];\n                line.maxTypingProgress = line.text.length;\n                line.syntaxType = Math.random() > 0.5 ? 'function' : 'variable';\n            }\n            const displayText = line.text.substring(0, Math.floor(line.typingProgress));\n            const cursor = line.typingProgress < line.maxTypingProgress ? '|' : '';\n            ctx.font = `${line.fontSize}px 'Courier New', monospace`;\n            const lineOpacityHex = Math.floor(line.opacity * 255).toString(16).length === 1 ? '0' + Math.floor(line.opacity * 255).toString(16) : Math.floor(line.opacity * 255).toString(16);\n            // Enhanced syntax highlighting\n            if (line.syntaxType === 'function' && (displayText.includes('function') || displayText.includes('class') || displayText.includes('const') || displayText.includes('import'))) ctx.fillStyle = `rgba(255, 215, 0, ${line.opacity})`;\n            else ctx.fillStyle = `${line.color}${lineOpacityHex}`;\n            ctx.textAlign = 'left';\n            ctx.fillText(displayText + cursor, line.x, line.y);\n            // Enhanced glow effect for active typing\n            if (line.typingProgress < line.maxTypingProgress) {\n                ctx.fillStyle = `rgba(255, 255, 255, ${line.opacity * 0.6})`;\n                ctx.fillText(displayText + cursor, line.x, line.y);\n            }\n        });\n        // Draw enhanced commits\n        commits.forEach((commit, index)=>{\n            commit.life += 0.015;\n            commit.x += commit.vx;\n            commit.y += commit.vy;\n            if (commit.life > commit.maxLife) {\n                commit.life = 0;\n                commit.x = Math.random() * canvas.width;\n                commit.y = Math.random() * canvas.height;\n                commit.message = `commit ${Math.random().toString(16).substr(2, 7)}`;\n            }\n            const alpha = (1 - commit.life / commit.maxLife) * 0.8;\n            // Enhanced commit glow\n            const commitGlowRadius = commit.size + 3;\n            const commitGradient = ctx.createRadialGradient(commit.x, commit.y, 0, commit.x, commit.y, commitGlowRadius);\n            const commitOpacityHex = Math.floor(alpha * 255).toString(16).length === 1 ? '0' + Math.floor(alpha * 255).toString(16) : Math.floor(alpha * 255).toString(16);\n            commitGradient.addColorStop(0, `${commit.color}${commitOpacityHex}`);\n            commitGradient.addColorStop(1, 'transparent');\n            ctx.beginPath();\n            ctx.arc(commit.x, commit.y, commitGlowRadius, 0, Math.PI * 2);\n            ctx.fillStyle = commitGradient;\n            ctx.fill();\n            // Main commit circle\n            ctx.beginPath();\n            ctx.arc(commit.x, commit.y, commit.size, 0, Math.PI * 2);\n            ctx.fillStyle = `rgba(0, 255, 0, ${alpha})`;\n            ctx.fill();\n            // Enhanced commit message\n            ctx.font = '11px monospace';\n            ctx.fillStyle = `rgba(0, 255, 0, ${alpha})`;\n            ctx.textAlign = 'center';\n            ctx.fillText(commit.message, commit.x, commit.y + commit.size + 12);\n        });\n        // Add enhanced occasional new commits\n        if (Math.random() < 0.025) {\n            const newCommit = {\n                x: Math.random() * canvas.width,\n                y: canvas.height,\n                message: `commit ${Math.random().toString(16).substr(2, 7)}`,\n                life: 0,\n                maxLife: 2.5,\n                size: 2.5,\n                vx: (Math.random() - 0.5) * 2.5,\n                vy: -1.5,\n                color: Math.random() > 0.5 ? '#FFE66D' : '#FF6B9D',\n                glowIntensity: Math.random() * 0.5 + 0.5\n            };\n            commits.push(newCommit);\n        }\n        // Add enhanced occasional file modifications\n        if (Math.random() < 0.015) {\n            const randomFile = files[Math.floor(Math.random() * files.length)];\n            randomFile.modified = true;\n            setTimeout(()=>{\n                randomFile.modified = false;\n            }, 4000);\n        }\n    };\n    const animate = ()=>{\n        draw();\n        requestAnimationFrame(animate);\n    };\n    window.addEventListener('resize', resizeCanvas);\n    resizeCanvas();\n    animate();\n}\n// Main initialization\ndocument.addEventListener('DOMContentLoaded', ()=>{\n    console.log('DOM Content Loaded - Starting initialization...');\n    // Staggered fall-in animation for keyboard keys\n    const keys = document.querySelectorAll('.key');\n    keys.forEach((key, index)=>{\n        key.style.animationDelay = `${index * 0.05}s`;\n    });\n    // Page-specific initializations\n    const neuralCanvas = document.getElementById('neural-network-canvas');\n    const dataFlowCanvas = document.getElementById('data-flow-canvas');\n    const projectsCanvas = document.getElementById('projects-canvas');\n    console.log('Canvas elements found:', {\n        neural: !!neuralCanvas,\n        dataFlow: !!dataFlowCanvas,\n        projects: !!projectsCanvas\n    });\n    if (neuralCanvas) {\n        console.log('Initializing neural network background...');\n        $48731e7e213a0ef5$var$initNeuralNetworkBackground();\n    }\n    if (dataFlowCanvas) {\n        console.log('Initializing data flow background...');\n        $48731e7e213a0ef5$var$initDataFlowBackground();\n    }\n    if (projectsCanvas) {\n        console.log('Initializing projects background...');\n        $48731e7e213a0ef5$var$initProjectsBackground();\n    }\n    $48731e7e213a0ef5$var$initTooltips();\n    $48731e7e213a0ef5$var$initHamburgerMenu();\n    $48731e7e213a0ef5$var$initScrollToTop();\n    $48731e7e213a0ef5$var$initTimelineAnimation();\n    // Funzioni comuni a tutte le pagine\n    $48731e7e213a0ef5$var$initNavbarActiveLink();\n    $48731e7e213a0ef5$var$initNavbarScroll();\n    // Funzioni specifiche per pagina\n    if (window.location.pathname.includes('about.html')) $48731e7e213a0ef5$var$initTimelineAnimation();\n    window.location.pathname.includes('projects.html');\n    console.log('Initialization complete!');\n});\n// Add CSS animations via JavaScript\nconst $48731e7e213a0ef5$var$style = document.createElement('style');\n$48731e7e213a0ef5$var$style.textContent = `\n    .navbar.scrolled {\n        background: rgba(16, 37, 66, 0.95) !important;\n        box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1) !important;\n    }\n    \n    .animate {\n        animation: fadeInUp 0.8s ease forwards;\n    }\n    \n    @keyframes fadeInUp {\n        from {\n            opacity: 0;\n            transform: translateY(30px);\n        }\n        to {\n            opacity: 1;\n            transform: translateY(0);\n        }\n    }\n    \n    .skill-card, .project-card {\n        opacity: 0;\n        transform: translateY(30px);\n        transition: all 0.6s ease;\n    }\n    \n    .skill-card.animate, .project-card.animate {\n        opacity: 1;\n        transform: translateY(0);\n    }\n    \n    .notification-content {\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n        gap: 1rem;\n    }\n    \n    .notification-close {\n        background: none;\n        border: none;\n        color: white;\n        font-size: 1.5rem;\n        cursor: pointer;\n        padding: 0;\n        width: 24px;\n        height: 24px;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n    }\n    \n    .nav-link.active {\n        color: #F87060 !important;\n    }\n    \n    .nav-link.active::after {\n        width: 100% !important;\n    }\n`;\ndocument.head.appendChild($48731e7e213a0ef5$var$style);\n\n\n//# sourceMappingURL=portafolio-personale.e2cf03af.js.map\n","import { computePosition, offset, shift, flip, arrow } from '@floating-ui/dom';\n\n// DOM Elements\nconst hamburger = document.querySelector<HTMLDivElement>('.hamburger');\nconst navMenu = document.querySelector<HTMLDivElement>('.nav-menu');\nconst navLinks = document.querySelectorAll<HTMLAnchorElement>('.nav-link');\nconst navbar = document.querySelector<HTMLElement>('.navbar');\nconst hero = document.querySelector<HTMLElement>('.hero');\n\n// Custom Cursor Logic\nconst backToTopBtn = document.querySelector<HTMLAnchorElement>('.back-to-top-btn');\nconst tooltip = document.querySelector<HTMLElement>('#tooltip');\n\n// Tooltip Logic\nconst elementsWithTooltip = document.querySelectorAll('[data-tooltip]');\n\nelementsWithTooltip.forEach(element => {\n    const reference = element as HTMLElement;\n    const tooltipText = reference.dataset.tooltip || '';\n\n    const showTooltip = () => {\n        if (!tooltip) return;\n        tooltip.textContent = tooltipText;\n        tooltip.classList.add('visible');\n\n        computePosition(reference, tooltip, {\n            placement: 'top',\n            middleware: [offset(8), flip(), shift({ padding: 5 })],\n        }).then(({ x, y }) => {\n            Object.assign(tooltip.style, {\n                left: `${x}px`,\n                top: `${y}px`,\n            });\n        });\n    };\n\n    const hideTooltip = () => {\n        if (tooltip) {\n            tooltip.classList.remove('visible');\n        }\n    };\n\n    reference.addEventListener('mouseenter', showTooltip);\n    reference.addEventListener('mouseleave', hideTooltip);\n    reference.addEventListener('focus', showTooltip);\n    reference.addEventListener('blur', hideTooltip);\n});\n\n// Back to Top Button Logic\nwindow.addEventListener('scroll', () => {\n    if (window.scrollY > 300) {\n        backToTopBtn?.classList.add('visible');\n    } else {\n        backToTopBtn?.classList.remove('visible');\n    }\n});\n\nbackToTopBtn?.addEventListener('click', (e) => {\n    e.preventDefault();\n    document.querySelector('#home')?.scrollIntoView({ behavior: 'smooth' });\n});\n\n// Mobile Navigation Toggle\nfunction toggleMobileMenu() {\n    // Only toggle mobile menu on devices with width <= 1024px\n    if (window.innerWidth <= 1024) {\n        hamburger?.classList.toggle('active');\n        navMenu?.classList.toggle('active');\n        \n        // Prevent body scroll when menu is open\n        if (navMenu?.classList.contains('active')) {\n            document.body.style.overflow = 'hidden';\n        } else {\n            document.body.style.overflow = 'auto';\n        }\n    }\n}\n\nfunction closeMobileMenu() {\n    // Only close mobile menu on devices where it might be active\n    if (window.innerWidth <= 1024) {\n        hamburger?.classList.remove('active');\n        navMenu?.classList.remove('active');\n        document.body.style.overflow = 'auto';\n    }\n}\n\nhamburger?.addEventListener('click', (e) => {\n    e.preventDefault();\n    e.stopPropagation();\n    toggleMobileMenu();\n});\n\n// Add touch support for mobile devices\nhamburger?.addEventListener('touchstart', (e) => {\n    e.preventDefault();\n    e.stopPropagation();\n}, { passive: false });\n\nhamburger?.addEventListener('touchend', (e) => {\n    e.preventDefault();\n    e.stopPropagation();\n    toggleMobileMenu();\n}, { passive: false });\n\n// Close mobile menu when clicking on a link\nnavLinks.forEach(link => {\n    link.addEventListener('click', closeMobileMenu);\n    \n    // Add touch support for navigation links\n    link.addEventListener('touchend', (e) => {\n        // Small delay to ensure smooth transition\n        setTimeout(closeMobileMenu, 100);\n    }, { passive: true });\n});\n\n// Close mobile menu when clicking outside\ndocument.addEventListener('click', (e) => {\n    const target = e.target as HTMLElement;\n    if (window.innerWidth <= 1024 && \n        navMenu?.classList.contains('active') && \n        !navMenu.contains(target) && \n        !hamburger?.contains(target)) {\n        closeMobileMenu();\n    }\n});\n\n// Close mobile menu when touching outside (mobile)\ndocument.addEventListener('touchstart', (e) => {\n    const target = e.target as HTMLElement;\n    if (window.innerWidth <= 1024 && \n        navMenu?.classList.contains('active') && \n        !navMenu.contains(target) && \n        !hamburger?.contains(target)) {\n        closeMobileMenu();\n    }\n}, { passive: true });\n\n// Handle window resize\nwindow.addEventListener('resize', () => {\n    if (window.innerWidth > 1024) {\n        closeMobileMenu();\n        // Ensure navbar is in correct state for desktop\n        document.body.style.overflow = 'auto';\n        hamburger?.classList.remove('active');\n        navMenu?.classList.remove('active');\n    }\n});\n\n// Handle escape key to close mobile menu\ndocument.addEventListener('keydown', (e) => {\n    if (e.key === 'Escape' && \n        window.innerWidth <= 1024 && \n        navMenu?.classList.contains('active')) {\n        closeMobileMenu();\n    }\n});\n\n// Prevent scrolling on mobile when menu is open\nlet startY = 0;\ndocument.addEventListener('touchstart', (e) => {\n    if (window.innerWidth <= 1024 && navMenu?.classList.contains('active')) {\n        startY = e.touches[0].clientY;\n    }\n}, { passive: true });\n\ndocument.addEventListener('touchmove', (e) => {\n    if (window.innerWidth <= 1024 && navMenu?.classList.contains('active')) {\n        const target = e.target as HTMLElement;\n        if (!navMenu.contains(target)) {\n            e.preventDefault();\n        }\n    }\n}, { passive: false });\n\n// Navbar Background on Scroll\nwindow.addEventListener('scroll', () => {\n    if (window.scrollY > 100) {\n        navbar?.classList.add('scrolled');\n    } else {\n        navbar?.classList.remove('scrolled');\n    }\n});\n\n// Active Navigation Link Highlighting\nwindow.addEventListener('scroll', () => {\n    const scrollY = window.scrollY;\n    let currentSectionId = \"\";\n\n    const sections = document.querySelectorAll<HTMLElement>('section[id]');\n\n    sections.forEach(section => {\n        const sectionTop = section.offsetTop - 85; // Offset per l'altezza della navbar + buffer\n\n        if (scrollY >= sectionTop) {\n            currentSectionId = section.getAttribute('id') || \"\";\n        }\n    });\n    \n    // Gestisce il caso in cui si arriva in fondo alla pagina\n    if ((window.innerHeight + window.scrollY) >= document.body.scrollHeight - 2) {\n        const lastSection = sections[sections.length - 1];\n        if (lastSection) {\n            currentSectionId = lastSection.getAttribute('id') || \"\";\n        }\n    }\n\n    navLinks.forEach(link => {\n        link.classList.remove('active');\n        if (link.getAttribute('href') === `#${currentSectionId}`) {\n            link.classList.add('active');\n        }\n    });\n});\n\n// Animated Counter for Stats\nfunction animateCounter(element: HTMLElement, target: number, duration: number = 2000, suffix: string = ''): void {\n    let start = 0;\n    const increment = target / (duration / 16);\n    const timer = setInterval(() => {\n        start += increment;\n        if (start >= target) {\n            element.textContent = target.toString() + suffix;\n            clearInterval(timer);\n        } else {\n            element.textContent = Math.floor(start).toString() + suffix;\n        }\n    }, 16);\n}\n\n// Intersection Observer for Animations\nconst observerOptions: IntersectionObserverInit = {\n    threshold: 0.1,\n    rootMargin: '0px 0px -50px 0px'\n};\n\nconst observer = new IntersectionObserver((entries: IntersectionObserverEntry[]) => {\n    entries.forEach(entry => {\n        if (entry.isIntersecting) {\n            entry.target.classList.add('animate');\n            \n            // Text animation for section headers\n            if (entry.target.classList.contains('section-header')) {\n                const spans = entry.target.querySelectorAll('h2 span, p span');\n                spans.forEach((span, index) => {\n                    (span as HTMLElement).style.transitionDelay = `${index * 0.03}s`;\n                    (span as HTMLElement).style.opacity = '1';\n                    (span as HTMLElement).style.transform = 'translateY(0) scale(1)';\n                });\n            }\n\n            // Animate counters when stats section is visible\n            if (entry.target.classList.contains('stats')) {\n                const statNumbers = entry.target.querySelectorAll<HTMLElement>('.stat h4');\n                statNumbers.forEach(stat => {\n                    const target = parseInt(stat.dataset.target || '0');\n                    const suffix = stat.dataset.suffix || '';\n                    if (!isNaN(target)) {\n                        animateCounter(stat, target, 2000, suffix);\n                    }\n                });\n                // Unobserve the stats section after animation to prevent re-triggering\n                observer.unobserve(entry.target);\n            }\n        }\n    });\n}, observerOptions);\n\nfunction calculateAge(birthDate: Date): number {\n    const today = new Date();\n    let age = today.getFullYear() - birthDate.getFullYear();\n    const m = today.getMonth() - birthDate.getMonth();\n    if (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) {\n        age--;\n    }\n    return age;\n}\n\n// Typing animation for hero text\nfunction typeWriter(element: HTMLElement, text: string, speed: number = 100): void {\n    let i = 0;\n    \n    function type() {\n        if (i < text.length) {\n            if(element) element.textContent += text.charAt(i);\n            i++;\n            setTimeout(type, speed);\n        }\n    }\n    \n    type();\n}\n\nfunction initInteractiveParticles(canvas: HTMLCanvasElement) {\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    let width = canvas.offsetWidth;\n    let height = canvas.offsetHeight;\n    canvas.width = width;\n    canvas.height = height;\n\n    const mouse = { x: width / 2, y: height / 2 };\n    canvas.addEventListener('mousemove', (event) => {\n        const rect = canvas.getBoundingClientRect();\n        mouse.x = event.clientX - rect.left;\n        mouse.y = event.clientY - rect.top;\n    });\n    \n    canvas.addEventListener('mouseleave', () => {\n        mouse.x = width / 2;\n        mouse.y = height / 2;\n    });\n\n    window.addEventListener('resize', () => {\n        width = canvas.offsetWidth;\n        height = canvas.offsetHeight;\n        canvas.width = width;\n        canvas.height = height;\n    });\n\n    class Particle {\n        x: number;\n        y: number;\n        size: number;\n        speedX: number;\n        speedY: number;\n\n        constructor() {\n            this.x = Math.random() * width;\n            this.y = Math.random() * height;\n            this.size = Math.random() * 2 + 1;\n            this.speedX = (Math.random() * 2 - 1) * 0.5;\n            this.speedY = (Math.random() * 2 - 1) * 0.5;\n        }\n\n        update() {\n            this.x += this.speedX;\n            this.y += this.speedY;\n\n            // Interazione con il mouse\n            let dx = this.x - mouse.x;\n            let dy = this.y - mouse.y;\n            let distance = Math.sqrt(dx * dx + dy * dy);\n            if (distance < 100) {\n                 this.x += dx / distance * 2;\n                 this.y += dy / distance * 2;\n            }\n\n            // Mantieni le particelle all'interno dei bordi con un margine\n            const margin = 10;\n            if (this.x < margin) {\n                this.x = margin;\n                this.speedX = Math.abs(this.speedX);\n            }\n            if (this.x > width - margin) {\n                this.x = width - margin;\n                this.speedX = -Math.abs(this.speedX);\n            }\n            if (this.y < margin) {\n                this.y = margin;\n                this.speedY = Math.abs(this.speedY);\n            }\n            if (this.y > height - margin) {\n                this.y = height - margin;\n                this.speedY = -Math.abs(this.speedY);\n            }\n        }\n\n        draw() {\n            if (!ctx) return;\n            ctx.fillStyle = 'rgba(237, 242, 244, 0.8)';\n            ctx.beginPath();\n            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n            ctx.fill();\n        }\n    }\n\n    let particlesArray: Particle[] = [];\n    function initParticles() {\n        particlesArray = [];\n        const numberOfParticles = 80;\n        for (let i = 0; i < numberOfParticles; i++) {\n            particlesArray.push(new Particle());\n        }\n    }\n    initParticles();\n\n    function handleParticles() {\n        for (let i = 0; i < particlesArray.length; i++) {\n            particlesArray[i].update();\n            particlesArray[i].draw();\n            for (let j = i; j < particlesArray.length; j++) {\n                const dx = particlesArray[i].x - particlesArray[j].x;\n                const dy = particlesArray[i].y - particlesArray[j].y;\n                const distance = Math.sqrt(dx * dx + dy * dy);\n                if (distance < 100) {\n                    if (!ctx) return;\n                    ctx.beginPath();\n                    ctx.strokeStyle = `rgba(248, 112, 96, ${1 - distance / 100})`;\n                    ctx.lineWidth = 0.5;\n                    ctx.moveTo(particlesArray[i].x, particlesArray[i].y);\n                    ctx.lineTo(particlesArray[j].x, particlesArray[j].y);\n                    ctx.stroke();\n                }\n            }\n        }\n    }\n\n    function animate() {\n        if (!ctx) return;\n        ctx.clearRect(0, 0, width, height);\n        handleParticles();\n        requestAnimationFrame(animate);\n    }\n    animate();\n}\n\nfunction initPlexusAnimation(canvas: HTMLCanvasElement) {\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    let points: {x: number, y: number, vx: number, vy: number, impactRadius: number, impactOpacity: number}[] = [];\n    let snake: {x: number, y: number}[] = [];\n    let snakeTarget = 0;\n    const easing = 0.05; // Fattore di easing per un movimento pi fluido\n\n    const setup = () => {\n        canvas.width = canvas.offsetWidth;\n        canvas.height = canvas.offsetHeight;\n        points = [];\n        const pointCount = Math.floor(canvas.width * canvas.height / 9000); // Leggermente meno punti\n\n        for (let i = 0; i < pointCount; i++) {\n            points.push({\n                x: Math.random() * canvas.width,\n                y: Math.random() * canvas.height,\n                vx: (Math.random() - 0.5) * 0.4, // Velocit leggermente ridotta\n                vy: (Math.random() - 0.5) * 0.4,\n                impactRadius: 0,\n                impactOpacity: 0\n            });\n        }\n\n        snake = [{ x: canvas.width / 2, y: canvas.height / 2 }];\n        for (let i = 1; i < 15; i++) { // Coda pi lunga per un effetto pi visibile\n            snake.push({\n                x: snake[0].x,\n                y: snake[0].y\n            });\n        }\n        findNewTarget();\n    };\n\n    const findNewTarget = () => {\n        let newTarget;\n        do {\n            newTarget = Math.floor(Math.random() * points.length);\n        } while (newTarget === snakeTarget);\n        snakeTarget = newTarget;\n    };\n\n    const updateSnake = () => {\n        if (points.length === 0 || !points[snakeTarget]) return;\n\n        const target = points[snakeTarget];\n        const head = snake[0];\n\n        const dx = target.x - head.x;\n        const dy = target.y - head.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance < 10) {\n            // \"Colpito\" il target: crea effetto impatto\n            points[snakeTarget].impactRadius = 15;\n            points[snakeTarget].impactOpacity = 1;\n            findNewTarget();\n        } else {\n            // Muovi la testa con easing\n            head.x += dx * easing;\n            head.y += dy * easing;\n        }\n\n        // La coda segue la testa\n        for (let i = 1; i < snake.length; i++) {\n            const leader = snake[i - 1];\n            const segment = snake[i];\n            const segDx = leader.x - segment.x;\n            const segDy = leader.y - segment.y;\n            segment.x += segDx * 0.5; // La coda segue in modo pi \"morbido\"\n            segment.y += segDy * 0.5;\n        }\n    };\n\n    const draw = () => {\n        if (!ctx) return;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        \n        // Disegna e aggiorna i punti e gli impatti\n        points.forEach(p => {\n            p.x += p.vx;\n            p.y += p.vy;\n\n            if (p.x < 0 || p.x > canvas.width) p.vx *= -1;\n            if (p.y < 0 || p.y > canvas.height) p.vy *= -1;\n            \n            ctx.beginPath();\n            ctx.fillStyle = 'rgba(248, 112, 96, 0.8)';\n            ctx.arc(p.x, p.y, 1.5, 0, Math.PI * 2);\n            ctx.fill();\n\n            // Disegna l'effetto impatto\n            if (p.impactRadius > 0) {\n                ctx.beginPath();\n                ctx.strokeStyle = `rgba(248, 112, 96, ${p.impactOpacity})`;\n                ctx.lineWidth = 2;\n                ctx.arc(p.x, p.y, p.impactRadius, 0, Math.PI * 2);\n                ctx.stroke();\n\n                p.impactRadius += 0.5; // L'onda si espande\n                p.impactOpacity -= 0.02; // E svanisce\n                if (p.impactOpacity <= 0) {\n                    p.impactRadius = 0;\n                    p.impactOpacity = 0;\n                }\n            }\n        });\n\n        // Disegna le connessioni tra punti (plexus)\n        for (let i = 0; i < points.length; i++) {\n            for (let j = i + 1; j < points.length; j++) {\n                const dist = Math.hypot(points[i].x - points[j].x, points[i].y - points[j].y);\n                if (dist < 100) { // Distanza di connessione ridotta\n                    ctx.beginPath();\n                    ctx.moveTo(points[i].x, points[i].y);\n                    ctx.lineTo(points[j].x, points[j].y);\n                    ctx.lineWidth = (1 - dist / 100) * 0.4;\n                    ctx.strokeStyle = 'rgba(248, 112, 96, 0.2)';\n                    ctx.stroke();\n                }\n            }\n        }\n\n        updateSnake();\n        \n        // Disegna il proiettile (serpente)\n        for (let i = 0; i < snake.length; i++) {\n            const segment = snake[i];\n            const opacity = 1 - (i / snake.length) * 0.8;\n            const size = 5 - (i / snake.length) * 4; // La coda si restringe\n\n            ctx.beginPath();\n            ctx.fillStyle = `rgba(248, 112, 96, ${opacity})`;\n            ctx.arc(segment.x, segment.y, Math.max(1, size), 0, Math.PI * 2);\n            ctx.fill();\n        }\n\n        // Disegna un alone attorno al punto target\n        if (points[snakeTarget]) {\n            const target = points[snakeTarget];\n            ctx.beginPath();\n            ctx.strokeStyle = 'rgba(248, 112, 96, 0.5)';\n            ctx.lineWidth = 1;\n            ctx.arc(target.x, target.y, 10, 0, Math.PI * 2);\n            ctx.stroke();\n        }\n\n        requestAnimationFrame(draw);\n    };\n\n    let animationFrameId: number | null = null;\n    const projectsSection = document.getElementById('projects');\n\n    const plexusObserver = new IntersectionObserver((entries) => {\n        entries.forEach(entry => {\n            if (entry.isIntersecting) {\n                if (!animationFrameId) {\n                    setup();\n                    animationFrameId = requestAnimationFrame(draw);\n                }\n            } else {\n                if (animationFrameId) {\n                    cancelAnimationFrame(animationFrameId);\n                    animationFrameId = null;\n                }\n            }\n        });\n    }, { threshold: 0.1 });\n    \n    if (projectsSection) {\n        plexusObserver.observe(projectsSection);\n    }\n    window.addEventListener('resize', setup);\n}\n\nfunction initTechArt() {\n    const container = document.getElementById('tech-art-container');\n    if (!container) return;\n\n    const canvas = document.createElement('canvas');\n    container.appendChild(canvas);\n    const ctx = canvas.getContext('2d');\n\n    let width = container.clientWidth;\n    let height = container.clientHeight;\n    canvas.width = width;\n    canvas.height = height;\n\n    const particles: TechParticle[] = [];\n    const particleCount = Math.min(Math.floor(width / 20), 30);\n    const maxDistance = 100;\n\n    class TechParticle {\n        x: number;\n        y: number;\n        size: number;\n        speedX: number;\n        speedY: number;\n\n        constructor() {\n            this.x = Math.random() * width;\n            this.y = Math.random() * height;\n            this.size = Math.random() * 2 + 1;\n            this.speedX = (Math.random() - 0.5) * 0.5;\n            this.speedY = (Math.random() - 0.5) * 0.5;\n        }\n\n        update() {\n            this.x += this.speedX;\n            this.y += this.speedY;\n            \n            // Mantieni le particelle all'interno dei bordi con un margine\n            const margin = 5;\n            if (this.x < margin) {\n                this.x = margin;\n                this.speedX = Math.abs(this.speedX);\n            }\n            if (this.x > width - margin) {\n                this.x = width - margin;\n                this.speedX = -Math.abs(this.speedX);\n            }\n            if (this.y < margin) {\n                this.y = margin;\n                this.speedY = Math.abs(this.speedY);\n            }\n            if (this.y > height - margin) {\n                this.y = height - margin;\n                this.speedY = -Math.abs(this.speedY);\n            }\n        }\n\n        draw() {\n            if (!ctx) return;\n            ctx.fillStyle = '#F87060';\n            ctx.beginPath();\n            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n            ctx.fill();\n        }\n    }\n\n    function initParticles() {\n        particles.length = 0;\n        for (let i = 0; i < particleCount; i++) {\n            particles.push(new TechParticle());\n        }\n    }\n\n    function handleParticles() {\n        if (!ctx) return;\n        for (let i = 0; i < particles.length; i++) {\n            particles[i].update();\n            particles[i].draw();\n\n            for (let j = i + 1; j < particles.length; j++) {\n                const dx = particles[i].x - particles[j].x;\n                const dy = particles[i].y - particles[j].y;\n                const distance = Math.sqrt(dx * dx + dy * dy);\n\n                if (distance < maxDistance) {\n                    ctx.beginPath();\n                    ctx.strokeStyle = `rgba(248, 112, 96, ${1 - distance / maxDistance})`;\n                    ctx.lineWidth = 0.5;\n                    ctx.moveTo(particles[i].x, particles[i].y);\n                    ctx.lineTo(particles[j].x, particles[j].y);\n                    ctx.stroke();\n                }\n            }\n        }\n    }\n    \n    function animate() {\n        if (!ctx) return;\n        ctx.clearRect(0, 0, width, height);\n        handleParticles();\n        requestAnimationFrame(animate);\n    }\n    \n    window.addEventListener('resize', () => {\n        width = container.clientWidth;\n        height = container.clientHeight;\n        canvas.width = width;\n        canvas.height = height;\n        initParticles();\n    });\n\n    initParticles();\n    animate();\n}\n\nfunction initSubtleBackground() {\n    const canvas = document.getElementById('matrix-canvas') as HTMLCanvasElement;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    let width = canvas.width = window.innerWidth;\n    let height = canvas.height = window.innerHeight;\n\n    interface FloatingDot {\n        x: number;\n        y: number;\n        size: number;\n        speedX: number;\n        speedY: number;\n        opacity: number;\n        pulseSpeed: number;\n        pulsePhase: number;\n    }\n\n    const dots: FloatingDot[] = [];\n    const dotCount = Math.floor((width * height) / 15000); // Densit molto bassa\n\n    // Inizializza i punti fluttuanti\n    for (let i = 0; i < dotCount; i++) {\n        dots.push({\n            x: Math.random() * width,\n            y: Math.random() * height,\n            size: Math.random() * 2 + 1,\n            speedX: (Math.random() - 0.5) * 0.2,\n            speedY: (Math.random() - 0.5) * 0.2,\n            opacity: Math.random() * 0.3 + 0.1,\n            pulseSpeed: Math.random() * 0.02 + 0.01,\n            pulsePhase: Math.random() * Math.PI * 2\n        });\n    }\n\n    function draw() {\n        if (!ctx) return;\n        ctx.clearRect(0, 0, width, height);\n\n        dots.forEach(dot => {\n            // Aggiorna posizione\n            dot.x += dot.speedX;\n            dot.y += dot.speedY;\n\n            // Rimbalzo sui bordi\n            if (dot.x < 0 || dot.x > width) dot.speedX *= -1;\n            if (dot.y < 0 || dot.y > height) dot.speedY *= -1;\n\n            // Effetto pulsazione\n            dot.pulsePhase += dot.pulseSpeed;\n            const pulseOpacity = dot.opacity * (0.5 + 0.5 * Math.sin(dot.pulsePhase));\n\n            // Disegna il punto con gradiente\n            const gradient = ctx.createRadialGradient(dot.x, dot.y, 0, dot.x, dot.y, dot.size * 3);\n            gradient.addColorStop(0, `rgba(248, 112, 96, ${pulseOpacity})`);\n            gradient.addColorStop(1, 'rgba(248, 112, 96, 0)');\n\n            ctx.fillStyle = gradient;\n            ctx.beginPath();\n            ctx.arc(dot.x, dot.y, dot.size * 3, 0, Math.PI * 2);\n            ctx.fill();\n        });\n\n        // Disegna connessioni sottili tra punti vicini\n        ctx.strokeStyle = 'rgba(248, 112, 96, 0.1)';\n        ctx.lineWidth = 0.5;\n        \n        for (let i = 0; i < dots.length; i++) {\n            for (let j = i + 1; j < dots.length; j++) {\n                const dx = dots[i].x - dots[j].x;\n                const dy = dots[i].y - dots[j].y;\n                const distance = Math.sqrt(dx * dx + dy * dy);\n                \n                if (distance < 150) {\n                    const opacity = (1 - distance / 150) * 0.1;\n                    ctx.strokeStyle = `rgba(248, 112, 96, ${opacity})`;\n                    ctx.beginPath();\n                    ctx.moveTo(dots[i].x, dots[i].y);\n                    ctx.lineTo(dots[j].x, dots[j].y);\n                    ctx.stroke();\n                }\n            }\n        }\n\n        requestAnimationFrame(draw);\n    }\n\n    window.addEventListener('resize', () => {\n        width = canvas.width = window.innerWidth;\n        height = canvas.height = window.innerHeight;\n        \n        // Ricalcola il numero di punti in base alla nuova dimensione\n        const newDotCount = Math.floor((width * height) / 15000);\n        while (dots.length > newDotCount) {\n            dots.pop();\n        }\n        while (dots.length < newDotCount) {\n            dots.push({\n                x: Math.random() * width,\n                y: Math.random() * height,\n                size: Math.random() * 2 + 1,\n                speedX: (Math.random() - 0.5) * 0.2,\n                speedY: (Math.random() - 0.5) * 0.2,\n                opacity: Math.random() * 0.3 + 0.1,\n                pulseSpeed: Math.random() * 0.02 + 0.01,\n                pulsePhase: Math.random() * Math.PI * 2\n            });\n        }\n    });\n\n    draw();\n}\n\nfunction initTypingAnimation() {\n    const nameSpan = document.querySelector<HTMLElement>('.hero-text h1 .highlight');\n    if (nameSpan?.textContent) {\n        const textToType = nameSpan.textContent;\n        nameSpan.textContent = ''; \n        setTimeout(() => {\n            if (nameSpan) typeWriter(nameSpan, textToType, 100);\n        }, 1000); \n    }\n}\n\nfunction initHamburgerMenu() {\n    const hamburger = document.querySelector<HTMLDivElement>('.hamburger');\n    const navMenu = document.querySelector<HTMLDivElement>('.nav-menu');\n    const navLinks = document.querySelectorAll<HTMLAnchorElement>('.nav-link');\n    \n    hamburger?.addEventListener('click', () => {\n        hamburger.classList.toggle('active');\n        navMenu?.classList.toggle('active');\n    });\n\n    // Close mobile menu when clicking on a link\n    navLinks.forEach(link => {\n        link.addEventListener('click', () => {\n            hamburger?.classList.remove('active');\n            navMenu?.classList.remove('active');\n        });\n    });\n}\n\nfunction initNavbarActiveLink() {\n    const currentPage = window.location.pathname.split('/').pop() || 'index.html';\n    const navLinks = document.querySelectorAll<HTMLAnchorElement>('.nav-menu a');\n\n    navLinks.forEach(link => {\n        const linkPage = link.getAttribute('href');\n        if (linkPage === currentPage) {\n            link.classList.add('active');\n        }\n    });\n}\n\nfunction initNavbarScroll() {\n    const navbar = document.querySelector<HTMLElement>('.navbar');\n    \n    window.addEventListener('scroll', () => {\n        if (window.scrollY > 100) {\n            navbar?.classList.add('scrolled');\n        } else {\n            navbar?.classList.remove('scrolled');\n        }\n    });\n}\n\nfunction initScrollToTop() {\n    const backToTopBtn = document.getElementById('scrollToTopBtn');\n    if (!backToTopBtn) return;\n    \n    window.addEventListener('scroll', () => {\n        if (window.scrollY > 300) {\n            backToTopBtn.classList.add('visible');\n        } else {\n            backToTopBtn.classList.remove('visible');\n        }\n    });\n\n    backToTopBtn.addEventListener('click', (e) => {\n        e.preventDefault();\n        window.scrollTo({ top: 0, behavior: 'smooth' });\n    });\n}\n\nfunction initTooltips() {\n    const tooltipItems = document.querySelectorAll<HTMLElement>('[data-tooltip]');\n    const tooltip = document.getElementById('tooltip') as HTMLElement | null;\n    \n    if (tooltip && tooltipItems.length > 0) {\n        tooltipItems.forEach(item => {\n            const reference = item;\n            const tooltipText = reference.dataset.tooltip || '';\n\n            const showTooltip = () => {\n                tooltip.textContent = tooltipText;\n                tooltip.classList.add('visible');\n\n                computePosition(reference, tooltip, {\n                    placement: 'top',\n                    middleware: [offset(8), flip(), shift({ padding: 5 })],\n                }).then(({ x, y }) => {\n                    Object.assign(tooltip.style, {\n                        left: `${x}px`,\n                        top: `${y}px`,\n                    });\n                });\n            };\n\n            const hideTooltip = () => {\n                tooltip.classList.remove('visible');\n            };\n\n            reference.addEventListener('mouseenter', showTooltip);\n            reference.addEventListener('mouseleave', hideTooltip);\n            reference.addEventListener('focus', showTooltip);\n            reference.addEventListener('blur', hideTooltip);\n        });\n    }\n}\n\nfunction initKeyboardAnimation() {\n    // La logica per l'animazione della tastiera va qui se necessaria\n}\n\nfunction initStatsCounters() {\n    const observer = new IntersectionObserver((entries) => {\n        entries.forEach(entry => {\n            if (entry.isIntersecting) {\n                if (entry.target.matches('.stats')) {\n                     const statNumbers = entry.target.querySelectorAll<HTMLElement>('.stat h4');\n                     statNumbers.forEach(stat => {\n                         const target = parseInt(stat.dataset.target || '0', 10);\n                         const suffix = stat.dataset.suffix || '';\n                         animateCounter(stat, target, 2000, suffix);\n                     });\n                     observer.unobserve(entry.target);\n                }\n            }\n        });\n    }, { threshold: 0.1 });\n\n    const statsEl = document.querySelector('.stats');\n    if (statsEl) {\n        observer.observe(statsEl);\n    }\n}\n\nfunction initTimelineAnimation() {\n    const timelineItems = document.querySelectorAll('.timeline-item');\n    \n    const timelineObserver = new IntersectionObserver((entries) => {\n        entries.forEach(entry => {\n            if (entry.isIntersecting) {\n                entry.target.classList.add('animate');\n            }\n        });\n    }, { threshold: 0.1 });\n\n    timelineItems.forEach(item => {\n        timelineObserver.observe(item);\n    });\n}\n\nfunction initAboutBackground() {\n    const aboutSection = document.querySelector('.about') as HTMLElement;\n    if (!aboutSection) return;\n\n    // Crea il canvas per le forme geometriche animate\n    const canvas = document.createElement('canvas');\n    canvas.style.position = 'absolute';\n    canvas.style.top = '0';\n    canvas.style.left = '0';\n    canvas.style.width = '100%';\n    canvas.style.height = '100%';\n    canvas.style.zIndex = '1';\n    canvas.style.pointerEvents = 'none';\n    canvas.style.opacity = '0.6';\n    \n    aboutSection.appendChild(canvas);\n    \n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    let width = aboutSection.offsetWidth;\n    let height = aboutSection.offsetHeight;\n    canvas.width = width;\n    canvas.height = height;\n\n    interface FloatingShape {\n        x: number;\n        y: number;\n        size: number;\n        speedX: number;\n        speedY: number;\n        rotation: number;\n        rotationSpeed: number;\n        type: 'circle' | 'triangle' | 'square';\n        opacity: number;\n    }\n\n    const shapes: FloatingShape[] = [];\n    const shapeCount = 8;\n\n    // Inizializza le forme\n    for (let i = 0; i < shapeCount; i++) {\n        shapes.push({\n            x: Math.random() * width,\n            y: Math.random() * height,\n            size: Math.random() * 40 + 20,\n            speedX: (Math.random() - 0.5) * 0.3,\n            speedY: (Math.random() - 0.5) * 0.3,\n            rotation: Math.random() * Math.PI * 2,\n            rotationSpeed: (Math.random() - 0.5) * 0.01,\n            type: ['circle', 'triangle', 'square'][Math.floor(Math.random() * 3)] as 'circle' | 'triangle' | 'square',\n            opacity: Math.random() * 0.3 + 0.1\n        });\n    }\n\n    function drawShape(shape: FloatingShape) {\n        if (!ctx) return;\n        \n        ctx.save();\n        ctx.translate(shape.x, shape.y);\n        ctx.rotate(shape.rotation);\n        ctx.globalAlpha = shape.opacity;\n        \n        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, shape.size);\n        gradient.addColorStop(0, 'rgba(248, 112, 96, 0.3)');\n        gradient.addColorStop(1, 'rgba(248, 112, 96, 0)');\n        \n        ctx.fillStyle = gradient;\n        ctx.strokeStyle = 'rgba(248, 112, 96, 0.2)';\n        ctx.lineWidth = 1;\n\n        switch (shape.type) {\n            case 'circle':\n                ctx.beginPath();\n                ctx.arc(0, 0, shape.size / 2, 0, Math.PI * 2);\n                ctx.fill();\n                ctx.stroke();\n                break;\n            \n            case 'triangle':\n                ctx.beginPath();\n                ctx.moveTo(0, -shape.size / 2);\n                ctx.lineTo(-shape.size / 2, shape.size / 2);\n                ctx.lineTo(shape.size / 2, shape.size / 2);\n                ctx.closePath();\n                ctx.fill();\n                ctx.stroke();\n                break;\n            \n            case 'square':\n                ctx.fillRect(-shape.size / 2, -shape.size / 2, shape.size, shape.size);\n                ctx.strokeRect(-shape.size / 2, -shape.size / 2, shape.size, shape.size);\n                break;\n        }\n        \n        ctx.restore();\n    }\n\n    function updateShapes() {\n        shapes.forEach(shape => {\n            shape.x += shape.speedX;\n            shape.y += shape.speedY;\n            shape.rotation += shape.rotationSpeed;\n\n            // Rimbalzo sui bordi\n            if (shape.x < -shape.size || shape.x > width + shape.size) {\n                shape.speedX *= -1;\n            }\n            if (shape.y < -shape.size || shape.y > height + shape.size) {\n                shape.speedY *= -1;\n            }\n\n            // Mantieni le forme all'interno dell'area\n            shape.x = Math.max(-shape.size / 2, Math.min(width + shape.size / 2, shape.x));\n            shape.y = Math.max(-shape.size / 2, Math.min(height + shape.size / 2, shape.y));\n        });\n    }\n\n    function animate() {\n        if (!ctx) return;\n        ctx.clearRect(0, 0, width, height);\n        \n        updateShapes();\n        shapes.forEach(drawShape);\n        \n        requestAnimationFrame(animate);\n    }\n\n    // Gestisci il ridimensionamento\n    const resizeObserver = new ResizeObserver(() => {\n        width = aboutSection.offsetWidth;\n        height = aboutSection.offsetHeight;\n        canvas.width = width;\n        canvas.height = height;\n    });\n    \n    resizeObserver.observe(aboutSection);\n    \n    // Avvia l'animazione solo quando la sezione  visibile\n    const intersectionObserver = new IntersectionObserver((entries) => {\n        entries.forEach(entry => {\n            if (entry.isIntersecting) {\n                animate();\n            }\n        });\n    }, { threshold: 0.1 });\n    \n    intersectionObserver.observe(aboutSection);\n}\n\nfunction initParallaxEffect() {\n    const parallaxElements = document.querySelectorAll('.profile-photo-container, .timeline-container');\n    \n    if (parallaxElements.length === 0) return;\n\n    const handleScroll = () => {\n        const scrollY = window.scrollY;\n        \n        parallaxElements.forEach(el => {\n            const element = el as HTMLElement;\n            const speed = parseFloat(element.dataset.parallaxSpeed || '0.1');\n            const offset = scrollY * speed;\n\n            element.style.transform = `translateY(${offset}px)`;\n        });\n    };\n\n    window.addEventListener('scroll', handleScroll, { passive: true });\n}\n\n/**\n * Initializes a neural network animation on a canvas.\n */\nfunction initNeuralNetworkBackground() {\n    console.log('initNeuralNetworkBackground called');\n    const canvas = document.getElementById('neural-network-canvas') as HTMLCanvasElement;\n    if (!canvas) {\n        console.error('Neural network canvas not found!');\n        return;\n    }\n    console.log('Neural network canvas found, starting animation...');\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n        console.error('Could not get 2D context for neural network canvas!');\n        return;\n    }\n\n    const mouse = { x: 0, y: 0 };\n    window.addEventListener('mousemove', e => {\n        mouse.x = e.clientX;\n        mouse.y = e.clientY;\n    });\n\n    let nodes: any[];\n    let particles: any[];\n    let impulses: any[];\n    let time = 0;\n\n    const resizeCanvas = () => {\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n\n        nodes = [];\n        const nodeCount = window.innerWidth < 768 ? 60 : 120;\n        for (let i = 0; i < nodeCount; i++) {\n            nodes.push({\n                x: Math.random() * canvas.width,\n                y: Math.random() * canvas.height,\n                vx: (Math.random() - 0.5) * 0.4,\n                vy: (Math.random() - 0.5) * 0.4,\n                baseRadius: Math.random() * 2.5 + 0.8,\n                pulseAngle: Math.random() * Math.PI,\n                color: Math.random() > 0.5 ? '#FF6B6B' : '#4ECDC4',\n                energy: Math.random(),\n                layer: Math.floor(Math.random() * 3),\n                processing: Math.random() > 0.6,\n                connections: [],\n                lastImpulse: 0,\n                glowIntensity: Math.random() * 0.5 + 0.5,\n            });\n        }\n\n        // Create connections between nodes\n        nodes.forEach((node, i) => {\n            nodes.forEach((otherNode, j) => {\n                if (i !== j) {\n                    const dist = Math.sqrt(Math.pow(node.x - otherNode.x, 2) + Math.pow(node.y - otherNode.y, 2));\n                    if (dist < 140 && Math.random() > 0.6) {\n                        node.connections.push(j);\n                    }\n                }\n            });\n        });\n\n        particles = [];\n        const particleCount = 40;\n        for (let i = 0; i < particleCount; i++) {\n            particles.push({\n                x: Math.random() * canvas.width,\n                y: Math.random() * canvas.height,\n                vx: (Math.random() - 0.5) * 2,\n                vy: (Math.random() - 0.5) * 2,\n                life: Math.random(),\n                maxLife: Math.random() * 1 + 0.5,\n                size: Math.random() * 2 + 0.8,\n                targetNode: Math.floor(Math.random() * nodes.length),\n                color: Math.random() > 0.5 ? '#FFE66D' : '#FF6B9D',\n            });\n        }\n\n        impulses = [];\n    };\n\n    const draw = () => {\n        if (!ctx) return;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        time += 0.015;\n\n        // Draw enhanced background noise with depth\n        for (let i = 0; i < 30; i++) {\n            const x = Math.random() * canvas.width;\n            const y = Math.random() * canvas.height;\n            const size = Math.random() * 1.5;\n            const alpha = Math.random() * 0.15;\n            ctx.beginPath();\n            ctx.arc(x, y, size, 0, Math.PI * 2);\n            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;\n            ctx.fill();\n        }\n\n        // Draw particles with enhanced movement\n        particles.forEach(particle => {\n            const targetNode = nodes[particle.targetNode];\n            const dx = targetNode.x - particle.x;\n            const dy = targetNode.y - particle.y;\n            const dist = Math.sqrt(dx * dx + dy * dy);\n            \n            if (dist > 5) {\n                particle.vx += dx * 0.002;\n                particle.vy += dy * 0.002;\n            }\n            \n            particle.x += particle.vx;\n            particle.y += particle.vy;\n            particle.life += 0.015;\n\n            if (particle.life > particle.maxLife || dist < 5) {\n                particle.life = 0;\n                particle.x = Math.random() * canvas.width;\n                particle.y = Math.random() * canvas.height;\n                particle.targetNode = Math.floor(Math.random() * nodes.length);\n            }\n\n            const alpha = (1 - particle.life / particle.maxLife) * 0.6;\n            ctx.beginPath();\n            ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);\n            const particleOpacityHex = Math.floor(alpha * 255).toString(16).length === 1 ? '0' + Math.floor(alpha * 255).toString(16) : Math.floor(alpha * 255).toString(16);\n            ctx.fillStyle = `${particle.color}${particleOpacityHex}`;\n            ctx.fill();\n        });\n\n        // Draw nodes in layers with enhanced effects\n        for (let layer = 0; layer < 3; layer++) {\n            nodes.filter(node => node.layer === layer).forEach(node => {\n                node.x += node.vx;\n                node.y += node.vy;\n                node.energy += 0.015;\n\n                if (node.x < 0 || node.x > canvas.width) node.vx *= -1;\n                if (node.y < 0 || node.y > canvas.height) node.vy *= -1;\n                \n                node.pulseAngle += 0.02;\n                const pulseFactor = (Math.sin(node.pulseAngle) + 1) / 2;\n                const currentRadius = node.baseRadius + pulseFactor * 1.5;\n\n                // Calculate distance to mouse for enhanced interaction\n                const distToMouse = Math.sqrt(Math.pow(node.x - mouse.x, 2) + Math.pow(node.y - mouse.y, 2));\n                const mouseInfluence = Math.max(0, 1 - distToMouse / 150);\n\n                // Processing effect with enhanced visuals\n                if (node.processing && Math.random() < 0.15) {\n                    impulses.push({\n                        x: node.x,\n                        y: node.y,\n                        life: 0,\n                        maxLife: 1.5,\n                        connections: [...node.connections],\n                        visited: new Set(),\n                        color: node.color,\n                    });\n                }\n\n                // Enhanced glow effect with multiple layers\n                const glowRadius = currentRadius + mouseInfluence * 15 + (3 - layer) * 3;\n                const gradient = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, glowRadius);\n                const opacity = (0.4 - layer * 0.1) * node.glowIntensity;\n                const opacityHex1 = Math.floor(opacity * 255).toString(16).length === 1 ? '0' + Math.floor(opacity * 255).toString(16) : Math.floor(opacity * 255).toString(16);\n                const opacityHex2 = Math.floor(opacity * 0.3 * 255).toString(16).length === 1 ? '0' + Math.floor(opacity * 0.3 * 255).toString(16) : Math.floor(opacity * 0.3 * 255).toString(16);\n                gradient.addColorStop(0, `${node.color}${opacityHex1}`);\n                gradient.addColorStop(0.4, `${node.color}${opacityHex2}`);\n                gradient.addColorStop(1, 'transparent');\n\n                ctx.beginPath();\n                ctx.arc(node.x, node.y, glowRadius, 0, Math.PI * 2);\n                ctx.fillStyle = gradient;\n                ctx.fill();\n\n                // Main node with enhanced shading\n                ctx.beginPath();\n                ctx.arc(node.x, node.y, currentRadius, 0, Math.PI * 2);\n                const nodeOpacity = Math.floor((0.7 + pulseFactor * 0.3 + mouseInfluence * 0.3) * 255);\n                const nodeOpacityHex = nodeOpacity.toString(16).length === 1 ? '0' + nodeOpacity.toString(16) : nodeOpacity.toString(16);\n                ctx.fillStyle = `${node.color}${nodeOpacityHex}`;\n                ctx.fill();\n\n                // Enhanced inner highlight\n                ctx.beginPath();\n                ctx.arc(node.x - currentRadius * 0.25, node.y - currentRadius * 0.25, currentRadius * 0.4, 0, Math.PI * 2);\n                ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + pulseFactor * 0.2})`;\n                ctx.fill();\n\n                // Enhanced processing indicator\n                if (node.processing) {\n                    ctx.beginPath();\n                    ctx.arc(node.x, node.y, currentRadius + 4, 0, Math.PI * 2);\n                    ctx.strokeStyle = `rgba(255, 215, 0, ${pulseFactor * 0.8})`;\n                    ctx.lineWidth = 2;\n                    ctx.stroke();\n                }\n            });\n        }\n\n        // Draw enhanced impulses\n        impulses.forEach((impulse, index) => {\n            impulse.life += 0.025;\n            if (impulse.life > impulse.maxLife) {\n                impulses.splice(index, 1);\n                return;\n            }\n\n            const alpha = (1 - impulse.life / impulse.maxLife) * 0.9;\n            const radius = impulse.life * 25;\n            \n            // Impulse glow\n            const impulseOpacityHex1 = Math.floor(alpha * 255).toString(16).length === 1 ? '0' + Math.floor(alpha * 255).toString(16) : Math.floor(alpha * 255).toString(16);\n            const impulseOpacityHex2 = Math.floor(alpha * 0.5 * 255).toString(16).length === 1 ? '0' + Math.floor(alpha * 0.5 * 255).toString(16) : Math.floor(alpha * 0.5 * 255).toString(16);\n            const gradient = ctx.createRadialGradient(impulse.x, impulse.y, 0, impulse.x, impulse.y, radius);\n            gradient.addColorStop(0, `${impulse.color}${impulseOpacityHex1}`);\n            gradient.addColorStop(0.5, `${impulse.color}${impulseOpacityHex2}`);\n            gradient.addColorStop(1, 'transparent');\n            \n            ctx.beginPath();\n            ctx.arc(impulse.x, impulse.y, radius, 0, Math.PI * 2);\n            ctx.fillStyle = gradient;\n            ctx.fill();\n        });\n\n        // Draw connections with enhanced energy flow\n        nodes.forEach((node, i) => {\n            node.connections.forEach((connectionIndex: number) => {\n                const connectedNode = nodes[connectionIndex];\n                const dist = Math.sqrt(Math.pow(node.x - connectedNode.x, 2) + Math.pow(node.y - connectedNode.y, 2));\n                \n                if (dist < 180) {\n                    const distToMouse = Math.min(\n                        Math.sqrt(Math.pow(node.x - mouse.x, 2) + Math.pow(node.y - mouse.y, 2)),\n                        Math.sqrt(Math.pow(connectedNode.x - mouse.x, 2) + Math.pow(connectedNode.y - mouse.y, 2))\n                    );\n\n                    let opacity = (1 - dist / 180) * 0.5;\n                    if (distToMouse < 100) {\n                        opacity = Math.min(1, opacity + (1 - distToMouse / 100) * 0.8);\n                    }\n\n                    // Enhanced energy flow effect\n                    const energyFlow = Math.sin(time * 4 + i + connectionIndex) * 0.5 + 0.5;\n                    opacity *= (0.4 + energyFlow * 0.8);\n\n                    // Enhanced gradient line\n                    const connectionOpacityHex1 = Math.floor(opacity * 255).toString(16).length === 1 ? '0' + Math.floor(opacity * 255).toString(16) : Math.floor(opacity * 255).toString(16);\n                    const connectionOpacityHex2 = Math.floor(opacity * 255).toString(16).length === 1 ? '0' + Math.floor(opacity * 255).toString(16) : Math.floor(opacity * 255).toString(16);\n                    const gradient = ctx.createLinearGradient(node.x, node.y, connectedNode.x, connectedNode.y);\n                    gradient.addColorStop(0, `${node.color}${connectionOpacityHex1}`);\n                    gradient.addColorStop(0.3, `rgba(255, 255, 255, ${opacity * 0.8})`);\n                    gradient.addColorStop(0.7, `rgba(255, 255, 255, ${opacity * 0.8})`);\n                    gradient.addColorStop(1, `${connectedNode.color}${connectionOpacityHex2}`);\n\n                    ctx.beginPath();\n                    ctx.moveTo(node.x, node.y);\n                    ctx.lineTo(connectedNode.x, connectedNode.y);\n                    ctx.strokeStyle = gradient;\n                    ctx.lineWidth = 1 + energyFlow * 2.5;\n                    ctx.stroke();\n\n                    // Enhanced energy particles\n                    if (Math.random() < 0.08) {\n                        const t = Math.random();\n                        const x = node.x + (connectedNode.x - node.x) * t;\n                        const y = node.y + (connectedNode.y - node.y) * t;\n                        \n                        ctx.beginPath();\n                        ctx.arc(x, y, 0.8, 0, Math.PI * 2);\n                        ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;\n                        ctx.fill();\n                    }\n                }\n            });\n        });\n    };\n\n    const animate = () => {\n        draw();\n        requestAnimationFrame(animate);\n    };\n\n    window.addEventListener('resize', resizeCanvas);\n    resizeCanvas();\n    animate();\n}\n\n/**\n * Initializes a data flow animation on a canvas.\n */\nfunction initDataFlowBackground() {\n    console.log('initDataFlowBackground called');\n    const canvas = document.getElementById('data-flow-canvas') as HTMLCanvasElement;\n    if (!canvas) {\n        console.error('Data flow canvas not found!');\n        return;\n    }\n    console.log('Data flow canvas found, starting animation...');\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n        console.error('Could not get 2D context for data flow canvas!');\n        return;\n    }\n\n    const mouse = { x: 0, y: 0 };\n    window.addEventListener('mousemove', e => {\n        mouse.x = e.clientX;\n        mouse.y = e.clientY;\n    });\n\n    let particles: any[];\n    let time = 0;\n    let buffer: any[];\n\n    // Enhanced data characters\n    const dataChars = [\n        '01', '10', '11', '00', 'FF', 'AA', '55', 'CC',\n        'AI', 'ML', 'DL', 'NN', 'CV', 'NLP', 'RL', 'GAN',\n        '0x1A', '0x2B', '0x3C', '0x4D', '0x5E', '0x6F',\n        'GET', 'POST', 'PUT', 'DEL', 'HTTP', 'JSON', 'XML',\n        'SQL', 'API', 'REST', 'WS', 'TCP', 'UDP', 'SSL',\n        'GPU', 'CPU', 'RAM', 'SSD', 'NVMe', 'PCIe'\n    ];\n\n    const resizeCanvas = () => {\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n\n        particles = [];\n        const particleCount = 600;\n        for (let i = 0; i < particleCount; i++) {\n            const isSymbol = Math.random() < 0.45;\n            particles.push({\n                x: Math.random() * canvas.width,\n                y: Math.random() * canvas.height,\n                speed: Math.random() * 2 + 0.5,\n                size: Math.random() * 2 + 1,\n                length: Math.random() * 30 + 20,\n                opacity: Math.random() * 0.8 + 0.2,\n                type: isSymbol ? 'symbol' : 'line',\n                symbol: dataChars[Math.floor(Math.random() * dataChars.length)],\n                color: Math.random() > 0.5 ? '#FF6B6B' : '#4ECDC4',\n                pulse: Math.random() * Math.PI,\n                waveOffset: Math.random() * Math.PI * 2,\n                corruption: Math.random() > 0.97,\n                bufferDelay: Math.random() * 100,\n                originalSymbol: '',\n                glowIntensity: Math.random() * 0.5 + 0.5,\n            });\n        }\n\n        // Initialize enhanced buffer\n        buffer = [];\n        for (let i = 0; i < 30; i++) {\n            buffer.push({\n                x: Math.random() * canvas.width,\n                y: canvas.height + Math.random() * 80,\n                symbol: dataChars[Math.floor(Math.random() * dataChars.length)],\n                delay: Math.random() * 300,\n                color: Math.random() > 0.5 ? '#FF6B6B' : '#4ECDC4',\n            });\n        }\n    };\n\n    const draw = () => {\n        if (!ctx) return;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        time += 0.02;\n        \n        // Draw enhanced buffer effects\n        buffer.forEach(buff => {\n            buff.delay--;\n            if (buff.delay <= 0) {\n                buff.y -= 0.8;\n                ctx.font = '14px monospace';\n                ctx.fillStyle = `${buff.color}50`;\n                ctx.textAlign = 'center';\n                ctx.fillText(buff.symbol, buff.x, buff.y);\n            }\n        });\n\n        particles.forEach(p => {\n            p.y -= p.speed;\n            p.pulse += 0.04;\n            \n            // Enhanced wave effect with physics\n            const wave = Math.sin(time + p.waveOffset) * 2;\n            p.x += wave * 0.08;\n            \n            // Add enhanced randomness for realism\n            p.x += (Math.random() - 0.5) * 0.3;\n            \n            if (p.y < -p.length) {\n                p.y = canvas.height + p.length;\n                p.x = Math.random() * canvas.width;\n                p.corruption = Math.random() > 0.97;\n                p.originalSymbol = p.symbol;\n                if (p.corruption) {\n                    p.symbol = 'ERR';\n                }\n            }\n\n            // Enhanced mouse interaction with realistic physics\n            const distToMouse = Math.sqrt(Math.pow(p.x - mouse.x, 2) + Math.pow(p.y - mouse.y, 2));\n            const mouseInfluence = Math.max(0, 1 - distToMouse / 100);\n            \n            // Enhanced opacity with realistic falloff\n            const enhancedOpacity = p.opacity + mouseInfluence * 0.6;\n            const pulseFactor = (Math.sin(p.pulse) + 1) / 2;\n            const finalOpacity = enhancedOpacity * (0.7 + pulseFactor * 0.4) * p.glowIntensity;\n\n            if (p.type === 'line') {\n                // Draw enhanced line with sophisticated gradient\n                const lineOpacityHex = Math.floor(finalOpacity * 255).toString(16).length === 1 ? '0' + Math.floor(finalOpacity * 255).toString(16) : Math.floor(finalOpacity * 255).toString(16);\n                const gradient = ctx.createLinearGradient(p.x, p.y, p.x, p.y - p.length);\n                gradient.addColorStop(0, `${p.color}${lineOpacityHex}`);\n                gradient.addColorStop(0.2, `rgba(255, 255, 255, ${finalOpacity * 0.9})`);\n                gradient.addColorStop(0.5, `rgba(255, 255, 255, ${finalOpacity})`);\n                gradient.addColorStop(0.8, `rgba(255, 255, 255, ${finalOpacity * 0.9})`);\n                gradient.addColorStop(1, `${p.color}${lineOpacityHex}`);\n                \n                ctx.beginPath();\n                ctx.moveTo(p.x, p.y);\n                ctx.lineTo(p.x, p.y - p.length);\n                ctx.strokeStyle = gradient;\n                ctx.lineWidth = p.size + mouseInfluence * 2.5;\n                ctx.stroke();\n\n                // Enhanced glow effect\n                if (mouseInfluence > 0.2) {\n                    ctx.beginPath();\n                    ctx.moveTo(p.x, p.y);\n                    ctx.lineTo(p.x, p.y - p.length);\n                    ctx.strokeStyle = `rgba(255, 255, 255, ${mouseInfluence * 0.6})`;\n                    ctx.lineWidth = p.size + mouseInfluence * 4;\n                    ctx.stroke();\n                }\n            } else {\n                // Draw symbol with enhanced font\n                ctx.font = `${p.size * 3}px 'Courier New', monospace`;\n                const symbolOpacityHex = Math.floor(finalOpacity * 255).toString(16).length === 1 ? '0' + Math.floor(finalOpacity * 255).toString(16) : Math.floor(finalOpacity * 255).toString(16);\n                \n                // Enhanced corruption effect\n                if (p.corruption) {\n                    ctx.fillStyle = `rgba(255, 0, 0, ${finalOpacity})`;\n                } else {\n                    ctx.fillStyle = `${p.color}${symbolOpacityHex}`;\n                }\n                \n                ctx.textAlign = 'center';\n                ctx.fillText(p.symbol, p.x, p.y);\n                \n                // Enhanced glow for symbols\n                if (mouseInfluence > 0.3) {\n                    ctx.font = `${p.size * 3}px 'Courier New', monospace`;\n                    ctx.fillStyle = `rgba(255, 255, 255, ${mouseInfluence * 0.8})`;\n                    ctx.fillText(p.symbol, p.x, p.y);\n                }\n            }\n\n            // Enhanced speed variation\n            if (mouseInfluence > 0.4) {\n                p.speed = Math.min(p.speed * 1.08, 4);\n            } else {\n                p.speed = Math.max(p.speed * 0.998, 0.3);\n            }\n        });\n\n        // Enhanced data corruption and repair effects\n        if (Math.random() < 0.03) {\n            const corruptX = Math.random() * canvas.width;\n            const corruptY = Math.random() * canvas.height;\n            \n            // Corruption glow\n            const gradient = ctx.createRadialGradient(corruptX, corruptY, 0, corruptX, corruptY, 8);\n            gradient.addColorStop(0, 'rgba(255, 0, 0, 0.8)');\n            gradient.addColorStop(0.5, 'rgba(255, 0, 0, 0.4)');\n            gradient.addColorStop(1, 'transparent');\n            \n            ctx.beginPath();\n            ctx.arc(corruptX, corruptY, 8, 0, Math.PI * 2);\n            ctx.fillStyle = gradient;\n            ctx.fill();\n            \n            ctx.font = '12px monospace';\n            ctx.fillStyle = 'rgba(255, 0, 0, 0.9)';\n            ctx.textAlign = 'center';\n            ctx.fillText('ERR', corruptX, corruptY + 18);\n        }\n\n        // Enhanced data packets\n        if (Math.random() < 0.015) {\n            const packetX = Math.random() * canvas.width;\n            const packetY = canvas.height;\n            \n            // Packet glow\n            const gradient = ctx.createRadialGradient(packetX, packetY, 0, packetX, packetY, 6);\n            gradient.addColorStop(0, 'rgba(0, 255, 0, 0.9)');\n            gradient.addColorStop(0.5, 'rgba(0, 255, 0, 0.5)');\n            gradient.addColorStop(1, 'transparent');\n            \n            ctx.beginPath();\n            ctx.arc(packetX, packetY, 6, 0, Math.PI * 2);\n            ctx.fillStyle = gradient;\n            ctx.fill();\n            \n            ctx.font = '10px monospace';\n            ctx.fillStyle = 'rgba(0, 255, 0, 0.9)';\n            ctx.textAlign = 'center';\n            ctx.fillText('PKT', packetX, packetY + 12);\n        }\n\n        // Add occasional data streams\n        if (Math.random() < 0.01) {\n            const streamX = Math.random() * canvas.width;\n            for (let i = 0; i < 10; i++) {\n                ctx.beginPath();\n                ctx.arc(streamX + (Math.random() - 0.5) * 20, canvas.height - i * 10, 1, 0, Math.PI * 2);\n                ctx.fillStyle = `rgba(255, 255, 255, ${0.8 - i * 0.08})`;\n                ctx.fill();\n            }\n        }\n    };\n\n    const animate = () => {\n        draw();\n        requestAnimationFrame(animate);\n    };\n\n    window.addEventListener('resize', resizeCanvas);\n    resizeCanvas();\n    animate();\n}\n\n/**\n * Initializes a projects development animation on a canvas.\n */\nfunction initProjectsBackground() {\n    console.log('initProjectsBackground called');\n    const canvas = document.getElementById('projects-canvas') as HTMLCanvasElement;\n    if (!canvas) {\n        console.error('Projects canvas not found!');\n        return;\n    }\n    console.log('Projects canvas found, starting animation...');\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n        console.error('Could not get 2D context for projects canvas!');\n        return;\n    }\n\n    const mouse = { x: 0, y: 0 };\n    window.addEventListener('mousemove', e => {\n        mouse.x = e.clientX;\n        mouse.y = e.clientY;\n    });\n\n    let codeLines: any[];\n    let commits: any[];\n    let repositories: any[];\n    let files: any[];\n    let time = 0;\n\n    // Enhanced code snippets for variety\n    const codeSnippets = [\n        'function init() {',\n        '  const data = [];',\n        '  return data;',\n        '}',\n        'class Project {',\n        '  constructor() {',\n        '    this.name = \"\";',\n        '  }',\n        '}',\n        'const api = {',\n        '  get: async () => {',\n        '    return fetch(url);',\n        '  }',\n        '};',\n        'if (condition) {',\n        '  doSomething();',\n        '}',\n        'for (let i = 0; i < n; i++) {',\n        '  process(i);',\n        '}',\n        'try {',\n        '  await operation();',\n        '} catch (error) {',\n        '  console.log(error);',\n        '}',\n        'const Component = () => {',\n        '  return <div>Hello</div>;',\n        '};',\n        'export default App;',\n        'import React from \"react\";',\n        'useEffect(() => {',\n        '  // Effect logic',\n        '}, []);'\n    ];\n\n    const fileNames = [\n        'index.js', 'app.ts', 'style.css', 'README.md',\n        'package.json', 'config.js', 'utils.js', 'api.js',\n        'components.jsx', 'hooks.js', 'store.js', 'router.js',\n        'types.ts', 'constants.js', 'helpers.js', 'services.js'\n    ];\n\n    const resizeCanvas = () => {\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n\n        // Initialize enhanced code lines\n        codeLines = [];\n        const lineCount = 18;\n        for (let i = 0; i < lineCount; i++) {\n            codeLines.push({\n                x: Math.random() * canvas.width,\n                y: Math.random() * canvas.height,\n                text: codeSnippets[Math.floor(Math.random() * codeSnippets.length)],\n                opacity: Math.random() * 0.7 + 0.2,\n                speed: Math.random() * 0.6 + 0.3,\n                typingProgress: 0,\n                maxTypingProgress: codeSnippets[Math.floor(Math.random() * codeSnippets.length)].length,\n                color: Math.random() > 0.5 ? '#FF6B6B' : '#4ECDC4',\n                fontSize: Math.random() * 4 + 12,\n                glowIntensity: Math.random() * 0.5 + 0.5,\n                syntaxType: Math.random() > 0.5 ? 'function' : 'variable',\n            });\n        }\n\n        // Initialize enhanced commits\n        commits = [];\n        const commitCount = 12;\n        for (let i = 0; i < commitCount; i++) {\n            commits.push({\n                x: Math.random() * canvas.width,\n                y: Math.random() * canvas.height,\n                message: `commit ${Math.random().toString(16).substr(2, 7)}`,\n                life: 0,\n                maxLife: Math.random() * 2.5 + 1.5,\n                size: Math.random() * 2.5 + 1.5,\n                vx: (Math.random() - 0.5) * 2.5,\n                vy: (Math.random() - 0.5) * 2.5,\n                color: Math.random() > 0.5 ? '#FFE66D' : '#FF6B9D',\n                glowIntensity: Math.random() * 0.5 + 0.5,\n            });\n        }\n\n        // Initialize enhanced repositories\n        repositories = [];\n        const repoCount = 8;\n        for (let i = 0; i < repoCount; i++) {\n            repositories.push({\n                x: Math.random() * canvas.width,\n                y: Math.random() * canvas.height,\n                name: `repo-${i + 1}`,\n                size: Math.random() * 25 + 20,\n                pulse: Math.random() * Math.PI,\n                connections: [],\n                files: Math.floor(Math.random() * 15) + 8,\n                color: Math.random() > 0.5 ? '#FF6B6B' : '#4ECDC4',\n                glowIntensity: Math.random() * 0.5 + 0.5,\n                activity: Math.random() > 0.6,\n            });\n        }\n\n        // Create enhanced connections between repositories\n        repositories.forEach((repo, i) => {\n            repositories.forEach((otherRepo, j) => {\n                if (i !== j && Math.random() > 0.6) {\n                    repo.connections.push(j);\n                }\n            });\n        });\n\n        // Initialize enhanced files\n        files = [];\n        const fileCount = 25;\n        for (let i = 0; i < fileCount; i++) {\n            files.push({\n                x: Math.random() * canvas.width,\n                y: Math.random() * canvas.height,\n                name: fileNames[Math.floor(Math.random() * fileNames.length)],\n                size: Math.random() * 4 + 1.5,\n                opacity: Math.random() * 0.6 + 0.3,\n                vx: (Math.random() - 0.5) * 1.5,\n                vy: (Math.random() - 0.5) * 1.5,\n                modified: Math.random() > 0.85,\n                targetRepo: Math.floor(Math.random() * repositories.length),\n                color: Math.random() > 0.5 ? '#FF6B6B' : '#4ECDC4',\n                glowIntensity: Math.random() * 0.5 + 0.5,\n            });\n        }\n    };\n\n    const draw = () => {\n        if (!ctx) return;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        time += 0.025;\n\n        // Draw enhanced repositories\n        repositories.forEach((repo, i) => {\n            repo.pulse += 0.025;\n            const pulseFactor = (Math.sin(repo.pulse) + 1) / 2;\n\n            // Enhanced repository glow\n            const glowRadius = repo.size + pulseFactor * 15;\n            const gradient = ctx.createRadialGradient(repo.x, repo.y, 0, repo.x, repo.y, glowRadius);\n            const opacity = (0.4 - i * 0.05) * repo.glowIntensity;\n            const opacityHex1 = Math.floor(opacity * 255).toString(16).length === 1 ? '0' + Math.floor(opacity * 255).toString(16) : Math.floor(opacity * 255).toString(16);\n            const opacityHex2 = Math.floor(opacity * 0.3 * 255).toString(16).length === 1 ? '0' + Math.floor(opacity * 0.3 * 255).toString(16) : Math.floor(opacity * 0.3 * 255).toString(16);\n            gradient.addColorStop(0, `${repo.color}${opacityHex1}`);\n            gradient.addColorStop(0.4, `${repo.color}${opacityHex2}`);\n            gradient.addColorStop(1, 'transparent');\n            \n            ctx.beginPath();\n            ctx.arc(repo.x, repo.y, glowRadius, 0, Math.PI * 2);\n            ctx.fillStyle = gradient;\n            ctx.fill();\n            \n            // Enhanced repository main circle\n            ctx.beginPath();\n            ctx.arc(repo.x, repo.y, repo.size, 0, Math.PI * 2);\n            const repoOpacity = Math.floor((0.7 + pulseFactor * 0.3) * 255);\n            const repoOpacityHex = repoOpacity.toString(16).length === 1 ? '0' + repoOpacity.toString(16) : repoOpacity.toString(16);\n            ctx.fillStyle = `${repo.color}${repoOpacityHex}`;\n            ctx.fill();\n\n            // Enhanced inner highlight\n            ctx.beginPath();\n            ctx.arc(repo.x - repo.size * 0.25, repo.y - repo.size * 0.25, repo.size * 0.4, 0, Math.PI * 2);\n            ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + pulseFactor * 0.2})`;\n            ctx.fill();\n\n            // Enhanced repository name\n            ctx.font = '14px monospace';\n            ctx.fillStyle = `rgba(255, 255, 255, ${0.9 + pulseFactor * 0.1})`;\n            ctx.textAlign = 'center';\n            ctx.fillText(repo.name, repo.x, repo.y + 5);\n\n            // Enhanced file count\n            ctx.font = '11px monospace';\n            ctx.fillStyle = `rgba(255, 255, 255, ${0.7 + pulseFactor * 0.2})`;\n            ctx.fillText(`${repo.files} files`, repo.x, repo.y + 20);\n\n            // Activity indicator\n            if (repo.activity) {\n                ctx.beginPath();\n                ctx.arc(repo.x + repo.size + 3, repo.y - repo.size + 3, 3, 0, Math.PI * 2);\n                ctx.fillStyle = `rgba(0, 255, 0, ${pulseFactor * 0.8})`;\n                ctx.fill();\n            }\n        });\n\n        // Draw enhanced repository connections\n        repositories.forEach((repo, i) => {\n            repo.connections.forEach((connectionIndex: number) => {\n                const connectedRepo = repositories[connectionIndex];\n                const dist = Math.sqrt(Math.pow(repo.x - connectedRepo.x, 2) + Math.pow(repo.y - connectedRepo.y, 2));\n                \n                if (dist < 250) {\n                    const opacity = (1 - dist / 250) * 0.4;\n                    const energyFlow = Math.sin(time * 3 + i + connectionIndex) * 0.5 + 0.5;\n                    \n                    ctx.beginPath();\n                    ctx.moveTo(repo.x, repo.y);\n                    ctx.lineTo(connectedRepo.x, connectedRepo.y);\n                    ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * energyFlow})`;\n                    ctx.lineWidth = 1 + energyFlow * 2;\n                    ctx.stroke();\n                }\n            });\n        });\n\n        // Draw enhanced files\n        files.forEach(file => {\n            file.x += file.vx;\n            file.y += file.vy;\n\n            if (file.x < 0 || file.x > canvas.width) file.vx *= -1;\n            if (file.y < 0 || file.y > canvas.height) file.vy *= -1;\n\n            // Enhanced file icon with glow\n            const fileGlowRadius = file.size + 2;\n            const fileGradient = ctx.createRadialGradient(file.x, file.y, 0, file.x, file.y, fileGlowRadius);\n            const fileOpacity = file.modified ? 0.8 : file.opacity;\n            const fileOpacityHex = Math.floor(fileOpacity * 255).toString(16).length === 1 ? '0' + Math.floor(fileOpacity * 255).toString(16) : Math.floor(fileOpacity * 255).toString(16);\n            fileGradient.addColorStop(0, `${file.color}${fileOpacityHex}`);\n            fileGradient.addColorStop(1, 'transparent');\n            \n            ctx.beginPath();\n            ctx.arc(file.x, file.y, fileGlowRadius, 0, Math.PI * 2);\n            ctx.fillStyle = fileGradient;\n            ctx.fill();\n\n            // Main file icon\n            ctx.beginPath();\n            ctx.rect(file.x - file.size, file.y - file.size, file.size * 2, file.size * 2);\n            ctx.fillStyle = file.modified ? \n                `rgba(255, 165, 0, ${file.opacity})` : \n                `rgba(255, 255, 255, ${file.opacity})`;\n            ctx.fill();\n\n            // Enhanced file name\n            ctx.font = '9px monospace';\n            ctx.fillStyle = `rgba(255, 255, 255, ${file.opacity})`;\n            ctx.textAlign = 'center';\n            ctx.fillText(file.name, file.x, file.y + file.size + 10);\n\n            // Enhanced modified indicator\n            if (file.modified) {\n                ctx.beginPath();\n                ctx.arc(file.x + file.size, file.y - file.size, 3, 0, Math.PI * 2);\n                ctx.fillStyle = 'rgba(255, 0, 0, 0.9)';\n                ctx.fill();\n            }\n        });\n\n        // Draw enhanced code lines with typing effect\n        codeLines.forEach(line => {\n            line.typingProgress += line.speed;\n            if (line.typingProgress > line.maxTypingProgress) {\n                line.typingProgress = 0;\n                line.text = codeSnippets[Math.floor(Math.random() * codeSnippets.length)];\n                line.maxTypingProgress = line.text.length;\n                line.syntaxType = Math.random() > 0.5 ? 'function' : 'variable';\n            }\n\n            const displayText = line.text.substring(0, Math.floor(line.typingProgress));\n            const cursor = line.typingProgress < line.maxTypingProgress ? '|' : '';\n\n            ctx.font = `${line.fontSize}px 'Courier New', monospace`;\n            const lineOpacityHex = Math.floor(line.opacity * 255).toString(16).length === 1 ? '0' + Math.floor(line.opacity * 255).toString(16) : Math.floor(line.opacity * 255).toString(16);\n            \n            // Enhanced syntax highlighting\n            if (line.syntaxType === 'function' && (displayText.includes('function') || displayText.includes('class') || displayText.includes('const') || displayText.includes('import'))) {\n                ctx.fillStyle = `rgba(255, 215, 0, ${line.opacity})`;\n            } else {\n                ctx.fillStyle = `${line.color}${lineOpacityHex}`;\n            }\n            \n            ctx.textAlign = 'left';\n            ctx.fillText(displayText + cursor, line.x, line.y);\n\n            // Enhanced glow effect for active typing\n            if (line.typingProgress < line.maxTypingProgress) {\n                ctx.fillStyle = `rgba(255, 255, 255, ${line.opacity * 0.6})`;\n                ctx.fillText(displayText + cursor, line.x, line.y);\n            }\n        });\n\n        // Draw enhanced commits\n        commits.forEach((commit, index) => {\n            commit.life += 0.015;\n            commit.x += commit.vx;\n            commit.y += commit.vy;\n\n            if (commit.life > commit.maxLife) {\n                commit.life = 0;\n                commit.x = Math.random() * canvas.width;\n                commit.y = Math.random() * canvas.height;\n                commit.message = `commit ${Math.random().toString(16).substr(2, 7)}`;\n            }\n\n            const alpha = (1 - commit.life / commit.maxLife) * 0.8;\n            \n            // Enhanced commit glow\n            const commitGlowRadius = commit.size + 3;\n            const commitGradient = ctx.createRadialGradient(commit.x, commit.y, 0, commit.x, commit.y, commitGlowRadius);\n            const commitOpacityHex = Math.floor(alpha * 255).toString(16).length === 1 ? '0' + Math.floor(alpha * 255).toString(16) : Math.floor(alpha * 255).toString(16);\n            commitGradient.addColorStop(0, `${commit.color}${commitOpacityHex}`);\n            commitGradient.addColorStop(1, 'transparent');\n            \n            ctx.beginPath();\n            ctx.arc(commit.x, commit.y, commitGlowRadius, 0, Math.PI * 2);\n            ctx.fillStyle = commitGradient;\n            ctx.fill();\n            \n            // Main commit circle\n            ctx.beginPath();\n            ctx.arc(commit.x, commit.y, commit.size, 0, Math.PI * 2);\n            ctx.fillStyle = `rgba(0, 255, 0, ${alpha})`;\n            ctx.fill();\n\n            // Enhanced commit message\n            ctx.font = '11px monospace';\n            ctx.fillStyle = `rgba(0, 255, 0, ${alpha})`;\n            ctx.textAlign = 'center';\n            ctx.fillText(commit.message, commit.x, commit.y + commit.size + 12);\n        });\n\n        // Add enhanced occasional new commits\n        if (Math.random() < 0.025) {\n            const newCommit = {\n                x: Math.random() * canvas.width,\n                y: canvas.height,\n                message: `commit ${Math.random().toString(16).substr(2, 7)}`,\n                life: 0,\n                maxLife: 2.5,\n                size: 2.5,\n                vx: (Math.random() - 0.5) * 2.5,\n                vy: -1.5,\n                color: Math.random() > 0.5 ? '#FFE66D' : '#FF6B9D',\n                glowIntensity: Math.random() * 0.5 + 0.5,\n            };\n            commits.push(newCommit);\n        }\n\n        // Add enhanced occasional file modifications\n        if (Math.random() < 0.015) {\n            const randomFile = files[Math.floor(Math.random() * files.length)];\n            randomFile.modified = true;\n            setTimeout(() => {\n                randomFile.modified = false;\n            }, 4000);\n        }\n    };\n\n    const animate = () => {\n        draw();\n        requestAnimationFrame(animate);\n    };\n\n    window.addEventListener('resize', resizeCanvas);\n    resizeCanvas();\n    animate();\n}\n\n// Main initialization\ndocument.addEventListener('DOMContentLoaded', () => {\n    console.log('DOM Content Loaded - Starting initialization...');\n    \n    // Staggered fall-in animation for keyboard keys\n    const keys = document.querySelectorAll('.key');\n    keys.forEach((key, index) => {\n        (key as HTMLElement).style.animationDelay = `${index * 0.05}s`;\n    });\n\n    // Page-specific initializations\n    const neuralCanvas = document.getElementById('neural-network-canvas');\n    const dataFlowCanvas = document.getElementById('data-flow-canvas');\n    const projectsCanvas = document.getElementById('projects-canvas');\n    \n    console.log('Canvas elements found:', {\n        neural: !!neuralCanvas,\n        dataFlow: !!dataFlowCanvas,\n        projects: !!projectsCanvas\n    });\n    \n    if (neuralCanvas) {\n        console.log('Initializing neural network background...');\n        initNeuralNetworkBackground();\n    }\n    if (dataFlowCanvas) {\n        console.log('Initializing data flow background...');\n        initDataFlowBackground();\n    }\n    if (projectsCanvas) {\n        console.log('Initializing projects background...');\n        initProjectsBackground();\n    }\n\n    initTooltips();\n    initHamburgerMenu();\n    initScrollToTop();\n    initTimelineAnimation();\n\n    // Funzioni comuni a tutte le pagine\n    initNavbarActiveLink();\n    initNavbarScroll();\n\n    // Funzioni specifiche per pagina\n    if (window.location.pathname.includes('about.html')) {\n        initTimelineAnimation();\n    }\n    if (window.location.pathname.includes('projects.html')) {\n        // Projects page specific initialization\n    }\n    \n    console.log('Initialization complete!');\n});\n\n// Add CSS animations via JavaScript\nconst style = document.createElement('style');\nstyle.textContent = `\n    .navbar.scrolled {\n        background: rgba(16, 37, 66, 0.95) !important;\n        box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1) !important;\n    }\n    \n    .animate {\n        animation: fadeInUp 0.8s ease forwards;\n    }\n    \n    @keyframes fadeInUp {\n        from {\n            opacity: 0;\n            transform: translateY(30px);\n        }\n        to {\n            opacity: 1;\n            transform: translateY(0);\n        }\n    }\n    \n    .skill-card, .project-card {\n        opacity: 0;\n        transform: translateY(30px);\n        transition: all 0.6s ease;\n    }\n    \n    .skill-card.animate, .project-card.animate {\n        opacity: 1;\n        transform: translateY(0);\n    }\n    \n    .notification-content {\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n        gap: 1rem;\n    }\n    \n    .notification-close {\n        background: none;\n        border: none;\n        color: white;\n        font-size: 1.5rem;\n        cursor: pointer;\n        padding: 0;\n        width: 24px;\n        height: 24px;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n    }\n    \n    .nav-link.active {\n        color: #F87060 !important;\n    }\n    \n    .nav-link.active::after {\n        width: 100% !important;\n    }\n`;\n\ndocument.head.appendChild(style);","import { rectToClientRect, arrow as arrow$1, autoPlacement as autoPlacement$1, detectOverflow as detectOverflow$1, flip as flip$1, hide as hide$1, inline as inline$1, limitShift as limitShift$1, offset as offset$1, shift as shift$1, size as size$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getFrameElement, getNodeScroll, getDocumentElement, isTopLayer, getNodeName, isOverflowElement, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\n\nfunction getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {\n  if (ignoreScrollbarX === void 0) {\n    ignoreScrollbarX = false;\n  }\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 :\n  // RTL <body> scrollbar.\n  getWindowScrollBarX(documentElement, htmlRect));\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nconst absoluteOrFixed = /*#__PURE__*/new Set(['absolute', 'fixed']);\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n\n  // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n  // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n  function setLeftRTLScrollbarOffset() {\n    offsets.x = getWindowScrollBarX(documentElement);\n  }\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      setLeftRTLScrollbarOffset();\n    }\n  }\n  if (isFixed && !isOffsetParentAnElement && documentElement) {\n    setLeftRTLScrollbarOffset();\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n\n  // Firefox returns the <html> element as the offsetParent if it's non-static,\n  // while Chrome and Safari return the <body> element. The <body> element must\n  // be used to perform the correct calculations even if the <html> element is\n  // non-static.\n  if (getDocumentElement(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\nfunction rectsAreEqual(a, b) {\n  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n}\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = elementRectForRootMargin;\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n        // It's possible that even though the ratio is reported as 1, the\n        // element is not actually fully within the IntersectionObserver's root\n        // area anymore. This can happen under performance constraints. This may\n        // be a bug in the browser's IntersectionObserver implementation. To\n        // work around this, we compare the element's bounding rect now with\n        // what it was at the time we created the IntersectionObserver. If they\n        // are not equal then the element moved, so we refresh.\n        refresh();\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (_e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          const ignoreCrossAxisOverflow = checkCrossAxis === 'alignment' ? initialSideAxis !== getSideAxis(nextPlacement) : false;\n          if (!ignoreCrossAxisOverflow ||\n          // We leave the current main axis only if every placement on that axis\n          // overflows the main axis.\n          overflowsData.every(d => d.overflows[0] > 0 && getSideAxis(d.placement) === initialSideAxis)) {\n            // Try next placement and re-run the lifecycle.\n            return {\n              data: {\n                index: nextIndex,\n                overflows: overflowsData\n              },\n              reset: {\n                placement: nextPlacement\n              }\n            };\n          }\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nconst originSides = /*#__PURE__*/new Set(['left', 'top']);\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = originSides.has(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = originSides.has(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n        availableWidth = maximumClippingWidth;\n      }\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nconst yAxisSides = /*#__PURE__*/new Set(['top', 'bottom']);\nfunction getSideAxis(placement) {\n  return yAxisSides.has(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nconst lrPlacement = ['left', 'right'];\nconst rlPlacement = ['right', 'left'];\nconst tbPlacement = ['top', 'bottom'];\nconst btPlacement = ['bottom', 'top'];\nfunction getSideList(side, isStart, rtl) {\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rlPlacement : lrPlacement;\n      return isStart ? lrPlacement : rlPlacement;\n    case 'left':\n    case 'right':\n      return isStart ? tbPlacement : btPlacement;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","function hasWindow() {\n  return typeof window !== 'undefined';\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nconst invalidOverflowDisplayValues = /*#__PURE__*/new Set(['inline', 'contents']);\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);\n}\nconst tableElements = /*#__PURE__*/new Set(['table', 'td', 'th']);\nfunction isTableElement(element) {\n  return tableElements.has(getNodeName(element));\n}\nconst topLayerSelectors = [':popover-open', ':modal'];\nfunction isTopLayer(element) {\n  return topLayerSelectors.some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (_e) {\n      return false;\n    }\n  });\n}\nconst transformProperties = ['transform', 'translate', 'scale', 'rotate', 'perspective'];\nconst willChangeValues = ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'];\nconst containValues = ['paint', 'layout', 'strict', 'content'];\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  // https://drafts.csswg.org/css-transforms-2/#individual-transforms\n  return transformProperties.some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || willChangeValues.some(value => (css.willChange || '').includes(value)) || containValues.some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nconst lastTraversableNodeNames = /*#__PURE__*/new Set(['html', 'body', '#document']);\nfunction isLastTraversableNode(node) {\n  return lastTraversableNodeNames.has(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getFrameElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\n"],"names":["$10310cf078d13212$export$96ec731ed4dcb222","Math","min","$10310cf078d13212$export$8960430cfd85939f","max","$10310cf078d13212$export$2077e0241d6afd3c","round","$10310cf078d13212$export$a397704b5e280835","v","x","y","$10310cf078d13212$var$oppositeSideMap","left","right","bottom","top","$10310cf078d13212$var$oppositeAlignmentMap","start","end","$10310cf078d13212$export$fef61f332f2c0afc","value","param","$10310cf078d13212$export$3c915306cb7fc97a","placement","split","$10310cf078d13212$export$f0989780f32bfcda","$10310cf078d13212$export$8a000a963141ac32","axis","$10310cf078d13212$export$320bd9d53520c68a","$10310cf078d13212$var$yAxisSides","Set","$10310cf078d13212$export$f28e8f882010718a","has","$10310cf078d13212$export$2b182c584985588b","replace","alignment","$10310cf078d13212$var$lrPlacement","$10310cf078d13212$var$rlPlacement","$10310cf078d13212$var$tbPlacement","$10310cf078d13212$var$btPlacement","$10310cf078d13212$export$9c5e28bad23365fa","side","$10310cf078d13212$export$ee05aea0aeecbad4","rect","width","height","$973e4da43f2a375d$var$computeCoordsFromPlacement","_ref","rtl","coords","reference","floating","sideAxis","alignmentAxis","alignLength","isVertical","commonX","commonY","commonAlign","$973e4da43f2a375d$export$48a53dcb22e581d0","config","strategy","middleware","platform","validMiddleware","filter","Boolean","isRTL","rects","getElementRects","statefulPlacement","middlewareData","resetCount","i","length","name","fn","nextX","nextY","data","reset","initialPlacement","elements","$973e4da43f2a375d$export$37b6bde19b108ecc","state","options","_await$platform$isEle","padding","boundary","rootBoundary","elementContext","altBoundary","paddingObject","element","clippingClientRect","getClippingRect","isElement","contextElement","getDocumentElement","offsetParent","getOffsetParent","offsetScale","getScale","elementClientRect","convertOffsetParentRelativeRectToViewportRelativeRect","$973e4da43f2a375d$var$originSides","$973e4da43f2a375d$var$convertValueToCoords","mainAxisMulti","crossAxisMulti","rawValue","mainAxis","crossAxis","$238ac70369f38756$var$hasWindow","window","$238ac70369f38756$export$651544f548703224","node","$238ac70369f38756$export$8ee0fc9ee280b4ee","nodeName","toLowerCase","$238ac70369f38756$export$38b2d434cce3ea22","_node$ownerDocument","ownerDocument","defaultView","$238ac70369f38756$export$e495491855dc5418","document","documentElement","Node","$238ac70369f38756$export$45a5e7f76e0caa8d","Element","$238ac70369f38756$export$1b3bfaa9684536aa","HTMLElement","$238ac70369f38756$export$af51f0f06c0f328a","ShadowRoot","$238ac70369f38756$var$invalidOverflowDisplayValues","$238ac70369f38756$export$989e911fa9af580a","overflow","overflowX","overflowY","display","$238ac70369f38756$export$3735103072e4a80","test","$238ac70369f38756$var$tableElements","$238ac70369f38756$var$topLayerSelectors","$238ac70369f38756$export$89e651af02346cd4","some","selector","matches","_e","$238ac70369f38756$var$transformProperties","$238ac70369f38756$var$willChangeValues","$238ac70369f38756$var$containValues","$238ac70369f38756$export$d6c4e8150c35fed1","elementOrCss","webkit","$238ac70369f38756$export$78551043582a6a98","css","containerType","backdropFilter","willChange","includes","contain","CSS","supports","$238ac70369f38756$var$lastTraversableNodeNames","$238ac70369f38756$export$d1162fb0b6d4cd51","getComputedStyle","$238ac70369f38756$export$dc8fc79fa2800137","scrollLeft","scrollTop","scrollX","scrollY","$238ac70369f38756$export$4e12058fc4d51d56","result","assignedSlot","parentNode","host","$238ac70369f38756$export$7bf1f8740e3e34af","win","parent","Object","getPrototypeOf","frameElement","$461947879dcdbcd4$var$getCssDimensions","parseFloat","hasOffset","offsetWidth","offsetHeight","shouldFallback","$","$461947879dcdbcd4$var$unwrapElement","$461947879dcdbcd4$var$getScale","domElement","getBoundingClientRect","Number","isFinite","$461947879dcdbcd4$var$noOffsets","$461947879dcdbcd4$var$getVisualOffsets","visualViewport","offsetLeft","offsetTop","$461947879dcdbcd4$var$getBoundingClientRect","includeScale","isFixedStrategy","isFixed","clientRect","scale","visualOffsets","$461947879dcdbcd4$var$shouldAddVisualOffsets","floatingOffsetParent","offsetWin","currentWin","currentIFrame","iframeScale","iframeRect","clientLeft","paddingLeft","clientTop","paddingTop","$461947879dcdbcd4$var$getWindowScrollBarX","leftScroll","$461947879dcdbcd4$var$getHTMLOffset","scroll","ignoreScrollbarX","htmlRect","$461947879dcdbcd4$var$absoluteOrFixed","$461947879dcdbcd4$var$getClientRectFromClippingAncestor","clippingAncestor","$461947879dcdbcd4$var$getViewportRect","html","clientWidth","clientHeight","visualViewportBased","$461947879dcdbcd4$var$getDocumentRect","body","scrollWidth","scrollHeight","direction","$461947879dcdbcd4$var$getInnerBoundingClientRect","$461947879dcdbcd4$var$isStaticPositioned","position","$461947879dcdbcd4$var$getTrueOffsetParent","polyfill","rawOffsetParent","$461947879dcdbcd4$var$getOffsetParent","svgOffsetParent","currentNode","$461947879dcdbcd4$var$getElementRects","getOffsetParentFn","getDimensionsFn","getDimensions","floatingDimensions","$461947879dcdbcd4$var$getRectRelativeToOffsetParent","isOffsetParentAnElement","offsets","offsetRect","htmlOffset","$461947879dcdbcd4$export$722a64dea1b767dc","topLayer","clippingAncestors","$461947879dcdbcd4$var$getClippingElementAncestors","cache","cachedResult","get","$238ac70369f38756$export$3b57c1601291186b","list","traverseIframes","_node$ownerDocument2","scrollableAncestor","$238ac70369f38756$export$7cd01a57c8ca906c","isBody","concat","el","currentContainingBlockComputedStyle","elementIsFixed","computedStyle","currentNodeIsContaining","$461947879dcdbcd4$var$hasFixedPositionAncestor","stopNode","ancestor","set","_c","firstClippingAncestor","clippingRect","reduce","accRect","getClientRects","Array","from","$461947879dcdbcd4$export$cc800923e997bb8","_middlewareData$offse","_middlewareData$arrow","diffCoords","offset","arrow","alignmentOffset","$461947879dcdbcd4$export$fba63a578e423eb","checkMainAxis","checkCrossAxis","limiter","detectOverflowOptions","mainAxisCoord","crossAxisCoord","minSide","maxSide","limitedCoords","enabled","$461947879dcdbcd4$export$8a83211c878a3f1f","_middlewareData$flip","_middlewareData$flip2","_overflowsData$filter","_overflowsData$filter2","fallbackPlacements","specifiedFallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","flipAlignment","initialSideAxis","isBasePlacement","oppositePlacement","hasFallbackAxisSideDirection","push","$10310cf078d13212$var$getSideList","isStart","map","placements","overflows","overflowsData","flip","sides","mainAlignmentSide","every","nextIndex","index","nextPlacement","d","resetPlacement","sort","a","b","currentSideAxis","acc","$461947879dcdbcd4$export$48a53dcb22e581d0","Map","mergedOptions","platformWithCache","$48731e7e213a0ef5$var$hamburger","querySelector","$48731e7e213a0ef5$var$navMenu","$48731e7e213a0ef5$var$navLinks","querySelectorAll","$48731e7e213a0ef5$var$navbar","$48731e7e213a0ef5$var$backToTopBtn","$48731e7e213a0ef5$var$tooltip","$48731e7e213a0ef5$var$toggleMobileMenu","innerWidth","classList","toggle","contains","style","$48731e7e213a0ef5$var$closeMobileMenu","remove","$48731e7e213a0ef5$var$elementsWithTooltip","forEach","tooltipText","dataset","tooltip","showTooltip","textContent","add","then","assign","hideTooltip","addEventListener","e","preventDefault","scrollIntoView","behavior","stopPropagation","passive","link","setTimeout","target","key","touches","clientY","currentSectionId","sections","section","getAttribute","innerHeight","lastSection","$48731e7e213a0ef5$var$observer","IntersectionObserver","entries","entry","isIntersecting","spans","span","transitionDelay","opacity","transform","statNumbers","stat","parseInt","suffix","isNaN","$48731e7e213a0ef5$var$animateCounter","duration","increment","timer","setInterval","toString","clearInterval","floor","unobserve","threshold","rootMargin","$48731e7e213a0ef5$var$initTimelineAnimation","timelineItems","timelineObserver","item","observe","console","log","keys","animationDelay","neuralCanvas","getElementById","dataFlowCanvas","projectsCanvas","neural","dataFlow","projects","$48731e7e213a0ef5$var$initNeuralNetworkBackground","nodes","particles","impulses","canvas","error","ctx","getContext","mouse","clientX","time","resizeCanvas","nodeCount","random","vx","vy","baseRadius","pulseAngle","PI","color","energy","layer","processing","connections","lastImpulse","glowIntensity","otherNode","j","dist","sqrt","pow","life","maxLife","size","targetNode","animate","draw","clearRect","alpha","beginPath","arc","fillStyle","fill","particle","dx","dy","particleOpacityHex","pulseFactor","sin","currentRadius","mouseInfluence","distToMouse","visited","glowRadius","gradient","createRadialGradient","opacityHex1","opacityHex2","addColorStop","nodeOpacity","nodeOpacityHex","strokeStyle","lineWidth","stroke","impulse","splice","radius","impulseOpacityHex1","impulseOpacityHex2","connectionIndex","connectedNode","energyFlow","connectionOpacityHex1","connectionOpacityHex2","createLinearGradient","moveTo","lineTo","t","requestAnimationFrame","$48731e7e213a0ef5$var$initDataFlowBackground","buffer","dataChars","isSymbol","speed","type","symbol","pulse","waveOffset","corruption","bufferDelay","originalSymbol","delay","buff","font","textAlign","fillText","p","wave","finalOpacity","enhancedOpacity","lineOpacityHex","symbolOpacityHex","corruptX","corruptY","packetX","packetY","streamX","$48731e7e213a0ef5$var$initProjectsBackground","codeLines","commits","repositories","files","codeSnippets","fileNames","text","typingProgress","maxTypingProgress","fontSize","syntaxType","message","substr","activity","repo","otherRepo","modified","targetRepo","repoOpacity","repoOpacityHex","connectedRepo","file","fileGlowRadius","fileGradient","fileOpacity","fileOpacityHex","line","displayText","substring","cursor","commit","commitGlowRadius","commitGradient","commitOpacityHex","newCommit","randomFile","tooltipItems","hamburger","navMenu","navLinks","backToTopBtn","scrollTo","currentPage","location","pathname","pop","linkPage","navbar","$48731e7e213a0ef5$var$style","createElement","head","appendChild"],"version":3,"file":"portafolio-personale.e2cf03af.js.map"}