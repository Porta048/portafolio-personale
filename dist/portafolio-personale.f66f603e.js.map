{"mappings":"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","sources":["node_modules/@parcel/runtime-browser-hmr/lib/runtime-2bef15aabf680bf8.js","script.ts","node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.js","node_modules/@floating-ui/core/dist/floating-ui.core.esm.js","node_modules/@floating-ui/utils/dist/floating-ui.utils.esm.js","node_modules/@parcel/transformer-js/src/esmodule-helpers.js","node_modules/@floating-ui/utils/dom/floating-ui.utils.dom.esm.js"],"sourcesContent":["var HMR_HOST = null;var HMR_PORT = null;var HMR_SERVER_PORT = 1234;var HMR_SECURE = false;var HMR_ENV_HASH = \"439701173a9199ea\";var HMR_USE_SSE = false;module.bundle.HMR_BUNDLE_ID = \"4fce20e4f66f603e\";\"use strict\";\n\n/* global HMR_HOST, HMR_PORT, HMR_SERVER_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */\n/*::\nimport type {\n  HMRAsset,\n  HMRMessage,\n} from '@parcel/reporter-dev-server/src/HMRServer.js';\ninterface ParcelRequire {\n  (string): mixed;\n  cache: {|[string]: ParcelModule|};\n  hotData: {|[string]: mixed|};\n  Module: any;\n  parent: ?ParcelRequire;\n  isParcelRequire: true;\n  modules: {|[string]: [Function, {|[string]: string|}]|};\n  HMR_BUNDLE_ID: string;\n  root: ParcelRequire;\n}\ninterface ParcelModule {\n  hot: {|\n    data: mixed,\n    accept(cb: (Function) => void): void,\n    dispose(cb: (mixed) => void): void,\n    // accept(deps: Array<string> | string, cb: (Function) => void): void,\n    // decline(): void,\n    _acceptCallbacks: Array<(Function) => void>,\n    _disposeCallbacks: Array<(mixed) => void>,\n  |};\n}\ninterface ExtensionContext {\n  runtime: {|\n    reload(): void,\n    getURL(url: string): string;\n    getManifest(): {manifest_version: number, ...};\n  |};\n}\ndeclare var module: {bundle: ParcelRequire, ...};\ndeclare var HMR_HOST: string;\ndeclare var HMR_PORT: string;\ndeclare var HMR_SERVER_PORT: string;\ndeclare var HMR_ENV_HASH: string;\ndeclare var HMR_SECURE: boolean;\ndeclare var HMR_USE_SSE: boolean;\ndeclare var chrome: ExtensionContext;\ndeclare var browser: ExtensionContext;\ndeclare var __parcel__import__: (string) => Promise<void>;\ndeclare var __parcel__importScripts__: (string) => Promise<void>;\ndeclare var globalThis: typeof self;\ndeclare var ServiceWorkerGlobalScope: Object;\n*/\nvar OVERLAY_ID = '__parcel__error__overlay__';\nvar OldModule = module.bundle.Module;\nfunction Module(moduleName) {\n  OldModule.call(this, moduleName);\n  this.hot = {\n    data: module.bundle.hotData[moduleName],\n    _acceptCallbacks: [],\n    _disposeCallbacks: [],\n    accept: function (fn) {\n      this._acceptCallbacks.push(fn || function () {});\n    },\n    dispose: function (fn) {\n      this._disposeCallbacks.push(fn);\n    }\n  };\n  module.bundle.hotData[moduleName] = undefined;\n}\nmodule.bundle.Module = Module;\nmodule.bundle.hotData = {};\nvar checkedAssets /*: {|[string]: boolean|} */,\n  disposedAssets /*: {|[string]: boolean|} */,\n  assetsToDispose /*: Array<[ParcelRequire, string]> */,\n  assetsToAccept /*: Array<[ParcelRequire, string]> */,\n  bundleNotFound = false;\nfunction getHostname() {\n  return HMR_HOST || (typeof location !== 'undefined' && location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');\n}\nfunction getPort() {\n  return HMR_PORT || (typeof location !== 'undefined' ? location.port : HMR_SERVER_PORT);\n}\n\n// eslint-disable-next-line no-redeclare\nlet WebSocket = globalThis.WebSocket;\nif (!WebSocket && typeof module.bundle.root === 'function') {\n  try {\n    // eslint-disable-next-line no-global-assign\n    WebSocket = module.bundle.root('ws');\n  } catch {\n    // ignore.\n  }\n}\nvar hostname = getHostname();\nvar port = getPort();\nvar protocol = HMR_SECURE || typeof location !== 'undefined' && location.protocol === 'https:' && !['localhost', '127.0.0.1', '0.0.0.0'].includes(hostname) ? 'wss' : 'ws';\n\n// eslint-disable-next-line no-redeclare\nvar parent = module.bundle.parent;\nif (!parent || !parent.isParcelRequire) {\n  // Web extension context\n  var extCtx = typeof browser === 'undefined' ? typeof chrome === 'undefined' ? null : chrome : browser;\n\n  // Safari doesn't support sourceURL in error stacks.\n  // eval may also be disabled via CSP, so do a quick check.\n  var supportsSourceURL = false;\n  try {\n    (0, eval)('throw new Error(\"test\"); //# sourceURL=test.js');\n  } catch (err) {\n    supportsSourceURL = err.stack.includes('test.js');\n  }\n  var ws;\n  if (HMR_USE_SSE) {\n    ws = new EventSource('/__parcel_hmr');\n  } else {\n    try {\n      // If we're running in the dev server's node runner, listen for messages on the parent port.\n      let {\n        workerData,\n        parentPort\n      } = module.bundle.root('node:worker_threads') /*: any*/;\n      if (workerData !== null && workerData !== void 0 && workerData.__parcel) {\n        parentPort.on('message', async message => {\n          try {\n            await handleMessage(message);\n            parentPort.postMessage('updated');\n          } catch {\n            parentPort.postMessage('restart');\n          }\n        });\n\n        // After the bundle has finished running, notify the dev server that the HMR update is complete.\n        queueMicrotask(() => parentPort.postMessage('ready'));\n      }\n    } catch {\n      if (typeof WebSocket !== 'undefined') {\n        try {\n          ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');\n        } catch (err) {\n          // Ignore cloudflare workers error.\n          if (err.message && !err.message.includes('Disallowed operation called within global scope')) {\n            console.error(err.message);\n          }\n        }\n      }\n    }\n  }\n  if (ws) {\n    // $FlowFixMe\n    ws.onmessage = async function (event /*: {data: string, ...} */) {\n      var data /*: HMRMessage */ = JSON.parse(event.data);\n      await handleMessage(data);\n    };\n    if (ws instanceof WebSocket) {\n      ws.onerror = function (e) {\n        if (e.message) {\n          console.error(e.message);\n        }\n      };\n      ws.onclose = function () {\n        console.warn('[parcel] 🚨 Connection to the HMR server was lost');\n      };\n    }\n  }\n}\nasync function handleMessage(data /*: HMRMessage */) {\n  checkedAssets = {} /*: {|[string]: boolean|} */;\n  disposedAssets = {} /*: {|[string]: boolean|} */;\n  assetsToAccept = [];\n  assetsToDispose = [];\n  bundleNotFound = false;\n  if (data.type === 'reload') {\n    fullReload();\n  } else if (data.type === 'update') {\n    // Remove error overlay if there is one\n    if (typeof document !== 'undefined') {\n      removeErrorOverlay();\n    }\n    let assets = data.assets;\n\n    // Handle HMR Update\n    let handled = assets.every(asset => {\n      return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);\n    });\n\n    // Dispatch a custom event in case a bundle was not found. This might mean\n    // an asset on the server changed and we should reload the page. This event\n    // gives the client an opportunity to refresh without losing state\n    // (e.g. via React Server Components). If e.preventDefault() is not called,\n    // we will trigger a full page reload.\n    if (handled && bundleNotFound && assets.some(a => a.envHash !== HMR_ENV_HASH) && typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') {\n      handled = !window.dispatchEvent(new CustomEvent('parcelhmrreload', {\n        cancelable: true\n      }));\n    }\n    if (handled) {\n      console.clear();\n\n      // Dispatch custom event so other runtimes (e.g React Refresh) are aware.\n      if (typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') {\n        window.dispatchEvent(new CustomEvent('parcelhmraccept'));\n      }\n      await hmrApplyUpdates(assets);\n      hmrDisposeQueue();\n\n      // Run accept callbacks. This will also re-execute other disposed assets in topological order.\n      let processedAssets = {};\n      for (let i = 0; i < assetsToAccept.length; i++) {\n        let id = assetsToAccept[i][1];\n        if (!processedAssets[id]) {\n          hmrAccept(assetsToAccept[i][0], id);\n          processedAssets[id] = true;\n        }\n      }\n    } else fullReload();\n  }\n  if (data.type === 'error') {\n    // Log parcel errors to console\n    for (let ansiDiagnostic of data.diagnostics.ansi) {\n      let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;\n      console.error('🚨 [parcel]: ' + ansiDiagnostic.message + '\\n' + stack + '\\n\\n' + ansiDiagnostic.hints.join('\\n'));\n    }\n    if (typeof document !== 'undefined') {\n      // Render the fancy html overlay\n      removeErrorOverlay();\n      var overlay = createErrorOverlay(data.diagnostics.html);\n      // $FlowFixMe\n      document.body.appendChild(overlay);\n    }\n  }\n}\nfunction removeErrorOverlay() {\n  var overlay = document.getElementById(OVERLAY_ID);\n  if (overlay) {\n    overlay.remove();\n    console.log('[parcel] ✨ Error resolved');\n  }\n}\nfunction createErrorOverlay(diagnostics) {\n  var overlay = document.createElement('div');\n  overlay.id = OVERLAY_ID;\n  let errorHTML = '<div style=\"background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;\">';\n  for (let diagnostic of diagnostics) {\n    let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame) => {\n      return `${p}\n<a href=\"${protocol === 'wss' ? 'https' : 'http'}://${hostname}:${port}/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}\" style=\"text-decoration: underline; color: #888\" onclick=\"fetch(this.href); return false\">${frame.location}</a>\n${frame.code}`;\n    }, '') : diagnostic.stack;\n    errorHTML += `\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          🚨 ${diagnostic.message}\n        </div>\n        <pre>${stack}</pre>\n        <div>\n          ${diagnostic.hints.map(hint => '<div>💡 ' + hint + '</div>').join('')}\n        </div>\n        ${diagnostic.documentation ? `<div>📝 <a style=\"color: violet\" href=\"${diagnostic.documentation}\" target=\"_blank\">Learn more</a></div>` : ''}\n      </div>\n    `;\n  }\n  errorHTML += '</div>';\n  overlay.innerHTML = errorHTML;\n  return overlay;\n}\nfunction fullReload() {\n  if (typeof location !== 'undefined' && 'reload' in location) {\n    location.reload();\n  } else if (typeof extCtx !== 'undefined' && extCtx && extCtx.runtime && extCtx.runtime.reload) {\n    extCtx.runtime.reload();\n  } else {\n    try {\n      let {\n        workerData,\n        parentPort\n      } = module.bundle.root('node:worker_threads') /*: any*/;\n      if (workerData !== null && workerData !== void 0 && workerData.__parcel) {\n        parentPort.postMessage('restart');\n      }\n    } catch (err) {\n      console.error('[parcel] ⚠️ An HMR update was not accepted. Please restart the process.');\n    }\n  }\n}\nfunction getParents(bundle, id) /*: Array<[ParcelRequire, string]> */{\n  var modules = bundle.modules;\n  if (!modules) {\n    return [];\n  }\n  var parents = [];\n  var k, d, dep;\n  for (k in modules) {\n    for (d in modules[k][1]) {\n      dep = modules[k][1][d];\n      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {\n        parents.push([bundle, k]);\n      }\n    }\n  }\n  if (bundle.parent) {\n    parents = parents.concat(getParents(bundle.parent, id));\n  }\n  return parents;\n}\nfunction updateLink(link) {\n  var href = link.getAttribute('href');\n  if (!href) {\n    return;\n  }\n  var newLink = link.cloneNode();\n  newLink.onload = function () {\n    if (link.parentNode !== null) {\n      // $FlowFixMe\n      link.parentNode.removeChild(link);\n    }\n  };\n  newLink.setAttribute('href',\n  // $FlowFixMe\n  href.split('?')[0] + '?' + Date.now());\n  // $FlowFixMe\n  link.parentNode.insertBefore(newLink, link.nextSibling);\n}\nvar cssTimeout = null;\nfunction reloadCSS() {\n  if (cssTimeout || typeof document === 'undefined') {\n    return;\n  }\n  cssTimeout = setTimeout(function () {\n    var links = document.querySelectorAll('link[rel=\"stylesheet\"]');\n    for (var i = 0; i < links.length; i++) {\n      // $FlowFixMe[incompatible-type]\n      var href /*: string */ = links[i].getAttribute('href');\n      var hostname = getHostname();\n      var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\\\/\\\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());\n      var absolute = /^https?:\\/\\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;\n      if (!absolute) {\n        updateLink(links[i]);\n      }\n    }\n    cssTimeout = null;\n  }, 50);\n}\nfunction hmrDownload(asset) {\n  if (asset.type === 'js') {\n    if (typeof document !== 'undefined') {\n      let script = document.createElement('script');\n      script.src = asset.url + '?t=' + Date.now();\n      if (asset.outputFormat === 'esmodule') {\n        script.type = 'module';\n      }\n      return new Promise((resolve, reject) => {\n        var _document$head;\n        script.onload = () => resolve(script);\n        script.onerror = reject;\n        (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);\n      });\n    } else if (typeof importScripts === 'function') {\n      // Worker scripts\n      if (asset.outputFormat === 'esmodule') {\n        return __parcel__import__(asset.url + '?t=' + Date.now());\n      } else {\n        return new Promise((resolve, reject) => {\n          try {\n            __parcel__importScripts__(asset.url + '?t=' + Date.now());\n            resolve();\n          } catch (err) {\n            reject(err);\n          }\n        });\n      }\n    }\n  }\n}\nasync function hmrApplyUpdates(assets) {\n  global.parcelHotUpdate = Object.create(null);\n  let scriptsToRemove;\n  try {\n    // If sourceURL comments aren't supported in eval, we need to load\n    // the update from the dev server over HTTP so that stack traces\n    // are correct in errors/logs. This is much slower than eval, so\n    // we only do it if needed (currently just Safari).\n    // https://bugs.webkit.org/show_bug.cgi?id=137297\n    // This path is also taken if a CSP disallows eval.\n    if (!supportsSourceURL) {\n      let promises = assets.map(asset => {\n        var _hmrDownload;\n        return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch(err => {\n          // Web extension fix\n          if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != 'undefined' && global instanceof ServiceWorkerGlobalScope) {\n            extCtx.runtime.reload();\n            return;\n          }\n          throw err;\n        });\n      });\n      scriptsToRemove = await Promise.all(promises);\n    }\n    assets.forEach(function (asset) {\n      hmrApply(module.bundle.root, asset);\n    });\n  } finally {\n    delete global.parcelHotUpdate;\n    if (scriptsToRemove) {\n      scriptsToRemove.forEach(script => {\n        if (script) {\n          var _document$head2;\n          (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);\n        }\n      });\n    }\n  }\n}\nfunction hmrApply(bundle /*: ParcelRequire */, asset /*:  HMRAsset */) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (asset.type === 'css') {\n    reloadCSS();\n  } else if (asset.type === 'js') {\n    let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];\n    if (deps) {\n      if (modules[asset.id]) {\n        // Remove dependencies that are removed and will become orphaned.\n        // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.\n        let oldDeps = modules[asset.id][1];\n        for (let dep in oldDeps) {\n          if (!deps[dep] || deps[dep] !== oldDeps[dep]) {\n            let id = oldDeps[dep];\n            let parents = getParents(module.bundle.root, id);\n            if (parents.length === 1) {\n              hmrDelete(module.bundle.root, id);\n            }\n          }\n        }\n      }\n      if (supportsSourceURL) {\n        // Global eval. We would use `new Function` here but browser\n        // support for source maps is better with eval.\n        (0, eval)(asset.output);\n      }\n\n      // $FlowFixMe\n      let fn = global.parcelHotUpdate[asset.id];\n      modules[asset.id] = [fn, deps];\n    }\n\n    // Always traverse to the parent bundle, even if we already replaced the asset in this bundle.\n    // This is required in case modules are duplicated. We need to ensure all instances have the updated code.\n    if (bundle.parent) {\n      hmrApply(bundle.parent, asset);\n    }\n  }\n}\nfunction hmrDelete(bundle, id) {\n  let modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (modules[id]) {\n    // Collect dependencies that will become orphaned when this module is deleted.\n    let deps = modules[id][1];\n    let orphans = [];\n    for (let dep in deps) {\n      let parents = getParents(module.bundle.root, deps[dep]);\n      if (parents.length === 1) {\n        orphans.push(deps[dep]);\n      }\n    }\n\n    // Delete the module. This must be done before deleting dependencies in case of circular dependencies.\n    delete modules[id];\n    delete bundle.cache[id];\n\n    // Now delete the orphans.\n    orphans.forEach(id => {\n      hmrDelete(module.bundle.root, id);\n    });\n  } else if (bundle.parent) {\n    hmrDelete(bundle.parent, id);\n  }\n}\nfunction hmrAcceptCheck(bundle /*: ParcelRequire */, id /*: string */, depsByBundle /*: ?{ [string]: { [string]: string } }*/) {\n  checkedAssets = {};\n  if (hmrAcceptCheckOne(bundle, id, depsByBundle)) {\n    return true;\n  }\n\n  // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.\n  let parents = getParents(module.bundle.root, id);\n  let accepted = false;\n  while (parents.length > 0) {\n    let v = parents.shift();\n    let a = hmrAcceptCheckOne(v[0], v[1], null);\n    if (a) {\n      // If this parent accepts, stop traversing upward, but still consider siblings.\n      accepted = true;\n    } else if (a !== null) {\n      // Otherwise, queue the parents in the next level upward.\n      let p = getParents(module.bundle.root, v[1]);\n      if (p.length === 0) {\n        // If there are no parents, then we've reached an entry without accepting. Reload.\n        accepted = false;\n        break;\n      }\n      parents.push(...p);\n    }\n  }\n  return accepted;\n}\nfunction hmrAcceptCheckOne(bundle /*: ParcelRequire */, id /*: string */, depsByBundle /*: ?{ [string]: { [string]: string } }*/) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {\n    // If we reached the root bundle without finding where the asset should go,\n    // there's nothing to do. Mark as \"accepted\" so we don't reload the page.\n    if (!bundle.parent) {\n      bundleNotFound = true;\n      return true;\n    }\n    return hmrAcceptCheckOne(bundle.parent, id, depsByBundle);\n  }\n  if (checkedAssets[id]) {\n    return null;\n  }\n  checkedAssets[id] = true;\n  var cached = bundle.cache[id];\n  if (!cached) {\n    return true;\n  }\n  assetsToDispose.push([bundle, id]);\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    assetsToAccept.push([bundle, id]);\n    return true;\n  }\n  return false;\n}\nfunction hmrDisposeQueue() {\n  // Dispose all old assets.\n  for (let i = 0; i < assetsToDispose.length; i++) {\n    let id = assetsToDispose[i][1];\n    if (!disposedAssets[id]) {\n      hmrDispose(assetsToDispose[i][0], id);\n      disposedAssets[id] = true;\n    }\n  }\n  assetsToDispose = [];\n}\nfunction hmrDispose(bundle /*: ParcelRequire */, id /*: string */) {\n  var cached = bundle.cache[id];\n  bundle.hotData[id] = {};\n  if (cached && cached.hot) {\n    cached.hot.data = bundle.hotData[id];\n  }\n  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {\n    cached.hot._disposeCallbacks.forEach(function (cb) {\n      cb(bundle.hotData[id]);\n    });\n  }\n  delete bundle.cache[id];\n}\nfunction hmrAccept(bundle /*: ParcelRequire */, id /*: string */) {\n  // Execute the module.\n  bundle(id);\n\n  // Run the accept callbacks in the new version of the module.\n  var cached = bundle.cache[id];\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    let assetsToAlsoAccept = [];\n    cached.hot._acceptCallbacks.forEach(function (cb) {\n      let additionalAssets = cb(function () {\n        return getParents(module.bundle.root, id);\n      });\n      if (Array.isArray(additionalAssets) && additionalAssets.length) {\n        assetsToAlsoAccept.push(...additionalAssets);\n      }\n    });\n    if (assetsToAlsoAccept.length) {\n      let handled = assetsToAlsoAccept.every(function (a) {\n        return hmrAcceptCheck(a[0], a[1]);\n      });\n      if (!handled) {\n        return fullReload();\n      }\n      hmrDisposeQueue();\n    }\n  }\n}","import { computePosition, offset, shift, flip, arrow } from '@floating-ui/dom';\r\n\r\n// DOM Elements\r\nconst hamburger = document.querySelector<HTMLDivElement>('.hamburger');\r\nconst navMenu = document.querySelector<HTMLDivElement>('.nav-menu');\r\nconst navLinks = document.querySelectorAll<HTMLAnchorElement>('.nav-link');\r\nconst navbar = document.querySelector<HTMLElement>('.navbar');\r\nconst hero = document.querySelector<HTMLElement>('.hero');\r\n\r\n// Custom Cursor Logic\r\nconst backToTopBtn = document.querySelector<HTMLAnchorElement>('.back-to-top-btn');\r\nconst tooltip = document.querySelector<HTMLElement>('#tooltip');\r\n\r\n// Tooltip Logic\r\nconst elementsWithTooltip = document.querySelectorAll('[data-tooltip]');\r\n\r\nelementsWithTooltip.forEach(element => {\r\n    const reference = element as HTMLElement;\r\n    const tooltipText = reference.dataset.tooltip || '';\r\n\r\n    const showTooltip = () => {\r\n        if (!tooltip) return;\r\n        tooltip.textContent = tooltipText;\r\n        tooltip.classList.add('visible');\r\n\r\n        computePosition(reference, tooltip, {\r\n            placement: 'top',\r\n            middleware: [offset(8), flip(), shift({ padding: 5 })],\r\n        }).then(({ x, y }) => {\r\n            Object.assign(tooltip.style, {\r\n                left: `${x}px`,\r\n                top: `${y}px`,\r\n            });\r\n        });\r\n    };\r\n\r\n    const hideTooltip = () => {\r\n        if (tooltip) {\r\n            tooltip.classList.remove('visible');\r\n        }\r\n    };\r\n\r\n    reference.addEventListener('mouseenter', showTooltip);\r\n    reference.addEventListener('mouseleave', hideTooltip);\r\n    reference.addEventListener('focus', showTooltip);\r\n    reference.addEventListener('blur', hideTooltip);\r\n});\r\n\r\n// Back to Top Button Logic\r\nwindow.addEventListener('scroll', () => {\r\n    if (window.scrollY > 300) {\r\n        backToTopBtn?.classList.add('visible');\r\n    } else {\r\n        backToTopBtn?.classList.remove('visible');\r\n    }\r\n});\r\n\r\nbackToTopBtn?.addEventListener('click', (e) => {\r\n    e.preventDefault();\r\n    document.querySelector('#home')?.scrollIntoView({ behavior: 'smooth' });\r\n});\r\n\r\n// Mobile Navigation Toggle\r\nfunction toggleMobileMenu() {\r\n    // Only toggle mobile menu on devices with width <= 1024px\r\n    if (window.innerWidth <= 1024) {\r\n        hamburger?.classList.toggle('active');\r\n        navMenu?.classList.toggle('active');\r\n        \r\n        // Prevent body scroll when menu is open\r\n        if (navMenu?.classList.contains('active')) {\r\n            document.body.style.overflow = 'hidden';\r\n        } else {\r\n            document.body.style.overflow = 'auto';\r\n        }\r\n    }\r\n}\r\n\r\nfunction closeMobileMenu() {\r\n    // Only close mobile menu on devices where it might be active\r\n    if (window.innerWidth <= 1024) {\r\n        hamburger?.classList.remove('active');\r\n        navMenu?.classList.remove('active');\r\n        document.body.style.overflow = 'auto';\r\n    }\r\n}\r\n\r\nhamburger?.addEventListener('click', (e) => {\r\n    e.preventDefault();\r\n    e.stopPropagation();\r\n    toggleMobileMenu();\r\n});\r\n\r\n// Add touch support for mobile devices\r\nhamburger?.addEventListener('touchstart', (e) => {\r\n    e.preventDefault();\r\n    e.stopPropagation();\r\n}, { passive: false });\r\n\r\nhamburger?.addEventListener('touchend', (e) => {\r\n    e.preventDefault();\r\n    e.stopPropagation();\r\n    toggleMobileMenu();\r\n}, { passive: false });\r\n\r\n// Close mobile menu when clicking on a link\r\nnavLinks.forEach(link => {\r\n    link.addEventListener('click', closeMobileMenu);\r\n    \r\n    // Add touch support for navigation links\r\n    link.addEventListener('touchend', (e) => {\r\n        // Small delay to ensure smooth transition\r\n        setTimeout(closeMobileMenu, 100);\r\n    }, { passive: true });\r\n});\r\n\r\n// Close mobile menu when clicking outside\r\ndocument.addEventListener('click', (e) => {\r\n    const target = e.target as HTMLElement;\r\n    if (window.innerWidth <= 1024 && \r\n        navMenu?.classList.contains('active') && \r\n        !navMenu.contains(target) && \r\n        !hamburger?.contains(target)) {\r\n        closeMobileMenu();\r\n    }\r\n});\r\n\r\n// Close mobile menu when touching outside (mobile)\r\ndocument.addEventListener('touchstart', (e) => {\r\n    const target = e.target as HTMLElement;\r\n    if (window.innerWidth <= 1024 && \r\n        navMenu?.classList.contains('active') && \r\n        !navMenu.contains(target) && \r\n        !hamburger?.contains(target)) {\r\n        closeMobileMenu();\r\n    }\r\n}, { passive: true });\r\n\r\n// Handle window resize\r\nwindow.addEventListener('resize', () => {\r\n    if (window.innerWidth > 1024) {\r\n        closeMobileMenu();\r\n        // Ensure navbar is in correct state for desktop\r\n        document.body.style.overflow = 'auto';\r\n        hamburger?.classList.remove('active');\r\n        navMenu?.classList.remove('active');\r\n    }\r\n});\r\n\r\n// Handle escape key to close mobile menu\r\ndocument.addEventListener('keydown', (e) => {\r\n    if (e.key === 'Escape' && \r\n        window.innerWidth <= 1024 && \r\n        navMenu?.classList.contains('active')) {\r\n        closeMobileMenu();\r\n    }\r\n});\r\n\r\n// Prevent scrolling on mobile when menu is open\r\nlet startY = 0;\r\ndocument.addEventListener('touchstart', (e) => {\r\n    if (window.innerWidth <= 1024 && navMenu?.classList.contains('active')) {\r\n        startY = e.touches[0].clientY;\r\n    }\r\n}, { passive: true });\r\n\r\ndocument.addEventListener('touchmove', (e) => {\r\n    if (window.innerWidth <= 1024 && navMenu?.classList.contains('active')) {\r\n        const target = e.target as HTMLElement;\r\n        if (!navMenu.contains(target)) {\r\n            e.preventDefault();\r\n        }\r\n    }\r\n}, { passive: false });\r\n\r\n// Navbar Background on Scroll\r\nwindow.addEventListener('scroll', () => {\r\n    if (window.scrollY > 100) {\r\n        navbar?.classList.add('scrolled');\r\n    } else {\r\n        navbar?.classList.remove('scrolled');\r\n    }\r\n});\r\n\r\n// Active Navigation Link Highlighting\r\nwindow.addEventListener('scroll', () => {\r\n    const scrollY = window.scrollY;\r\n    let currentSectionId = \"\";\r\n\r\n    const sections = document.querySelectorAll<HTMLElement>('section[id]');\r\n\r\n    sections.forEach(section => {\r\n        const sectionTop = section.offsetTop - 85; // Offset per l'altezza della navbar + buffer\r\n\r\n        if (scrollY >= sectionTop) {\r\n            currentSectionId = section.getAttribute('id') || \"\";\r\n        }\r\n    });\r\n    \r\n    // Gestisce il caso in cui si arriva in fondo alla pagina\r\n    if ((window.innerHeight + window.scrollY) >= document.body.scrollHeight - 2) {\r\n        const lastSection = sections[sections.length - 1];\r\n        if (lastSection) {\r\n            currentSectionId = lastSection.getAttribute('id') || \"\";\r\n        }\r\n    }\r\n\r\n    navLinks.forEach(link => {\r\n        link.classList.remove('active');\r\n        if (link.getAttribute('href') === `#${currentSectionId}`) {\r\n            link.classList.add('active');\r\n        }\r\n    });\r\n});\r\n\r\n// Animated Counter for Stats\r\nfunction animateCounter(element: HTMLElement, target: number, duration: number = 2000, suffix: string = ''): void {\r\n    let start = 0;\r\n    const increment = target / (duration / 16);\r\n    const timer = setInterval(() => {\r\n        start += increment;\r\n        if (start >= target) {\r\n            element.textContent = target.toString() + suffix;\r\n            clearInterval(timer);\r\n        } else {\r\n            element.textContent = Math.floor(start).toString() + suffix;\r\n        }\r\n    }, 16);\r\n}\r\n\r\n// Intersection Observer for Animations\r\nconst observerOptions: IntersectionObserverInit = {\r\n    threshold: 0.1,\r\n    rootMargin: '0px 0px -50px 0px'\r\n};\r\n\r\nconst observer = new IntersectionObserver((entries: IntersectionObserverEntry[]) => {\r\n    entries.forEach(entry => {\r\n        if (entry.isIntersecting) {\r\n            entry.target.classList.add('animate');\r\n            \r\n            // Text animation for section headers\r\n            if (entry.target.classList.contains('section-header')) {\r\n                const spans = entry.target.querySelectorAll('h2 span, p span');\r\n                spans.forEach((span, index) => {\r\n                    (span as HTMLElement).style.transitionDelay = `${index * 0.03}s`;\r\n                    (span as HTMLElement).style.opacity = '1';\r\n                    (span as HTMLElement).style.transform = 'translateY(0) scale(1)';\r\n                });\r\n            }\r\n\r\n            // Animate counters when stats section is visible\r\n            if (entry.target.classList.contains('stats')) {\r\n                const statNumbers = entry.target.querySelectorAll<HTMLElement>('.stat h4');\r\n                statNumbers.forEach(stat => {\r\n                    const target = parseInt(stat.dataset.target || '0');\r\n                    const suffix = stat.dataset.suffix || '';\r\n                    if (!isNaN(target)) {\r\n                        animateCounter(stat, target, 2000, suffix);\r\n                    }\r\n                });\r\n                // Unobserve the stats section after animation to prevent re-triggering\r\n                observer.unobserve(entry.target);\r\n            }\r\n        }\r\n    });\r\n}, observerOptions);\r\n\r\nfunction calculateAge(birthDate: Date): number {\r\n    const today = new Date();\r\n    let age = today.getFullYear() - birthDate.getFullYear();\r\n    const m = today.getMonth() - birthDate.getMonth();\r\n    if (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) {\r\n        age--;\r\n    }\r\n    return age;\r\n}\r\n\r\n// Typing animation for hero text\r\nfunction typeWriter(element: HTMLElement, text: string, speed: number = 100): void {\r\n    let i = 0;\r\n    \r\n    function type() {\r\n        if (i < text.length) {\r\n            if(element) element.textContent += text.charAt(i);\r\n            i++;\r\n            setTimeout(type, speed);\r\n        }\r\n    }\r\n    \r\n    type();\r\n}\r\n\r\nfunction initInteractiveParticles(canvas: HTMLCanvasElement) {\r\n    const ctx = canvas.getContext('2d');\r\n    if (!ctx) return;\r\n\r\n    let width = canvas.offsetWidth;\r\n    let height = canvas.offsetHeight;\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n\r\n    const mouse = { x: width / 2, y: height / 2 };\r\n    canvas.addEventListener('mousemove', (event) => {\r\n        const rect = canvas.getBoundingClientRect();\r\n        mouse.x = event.clientX - rect.left;\r\n        mouse.y = event.clientY - rect.top;\r\n    });\r\n    \r\n    canvas.addEventListener('mouseleave', () => {\r\n        mouse.x = width / 2;\r\n        mouse.y = height / 2;\r\n    });\r\n\r\n    window.addEventListener('resize', () => {\r\n        width = canvas.offsetWidth;\r\n        height = canvas.offsetHeight;\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n    });\r\n\r\n    class Particle {\r\n        x: number;\r\n        y: number;\r\n        size: number;\r\n        speedX: number;\r\n        speedY: number;\r\n\r\n        constructor() {\r\n            this.x = Math.random() * width;\r\n            this.y = Math.random() * height;\r\n            this.size = Math.random() * 2 + 1;\r\n            this.speedX = (Math.random() * 2 - 1) * 0.5;\r\n            this.speedY = (Math.random() * 2 - 1) * 0.5;\r\n        }\r\n\r\n        update() {\r\n            this.x += this.speedX;\r\n            this.y += this.speedY;\r\n\r\n            // Interazione con il mouse\r\n            let dx = this.x - mouse.x;\r\n            let dy = this.y - mouse.y;\r\n            let distance = Math.sqrt(dx * dx + dy * dy);\r\n            if (distance < 100) {\r\n                 this.x += dx / distance * 2;\r\n                 this.y += dy / distance * 2;\r\n            }\r\n\r\n            // Mantieni le particelle all'interno dei bordi con un margine\r\n            const margin = 10;\r\n            if (this.x < margin) {\r\n                this.x = margin;\r\n                this.speedX = Math.abs(this.speedX);\r\n            }\r\n            if (this.x > width - margin) {\r\n                this.x = width - margin;\r\n                this.speedX = -Math.abs(this.speedX);\r\n            }\r\n            if (this.y < margin) {\r\n                this.y = margin;\r\n                this.speedY = Math.abs(this.speedY);\r\n            }\r\n            if (this.y > height - margin) {\r\n                this.y = height - margin;\r\n                this.speedY = -Math.abs(this.speedY);\r\n            }\r\n        }\r\n\r\n        draw() {\r\n            if (!ctx) return;\r\n            ctx.fillStyle = 'rgba(237, 242, 244, 0.8)';\r\n            ctx.beginPath();\r\n            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\r\n            ctx.fill();\r\n        }\r\n    }\r\n\r\n    let particlesArray: Particle[] = [];\r\n    function initParticles() {\r\n        particlesArray = [];\r\n        const numberOfParticles = 80;\r\n        for (let i = 0; i < numberOfParticles; i++) {\r\n            particlesArray.push(new Particle());\r\n        }\r\n    }\r\n    initParticles();\r\n\r\n    function handleParticles() {\r\n        for (let i = 0; i < particlesArray.length; i++) {\r\n            particlesArray[i].update();\r\n            particlesArray[i].draw();\r\n            for (let j = i; j < particlesArray.length; j++) {\r\n                const dx = particlesArray[i].x - particlesArray[j].x;\r\n                const dy = particlesArray[i].y - particlesArray[j].y;\r\n                const distance = Math.sqrt(dx * dx + dy * dy);\r\n                if (distance < 100) {\r\n                    if (!ctx) return;\r\n                    ctx.beginPath();\r\n                    ctx.strokeStyle = `rgba(248, 112, 96, ${1 - distance / 100})`;\r\n                    ctx.lineWidth = 0.5;\r\n                    ctx.moveTo(particlesArray[i].x, particlesArray[i].y);\r\n                    ctx.lineTo(particlesArray[j].x, particlesArray[j].y);\r\n                    ctx.stroke();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function animate() {\r\n        if (!ctx) return;\r\n        ctx.clearRect(0, 0, width, height);\r\n        handleParticles();\r\n        requestAnimationFrame(animate);\r\n    }\r\n    animate();\r\n}\r\n\r\nfunction initPlexusAnimation(canvas: HTMLCanvasElement) {\r\n    const ctx = canvas.getContext('2d');\r\n    if (!ctx) return;\r\n\r\n    let points: {x: number, y: number, vx: number, vy: number, impactRadius: number, impactOpacity: number}[] = [];\r\n    let snake: {x: number, y: number}[] = [];\r\n    let snakeTarget = 0;\r\n    const easing = 0.05; // Fattore di easing per un movimento più fluido\r\n\r\n    const setup = () => {\r\n        canvas.width = canvas.offsetWidth;\r\n        canvas.height = canvas.offsetHeight;\r\n        points = [];\r\n        const pointCount = Math.floor(canvas.width * canvas.height / 9000); // Leggermente meno punti\r\n\r\n        for (let i = 0; i < pointCount; i++) {\r\n            points.push({\r\n                x: Math.random() * canvas.width,\r\n                y: Math.random() * canvas.height,\r\n                vx: (Math.random() - 0.5) * 0.4, // Velocità leggermente ridotta\r\n                vy: (Math.random() - 0.5) * 0.4,\r\n                impactRadius: 0,\r\n                impactOpacity: 0\r\n            });\r\n        }\r\n\r\n        snake = [{ x: canvas.width / 2, y: canvas.height / 2 }];\r\n        for (let i = 1; i < 15; i++) { // Coda più lunga per un effetto più visibile\r\n            snake.push({\r\n                x: snake[0].x,\r\n                y: snake[0].y\r\n            });\r\n        }\r\n        findNewTarget();\r\n    };\r\n\r\n    const findNewTarget = () => {\r\n        let newTarget;\r\n        do {\r\n            newTarget = Math.floor(Math.random() * points.length);\r\n        } while (newTarget === snakeTarget);\r\n        snakeTarget = newTarget;\r\n    };\r\n\r\n    const updateSnake = () => {\r\n        if (points.length === 0 || !points[snakeTarget]) return;\r\n\r\n        const target = points[snakeTarget];\r\n        const head = snake[0];\r\n\r\n        const dx = target.x - head.x;\r\n        const dy = target.y - head.y;\r\n        const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n        if (distance < 10) {\r\n            // \"Colpito\" il target: crea effetto impatto\r\n            points[snakeTarget].impactRadius = 15;\r\n            points[snakeTarget].impactOpacity = 1;\r\n            findNewTarget();\r\n        } else {\r\n            // Muovi la testa con easing\r\n            head.x += dx * easing;\r\n            head.y += dy * easing;\r\n        }\r\n\r\n        // La coda segue la testa\r\n        for (let i = 1; i < snake.length; i++) {\r\n            const leader = snake[i - 1];\r\n            const segment = snake[i];\r\n            const segDx = leader.x - segment.x;\r\n            const segDy = leader.y - segment.y;\r\n            segment.x += segDx * 0.5; // La coda segue in modo più \"morbido\"\r\n            segment.y += segDy * 0.5;\r\n        }\r\n    };\r\n\r\n    const draw = () => {\r\n        if (!ctx) return;\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n        \r\n        // Disegna e aggiorna i punti e gli impatti\r\n        points.forEach(p => {\r\n            p.x += p.vx;\r\n            p.y += p.vy;\r\n\r\n            if (p.x < 0 || p.x > canvas.width) p.vx *= -1;\r\n            if (p.y < 0 || p.y > canvas.height) p.vy *= -1;\r\n            \r\n            ctx.beginPath();\r\n            ctx.fillStyle = 'rgba(248, 112, 96, 0.8)';\r\n            ctx.arc(p.x, p.y, 1.5, 0, Math.PI * 2);\r\n            ctx.fill();\r\n\r\n            // Disegna l'effetto impatto\r\n            if (p.impactRadius > 0) {\r\n                ctx.beginPath();\r\n                ctx.strokeStyle = `rgba(248, 112, 96, ${p.impactOpacity})`;\r\n                ctx.lineWidth = 2;\r\n                ctx.arc(p.x, p.y, p.impactRadius, 0, Math.PI * 2);\r\n                ctx.stroke();\r\n\r\n                p.impactRadius += 0.5; // L'onda si espande\r\n                p.impactOpacity -= 0.02; // E svanisce\r\n                if (p.impactOpacity <= 0) {\r\n                    p.impactRadius = 0;\r\n                    p.impactOpacity = 0;\r\n                }\r\n            }\r\n        });\r\n\r\n        // Disegna le connessioni tra punti (plexus)\r\n        for (let i = 0; i < points.length; i++) {\r\n            for (let j = i + 1; j < points.length; j++) {\r\n                const dist = Math.hypot(points[i].x - points[j].x, points[i].y - points[j].y);\r\n                if (dist < 100) { // Distanza di connessione ridotta\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(points[i].x, points[i].y);\r\n                    ctx.lineTo(points[j].x, points[j].y);\r\n                    ctx.lineWidth = (1 - dist / 100) * 0.4;\r\n                    ctx.strokeStyle = 'rgba(248, 112, 96, 0.2)';\r\n                    ctx.stroke();\r\n                }\r\n            }\r\n        }\r\n\r\n        updateSnake();\r\n        \r\n        // Disegna il proiettile (serpente)\r\n        for (let i = 0; i < snake.length; i++) {\r\n            const segment = snake[i];\r\n            const opacity = 1 - (i / snake.length) * 0.8;\r\n            const size = 5 - (i / snake.length) * 4; // La coda si restringe\r\n\r\n            ctx.beginPath();\r\n            ctx.fillStyle = `rgba(248, 112, 96, ${opacity})`;\r\n            ctx.arc(segment.x, segment.y, Math.max(1, size), 0, Math.PI * 2);\r\n            ctx.fill();\r\n        }\r\n\r\n        // Disegna un alone attorno al punto target\r\n        if (points[snakeTarget]) {\r\n            const target = points[snakeTarget];\r\n            ctx.beginPath();\r\n            ctx.strokeStyle = 'rgba(248, 112, 96, 0.5)';\r\n            ctx.lineWidth = 1;\r\n            ctx.arc(target.x, target.y, 10, 0, Math.PI * 2);\r\n            ctx.stroke();\r\n        }\r\n\r\n        requestAnimationFrame(draw);\r\n    };\r\n\r\n    let animationFrameId: number | null = null;\r\n    const projectsSection = document.getElementById('projects');\r\n\r\n    const plexusObserver = new IntersectionObserver((entries) => {\r\n        entries.forEach(entry => {\r\n            if (entry.isIntersecting) {\r\n                if (!animationFrameId) {\r\n                    setup();\r\n                    animationFrameId = requestAnimationFrame(draw);\r\n                }\r\n            } else {\r\n                if (animationFrameId) {\r\n                    cancelAnimationFrame(animationFrameId);\r\n                    animationFrameId = null;\r\n                }\r\n            }\r\n        });\r\n    }, { threshold: 0.1 });\r\n    \r\n    if (projectsSection) {\r\n        plexusObserver.observe(projectsSection);\r\n    }\r\n    window.addEventListener('resize', setup);\r\n}\r\n\r\nfunction initTechArt() {\r\n    const container = document.getElementById('tech-art-container');\r\n    if (!container) return;\r\n\r\n    const canvas = document.createElement('canvas');\r\n    container.appendChild(canvas);\r\n    const ctx = canvas.getContext('2d');\r\n\r\n    let width = container.clientWidth;\r\n    let height = container.clientHeight;\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n\r\n    const particles: TechParticle[] = [];\r\n    const particleCount = Math.min(Math.floor(width / 20), 30);\r\n    const maxDistance = 100;\r\n\r\n    class TechParticle {\r\n        x: number;\r\n        y: number;\r\n        size: number;\r\n        speedX: number;\r\n        speedY: number;\r\n\r\n        constructor() {\r\n            this.x = Math.random() * width;\r\n            this.y = Math.random() * height;\r\n            this.size = Math.random() * 2 + 1;\r\n            this.speedX = (Math.random() - 0.5) * 0.5;\r\n            this.speedY = (Math.random() - 0.5) * 0.5;\r\n        }\r\n\r\n        update() {\r\n            this.x += this.speedX;\r\n            this.y += this.speedY;\r\n            \r\n            // Mantieni le particelle all'interno dei bordi con un margine\r\n            const margin = 5;\r\n            if (this.x < margin) {\r\n                this.x = margin;\r\n                this.speedX = Math.abs(this.speedX);\r\n            }\r\n            if (this.x > width - margin) {\r\n                this.x = width - margin;\r\n                this.speedX = -Math.abs(this.speedX);\r\n            }\r\n            if (this.y < margin) {\r\n                this.y = margin;\r\n                this.speedY = Math.abs(this.speedY);\r\n            }\r\n            if (this.y > height - margin) {\r\n                this.y = height - margin;\r\n                this.speedY = -Math.abs(this.speedY);\r\n            }\r\n        }\r\n\r\n        draw() {\r\n            if (!ctx) return;\r\n            ctx.fillStyle = '#F87060';\r\n            ctx.beginPath();\r\n            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\r\n            ctx.fill();\r\n        }\r\n    }\r\n\r\n    function initParticles() {\r\n        particles.length = 0;\r\n        for (let i = 0; i < particleCount; i++) {\r\n            particles.push(new TechParticle());\r\n        }\r\n    }\r\n\r\n    function handleParticles() {\r\n        if (!ctx) return;\r\n        for (let i = 0; i < particles.length; i++) {\r\n            particles[i].update();\r\n            particles[i].draw();\r\n\r\n            for (let j = i + 1; j < particles.length; j++) {\r\n                const dx = particles[i].x - particles[j].x;\r\n                const dy = particles[i].y - particles[j].y;\r\n                const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n                if (distance < maxDistance) {\r\n                    ctx.beginPath();\r\n                    ctx.strokeStyle = `rgba(248, 112, 96, ${1 - distance / maxDistance})`;\r\n                    ctx.lineWidth = 0.5;\r\n                    ctx.moveTo(particles[i].x, particles[i].y);\r\n                    ctx.lineTo(particles[j].x, particles[j].y);\r\n                    ctx.stroke();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    function animate() {\r\n        if (!ctx) return;\r\n        ctx.clearRect(0, 0, width, height);\r\n        handleParticles();\r\n        requestAnimationFrame(animate);\r\n    }\r\n    \r\n    window.addEventListener('resize', () => {\r\n        width = container.clientWidth;\r\n        height = container.clientHeight;\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        initParticles();\r\n    });\r\n\r\n    initParticles();\r\n    animate();\r\n}\r\n\r\nfunction initSubtleBackground() {\r\n    const canvas = document.getElementById('matrix-canvas') as HTMLCanvasElement;\r\n    if (!canvas) return;\r\n    const ctx = canvas.getContext('2d');\r\n    if (!ctx) return;\r\n\r\n    let width = canvas.width = window.innerWidth;\r\n    let height = canvas.height = window.innerHeight;\r\n\r\n    interface FloatingDot {\r\n        x: number;\r\n        y: number;\r\n        size: number;\r\n        speedX: number;\r\n        speedY: number;\r\n        opacity: number;\r\n        pulseSpeed: number;\r\n        pulsePhase: number;\r\n    }\r\n\r\n    const dots: FloatingDot[] = [];\r\n    const dotCount = Math.floor((width * height) / 15000); // Densità molto bassa\r\n\r\n    // Inizializza i punti fluttuanti\r\n    for (let i = 0; i < dotCount; i++) {\r\n        dots.push({\r\n            x: Math.random() * width,\r\n            y: Math.random() * height,\r\n            size: Math.random() * 2 + 1,\r\n            speedX: (Math.random() - 0.5) * 0.2,\r\n            speedY: (Math.random() - 0.5) * 0.2,\r\n            opacity: Math.random() * 0.3 + 0.1,\r\n            pulseSpeed: Math.random() * 0.02 + 0.01,\r\n            pulsePhase: Math.random() * Math.PI * 2\r\n        });\r\n    }\r\n\r\n    function draw() {\r\n        if (!ctx) return;\r\n        ctx.clearRect(0, 0, width, height);\r\n\r\n        dots.forEach(dot => {\r\n            // Aggiorna posizione\r\n            dot.x += dot.speedX;\r\n            dot.y += dot.speedY;\r\n\r\n            // Rimbalzo sui bordi\r\n            if (dot.x < 0 || dot.x > width) dot.speedX *= -1;\r\n            if (dot.y < 0 || dot.y > height) dot.speedY *= -1;\r\n\r\n            // Effetto pulsazione\r\n            dot.pulsePhase += dot.pulseSpeed;\r\n            const pulseOpacity = dot.opacity * (0.5 + 0.5 * Math.sin(dot.pulsePhase));\r\n\r\n            // Disegna il punto con gradiente\r\n            const gradient = ctx.createRadialGradient(dot.x, dot.y, 0, dot.x, dot.y, dot.size * 3);\r\n            gradient.addColorStop(0, `rgba(248, 112, 96, ${pulseOpacity})`);\r\n            gradient.addColorStop(1, 'rgba(248, 112, 96, 0)');\r\n\r\n            ctx.fillStyle = gradient;\r\n            ctx.beginPath();\r\n            ctx.arc(dot.x, dot.y, dot.size * 3, 0, Math.PI * 2);\r\n            ctx.fill();\r\n        });\r\n\r\n        // Disegna connessioni sottili tra punti vicini\r\n        ctx.strokeStyle = 'rgba(248, 112, 96, 0.1)';\r\n        ctx.lineWidth = 0.5;\r\n        \r\n        for (let i = 0; i < dots.length; i++) {\r\n            for (let j = i + 1; j < dots.length; j++) {\r\n                const dx = dots[i].x - dots[j].x;\r\n                const dy = dots[i].y - dots[j].y;\r\n                const distance = Math.sqrt(dx * dx + dy * dy);\r\n                \r\n                if (distance < 150) {\r\n                    const opacity = (1 - distance / 150) * 0.1;\r\n                    ctx.strokeStyle = `rgba(248, 112, 96, ${opacity})`;\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(dots[i].x, dots[i].y);\r\n                    ctx.lineTo(dots[j].x, dots[j].y);\r\n                    ctx.stroke();\r\n                }\r\n            }\r\n        }\r\n\r\n        requestAnimationFrame(draw);\r\n    }\r\n\r\n    window.addEventListener('resize', () => {\r\n        width = canvas.width = window.innerWidth;\r\n        height = canvas.height = window.innerHeight;\r\n        \r\n        // Ricalcola il numero di punti in base alla nuova dimensione\r\n        const newDotCount = Math.floor((width * height) / 15000);\r\n        while (dots.length > newDotCount) {\r\n            dots.pop();\r\n        }\r\n        while (dots.length < newDotCount) {\r\n            dots.push({\r\n                x: Math.random() * width,\r\n                y: Math.random() * height,\r\n                size: Math.random() * 2 + 1,\r\n                speedX: (Math.random() - 0.5) * 0.2,\r\n                speedY: (Math.random() - 0.5) * 0.2,\r\n                opacity: Math.random() * 0.3 + 0.1,\r\n                pulseSpeed: Math.random() * 0.02 + 0.01,\r\n                pulsePhase: Math.random() * Math.PI * 2\r\n            });\r\n        }\r\n    });\r\n\r\n    draw();\r\n}\r\n\r\nfunction initTypingAnimation() {\r\n    const nameSpan = document.querySelector<HTMLElement>('.hero-text h1 .highlight');\r\n    if (nameSpan?.textContent) {\r\n        const textToType = nameSpan.textContent;\r\n        nameSpan.textContent = ''; \r\n        setTimeout(() => {\r\n            if (nameSpan) typeWriter(nameSpan, textToType, 100);\r\n        }, 1000); \r\n    }\r\n}\r\n\r\nfunction initHamburgerMenu() {\r\n    const hamburger = document.querySelector<HTMLDivElement>('.hamburger');\r\n    const navMenu = document.querySelector<HTMLDivElement>('.nav-menu');\r\n    const navLinks = document.querySelectorAll<HTMLAnchorElement>('.nav-link');\r\n    \r\n    hamburger?.addEventListener('click', () => {\r\n        hamburger.classList.toggle('active');\r\n        navMenu?.classList.toggle('active');\r\n    });\r\n\r\n    // Close mobile menu when clicking on a link\r\n    navLinks.forEach(link => {\r\n        link.addEventListener('click', () => {\r\n            hamburger?.classList.remove('active');\r\n            navMenu?.classList.remove('active');\r\n        });\r\n    });\r\n}\r\n\r\nfunction initNavbarActiveLink() {\r\n    const currentPage = window.location.pathname.split('/').pop() || 'index.html';\r\n    const navLinks = document.querySelectorAll<HTMLAnchorElement>('.nav-menu a');\r\n\r\n    navLinks.forEach(link => {\r\n        const linkPage = link.getAttribute('href');\r\n        if (linkPage === currentPage) {\r\n            link.classList.add('active');\r\n        }\r\n    });\r\n}\r\n\r\nfunction initNavbarScroll() {\r\n    const navbar = document.querySelector<HTMLElement>('.navbar');\r\n    \r\n    window.addEventListener('scroll', () => {\r\n        if (window.scrollY > 100) {\r\n            navbar?.classList.add('scrolled');\r\n        } else {\r\n            navbar?.classList.remove('scrolled');\r\n        }\r\n    });\r\n}\r\n\r\nfunction initScrollToTop() {\r\n    const backToTopBtn = document.getElementById('scrollToTopBtn');\r\n    if (!backToTopBtn) return;\r\n    \r\n    window.addEventListener('scroll', () => {\r\n        if (window.scrollY > 300) {\r\n            backToTopBtn.classList.add('visible');\r\n        } else {\r\n            backToTopBtn.classList.remove('visible');\r\n        }\r\n    });\r\n\r\n    backToTopBtn.addEventListener('click', (e) => {\r\n        e.preventDefault();\r\n        window.scrollTo({ top: 0, behavior: 'smooth' });\r\n    });\r\n}\r\n\r\nfunction initTooltips() {\r\n    const tooltipItems = document.querySelectorAll<HTMLElement>('[data-tooltip]');\r\n    const tooltip = document.getElementById('tooltip') as HTMLElement | null;\r\n    \r\n    if (tooltip && tooltipItems.length > 0) {\r\n        tooltipItems.forEach(item => {\r\n            const reference = item;\r\n            const tooltipText = reference.dataset.tooltip || '';\r\n\r\n            const showTooltip = () => {\r\n                tooltip.textContent = tooltipText;\r\n                tooltip.classList.add('visible');\r\n\r\n                computePosition(reference, tooltip, {\r\n                    placement: 'top',\r\n                    middleware: [offset(8), flip(), shift({ padding: 5 })],\r\n                }).then(({ x, y }) => {\r\n                    Object.assign(tooltip.style, {\r\n                        left: `${x}px`,\r\n                        top: `${y}px`,\r\n                    });\r\n                });\r\n            };\r\n\r\n            const hideTooltip = () => {\r\n                tooltip.classList.remove('visible');\r\n            };\r\n\r\n            reference.addEventListener('mouseenter', showTooltip);\r\n            reference.addEventListener('mouseleave', hideTooltip);\r\n            reference.addEventListener('focus', showTooltip);\r\n            reference.addEventListener('blur', hideTooltip);\r\n        });\r\n    }\r\n}\r\n\r\nfunction initKeyboardAnimation() {\r\n    // La logica per l'animazione della tastiera va qui se necessaria\r\n}\r\n\r\nfunction initStatsCounters() {\r\n    const observer = new IntersectionObserver((entries) => {\r\n        entries.forEach(entry => {\r\n            if (entry.isIntersecting) {\r\n                if (entry.target.matches('.stats')) {\r\n                     const statNumbers = entry.target.querySelectorAll<HTMLElement>('.stat h4');\r\n                     statNumbers.forEach(stat => {\r\n                         const target = parseInt(stat.dataset.target || '0', 10);\r\n                         const suffix = stat.dataset.suffix || '';\r\n                         animateCounter(stat, target, 2000, suffix);\r\n                     });\r\n                     observer.unobserve(entry.target);\r\n                }\r\n            }\r\n        });\r\n    }, { threshold: 0.1 });\r\n\r\n    const statsEl = document.querySelector('.stats');\r\n    if (statsEl) {\r\n        observer.observe(statsEl);\r\n    }\r\n}\r\n\r\nfunction initTimelineAnimation() {\r\n    const timelineItems = document.querySelectorAll('.timeline-item');\r\n    const stats = document.querySelectorAll('.stat');\r\n    const profilePhoto = document.querySelector('.profile-photo');\r\n    \r\n    const observer = new IntersectionObserver((entries) => {\r\n        entries.forEach(entry => {\r\n            if (entry.isIntersecting) {\r\n                entry.target.classList.add('visible');\r\n            }\r\n        });\r\n    }, { threshold: 0.1 });\r\n\r\n    // Osserva gli elementi della timeline\r\n    timelineItems.forEach(item => {\r\n        observer.observe(item);\r\n    });\r\n\r\n    // Osserva le statistiche\r\n    stats.forEach((stat, index) => {\r\n        observer.observe(stat);\r\n    });\r\n\r\n    // Osserva la foto del profilo\r\n    if (profilePhoto) {\r\n        observer.observe(profilePhoto);\r\n    }\r\n}\r\n\r\nfunction initAboutBackground() {\r\n    const aboutSection = document.querySelector('.about') as HTMLElement;\r\n    if (!aboutSection) return;\r\n\r\n    // Crea il canvas per le forme geometriche animate\r\n    const canvas = document.createElement('canvas');\r\n    canvas.style.position = 'absolute';\r\n    canvas.style.top = '0';\r\n    canvas.style.left = '0';\r\n    canvas.style.width = '100%';\r\n    canvas.style.height = '100%';\r\n    canvas.style.zIndex = '1';\r\n    canvas.style.pointerEvents = 'none';\r\n    canvas.style.opacity = '0.6';\r\n    \r\n    aboutSection.appendChild(canvas);\r\n    \r\n    const ctx = canvas.getContext('2d');\r\n    if (!ctx) return;\r\n\r\n    let width = aboutSection.offsetWidth;\r\n    let height = aboutSection.offsetHeight;\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n\r\n    interface FloatingShape {\r\n        x: number;\r\n        y: number;\r\n        size: number;\r\n        speedX: number;\r\n        speedY: number;\r\n        rotation: number;\r\n        rotationSpeed: number;\r\n        type: 'circle' | 'triangle' | 'square';\r\n        opacity: number;\r\n    }\r\n\r\n    const shapes: FloatingShape[] = [];\r\n    const shapeCount = 8;\r\n\r\n    // Inizializza le forme\r\n    for (let i = 0; i < shapeCount; i++) {\r\n        shapes.push({\r\n            x: Math.random() * width,\r\n            y: Math.random() * height,\r\n            size: Math.random() * 40 + 20,\r\n            speedX: (Math.random() - 0.5) * 0.3,\r\n            speedY: (Math.random() - 0.5) * 0.3,\r\n            rotation: Math.random() * Math.PI * 2,\r\n            rotationSpeed: (Math.random() - 0.5) * 0.01,\r\n            type: ['circle', 'triangle', 'square'][Math.floor(Math.random() * 3)] as 'circle' | 'triangle' | 'square',\r\n            opacity: Math.random() * 0.3 + 0.1\r\n        });\r\n    }\r\n\r\n    function drawShape(shape: FloatingShape) {\r\n        if (!ctx) return;\r\n        \r\n        ctx.save();\r\n        ctx.translate(shape.x, shape.y);\r\n        ctx.rotate(shape.rotation);\r\n        ctx.globalAlpha = shape.opacity;\r\n        \r\n        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, shape.size);\r\n        gradient.addColorStop(0, 'rgba(248, 112, 96, 0.3)');\r\n        gradient.addColorStop(1, 'rgba(248, 112, 96, 0)');\r\n        \r\n        ctx.fillStyle = gradient;\r\n        ctx.strokeStyle = 'rgba(248, 112, 96, 0.2)';\r\n        ctx.lineWidth = 1;\r\n\r\n        switch (shape.type) {\r\n            case 'circle':\r\n                ctx.beginPath();\r\n                ctx.arc(0, 0, shape.size / 2, 0, Math.PI * 2);\r\n                ctx.fill();\r\n                ctx.stroke();\r\n                break;\r\n            \r\n            case 'triangle':\r\n                ctx.beginPath();\r\n                ctx.moveTo(0, -shape.size / 2);\r\n                ctx.lineTo(-shape.size / 2, shape.size / 2);\r\n                ctx.lineTo(shape.size / 2, shape.size / 2);\r\n                ctx.closePath();\r\n                ctx.fill();\r\n                ctx.stroke();\r\n                break;\r\n            \r\n            case 'square':\r\n                ctx.fillRect(-shape.size / 2, -shape.size / 2, shape.size, shape.size);\r\n                ctx.strokeRect(-shape.size / 2, -shape.size / 2, shape.size, shape.size);\r\n                break;\r\n        }\r\n        \r\n        ctx.restore();\r\n    }\r\n\r\n    function updateShapes() {\r\n        shapes.forEach(shape => {\r\n            shape.x += shape.speedX;\r\n            shape.y += shape.speedY;\r\n            shape.rotation += shape.rotationSpeed;\r\n\r\n            // Rimbalzo sui bordi\r\n            if (shape.x < -shape.size || shape.x > width + shape.size) {\r\n                shape.speedX *= -1;\r\n            }\r\n            if (shape.y < -shape.size || shape.y > height + shape.size) {\r\n                shape.speedY *= -1;\r\n            }\r\n\r\n            // Mantieni le forme all'interno dell'area\r\n            shape.x = Math.max(-shape.size / 2, Math.min(width + shape.size / 2, shape.x));\r\n            shape.y = Math.max(-shape.size / 2, Math.min(height + shape.size / 2, shape.y));\r\n        });\r\n    }\r\n\r\n    function animate() {\r\n        if (!ctx) return;\r\n        ctx.clearRect(0, 0, width, height);\r\n        \r\n        updateShapes();\r\n        shapes.forEach(drawShape);\r\n        \r\n        requestAnimationFrame(animate);\r\n    }\r\n\r\n    // Gestisci il ridimensionamento\r\n    const resizeObserver = new ResizeObserver(() => {\r\n        width = aboutSection.offsetWidth;\r\n        height = aboutSection.offsetHeight;\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n    });\r\n    \r\n    resizeObserver.observe(aboutSection);\r\n    \r\n    // Avvia l'animazione solo quando la sezione è visibile\r\n    const intersectionObserver = new IntersectionObserver((entries) => {\r\n        entries.forEach(entry => {\r\n            if (entry.isIntersecting) {\r\n                animate();\r\n            }\r\n        });\r\n    }, { threshold: 0.1 });\r\n    \r\n    intersectionObserver.observe(aboutSection);\r\n}\r\n\r\nfunction initParallaxEffect() {\r\n    const parallaxElements = document.querySelectorAll('.profile-photo-container, .timeline-container');\r\n    \r\n    if (parallaxElements.length === 0) return;\r\n\r\n    const handleScroll = () => {\r\n        const scrollY = window.scrollY;\r\n        \r\n        parallaxElements.forEach(el => {\r\n            const element = el as HTMLElement;\r\n            const speed = parseFloat(element.dataset.parallaxSpeed || '0.1');\r\n            const offset = scrollY * speed;\r\n\r\n            element.style.transform = `translateY(${offset}px)`;\r\n        });\r\n    };\r\n\r\n    window.addEventListener('scroll', handleScroll, { passive: true });\r\n}\r\n\r\n/**\r\n * Initializes a neural network animation on a canvas.\r\n */\r\nfunction initNeuralNetworkBackground() {\r\n    const canvas = document.getElementById('neural-network-canvas') as HTMLCanvasElement;\r\n    if (!canvas) return;\r\n\r\n    const ctx = canvas.getContext('2d');\r\n    if (!ctx) return;\r\n\r\n    const mouse = { x: 0, y: 0 };\r\n    window.addEventListener('mousemove', e => {\r\n        mouse.x = e.clientX;\r\n        mouse.y = e.clientY;\r\n    });\r\n\r\n    let nodes: any[];\r\n\r\n    const resizeCanvas = () => {\r\n        canvas.width = window.innerWidth;\r\n        canvas.height = window.innerHeight;\r\n\r\n        nodes = [];\r\n        const nodeCount = window.innerWidth < 768 ? 40 : 80;\r\n        for (let i = 0; i < nodeCount; i++) {\r\n            nodes.push({\r\n                x: Math.random() * canvas.width,\r\n                y: Math.random() * canvas.height,\r\n                vx: (Math.random() - 0.5) * 0.5,\r\n                vy: (Math.random() - 0.5) * 0.5,\r\n                baseRadius: Math.random() * 1.5 + 1,\r\n                pulseAngle: Math.random() * Math.PI,\r\n            });\r\n        }\r\n    };\r\n\r\n    const draw = () => {\r\n        if (!ctx) return;\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n        nodes.forEach(node => {\r\n            node.x += node.vx;\r\n            node.y += node.vy;\r\n\r\n            if (node.x < 0 || node.x > canvas.width) node.vx *= -1;\r\n            if (node.y < 0 || node.y > canvas.height) node.vy *= -1;\r\n            \r\n            node.pulseAngle += 0.02;\r\n            const pulseFactor = (Math.sin(node.pulseAngle) + 1) / 2;\r\n            const currentRadius = node.baseRadius + pulseFactor * 1.5;\r\n\r\n            ctx.beginPath();\r\n            ctx.arc(node.x, node.y, currentRadius, 0, Math.PI * 2);\r\n            ctx.fillStyle = `rgba(255, 255, 255, ${0.6 + pulseFactor * 0.4})`;\r\n            ctx.fill();\r\n        });\r\n\r\n        for (let i = 0; i < nodes.length; i++) {\r\n            for (let j = i + 1; j < nodes.length; j++) {\r\n                const dist = Math.sqrt(Math.pow(nodes[i].x - nodes[j].x, 2) + Math.pow(nodes[i].y - nodes[j].y, 2));\r\n                \r\n                const distToMouse = Math.min(\r\n                    Math.sqrt(Math.pow(nodes[i].x - mouse.x, 2) + Math.pow(nodes[i].y - mouse.y, 2)),\r\n                    Math.sqrt(Math.pow(nodes[j].x - mouse.x, 2) + Math.pow(nodes[j].y - mouse.y, 2))\r\n                );\r\n\r\n                if (dist < 150) {\r\n                    let opacity = (1 - dist / 150) * 0.5;\r\n                    if (distToMouse < 100) {\r\n                        opacity = Math.min(1, opacity + (1 - distToMouse / 100) * 0.8);\r\n                    }\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(nodes[i].x, nodes[i].y);\r\n                    ctx.lineTo(nodes[j].x, nodes[j].y);\r\n                    ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;\r\n                    ctx.lineWidth = 0.5;\r\n                    ctx.stroke();\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    const animate = () => {\r\n        draw();\r\n        requestAnimationFrame(animate);\r\n    };\r\n\r\n    window.addEventListener('resize', resizeCanvas);\r\n    resizeCanvas();\r\n    animate();\r\n}\r\n\r\n/**\r\n * Initializes a data flow animation on a canvas.\r\n */\r\nfunction initDataFlowBackground() {\r\n    const canvas = document.getElementById('data-flow-canvas') as HTMLCanvasElement;\r\n    if (!canvas) return;\r\n\r\n    const ctx = canvas.getContext('2d');\r\n    if (!ctx) return;\r\n\r\n    let particles: any[];\r\n\r\n    const resizeCanvas = () => {\r\n        canvas.width = window.innerWidth;\r\n        canvas.height = window.innerHeight;\r\n\r\n        particles = [];\r\n        const particleCount = 300;\r\n        for (let i = 0; i < particleCount; i++) {\r\n            particles.push({\r\n                x: Math.random() * canvas.width,\r\n                y: Math.random() * canvas.height,\r\n                speed: Math.random() * 1 + 0.2,\r\n                size: Math.random() * 1.5 + 1,\r\n                length: Math.random() * 15 + 5,\r\n                opacity: Math.random() * 0.4 + 0.1,\r\n            });\r\n        }\r\n    };\r\n\r\n    const draw = () => {\r\n        if (!ctx) return;\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n        \r\n        particles.forEach(p => {\r\n            p.y -= p.speed;\r\n            if (p.y < -p.length) {\r\n                p.y = canvas.height;\r\n                p.x = Math.random() * canvas.width;\r\n            }\r\n            ctx.beginPath();\r\n            ctx.moveTo(p.x, p.y);\r\n            ctx.lineTo(p.x, p.y - p.length);\r\n            ctx.strokeStyle = `rgba(255, 255, 255, ${p.opacity})`;\r\n            ctx.lineWidth = p.size;\r\n            ctx.stroke();\r\n        });\r\n    };\r\n\r\n    const animate = () => {\r\n        draw();\r\n        requestAnimationFrame(animate);\r\n    };\r\n\r\n    window.addEventListener('resize', resizeCanvas);\r\n    resizeCanvas();\r\n    animate();\r\n}\r\n\r\n// Main initialization\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n    // Staggered fall-in animation for keyboard keys\r\n    const keys = document.querySelectorAll('.key');\r\n    keys.forEach((key, index) => {\r\n        (key as HTMLElement).style.animationDelay = `${index * 0.05}s`;\r\n    });\r\n\r\n    // Page-specific initializations\r\n    if (document.getElementById('neural-network-canvas')) {\r\n        initNeuralNetworkBackground();\r\n    }\r\n    if (document.getElementById('data-flow-canvas')) {\r\n        initDataFlowBackground();\r\n    }\r\n\r\n    initTooltips();\r\n    initHamburgerMenu();\r\n    initScrollToTop();\r\n    initTimelineAnimation();\r\n\r\n    // Funzioni comuni a tutte le pagine\r\n    initNavbarActiveLink();\r\n    initNavbarScroll();\r\n\r\n    // Funzioni specifiche per pagina\r\n    if (document.getElementById('matrix-canvas')) {\r\n        initSubtleBackground();\r\n    }\r\n    if (document.querySelector('.keyboard')) {\r\n        initKeyboardAnimation();\r\n    }\r\n    if (document.getElementById('tech-art-container')) {\r\n        initTechArt();\r\n    }\r\n    const plexusCanvas = document.getElementById('plexus-canvas') as HTMLCanvasElement;\r\n    if (plexusCanvas) {\r\n        initPlexusAnimation(plexusCanvas);\r\n    }\r\n    if (document.querySelector('.stats')) {\r\n        initStatsCounters();\r\n    }\r\n    if (document.querySelector('.hero-text h1 .highlight')) {\r\n        initTypingAnimation();\r\n    }\r\n    const interactiveCanvas = document.getElementById('interactive-particles-canvas') as HTMLCanvasElement;\r\n    if(interactiveCanvas) {\r\n        initInteractiveParticles(interactiveCanvas);\r\n    }\r\n    if (document.querySelector('.timeline')) {\r\n        initTimelineAnimation();\r\n    }\r\n    if (document.querySelector('.about')) {\r\n        initAboutBackground();\r\n    }\r\n    initParallaxEffect(); // Inizializza l'effetto parallasse\r\n\r\n    // Calculate and set age for the stat counter\r\n    const ageStatElement = document.getElementById('age-stat');\r\n    if (ageStatElement) {\r\n        const birthDate = new Date(2005, 6, 6); // 06/07/2005 (mese è 0-indexed)\r\n        const age = calculateAge(birthDate);\r\n        ageStatElement.dataset.target = age.toString();\r\n    }\r\n\r\n    // Calcolo Età per il testo\r\n    const ageText = document.getElementById('age-text');\r\n    if (ageText) {\r\n        const birthDate = new Date('2005-07-06'); // 06/07/2005\r\n        const today = new Date();\r\n        let age = today.getFullYear() - birthDate.getFullYear();\r\n        const m = today.getMonth() - birthDate.getMonth();\r\n        if (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) {\r\n            age--;\r\n        }\r\n        ageText.innerText = age.toString();\r\n    }\r\n\r\n    const animateElements = document.querySelectorAll('.about-content, .stats, .contact-content, .section-header');\r\n    animateElements.forEach(el => observer.observe(el));\r\n\r\n    // Project card hover effects\r\n    const projectCards = document.querySelectorAll<HTMLDivElement>('.project-card');\r\n    \r\n    projectCards.forEach(card => {\r\n        card.addEventListener('mouseenter', () => {\r\n            card.style.transform = 'translateY(-15px) scale(1.02)';\r\n        });\r\n        \r\n        card.addEventListener('mouseleave', () => {\r\n            card.style.transform = 'translateY(0) scale(1)';\r\n        });\r\n    });\r\n\r\n    // Skills cards animation\r\n    const skillCards = document.querySelectorAll<HTMLDivElement>('.skill-card');\r\n    \r\n    skillCards.forEach((card, index) => {\r\n        card.style.animationDelay = `${index * 0.1}s`;\r\n        \r\n        // Add hover effect\r\n        card.addEventListener('mouseenter', () => {\r\n            card.style.transform = 'translateY(-15px) rotateY(5deg)';\r\n        });\r\n        \r\n        card.addEventListener('mouseleave', () => {\r\n            card.style.transform = 'translateY(0) rotateY(0deg)';\r\n        });\r\n    });\r\n\r\n    // Update GitHub chart image source to prevent caching\r\n    if (window.location.pathname.endsWith('projects.html')) {\r\n        const chart = document.getElementById('github-chart') as HTMLImageElement;\r\n        if (chart) {\r\n            // Append a timestamp to the image URL to bypass the cache\r\n            const baseUrl = chart.src.split('?')[0];\r\n            chart.src = `${baseUrl}?t=${new Date().getTime()}`;\r\n        }\r\n    }\r\n});\r\n\r\n// Add CSS animations via JavaScript\r\nconst style = document.createElement('style');\r\nstyle.textContent = `\r\n    .navbar.scrolled {\r\n        background: rgba(16, 37, 66, 0.95) !important;\r\n        box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1) !important;\r\n    }\r\n    \r\n    .animate {\r\n        animation: fadeInUp 0.8s ease forwards;\r\n    }\r\n    \r\n    @keyframes fadeInUp {\r\n        from {\r\n            opacity: 0;\r\n            transform: translateY(30px);\r\n        }\r\n        to {\r\n            opacity: 1;\r\n            transform: translateY(0);\r\n        }\r\n    }\r\n    \r\n    .skill-card, .project-card {\r\n        opacity: 0;\r\n        transform: translateY(30px);\r\n        transition: all 0.6s ease;\r\n    }\r\n    \r\n    .skill-card.animate, .project-card.animate {\r\n        opacity: 1;\r\n        transform: translateY(0);\r\n    }\r\n    \r\n    .notification-content {\r\n        display: flex;\r\n        align-items: center;\r\n        justify-content: space-between;\r\n        gap: 1rem;\r\n    }\r\n    \r\n    .notification-close {\r\n        background: none;\r\n        border: none;\r\n        color: white;\r\n        font-size: 1.5rem;\r\n        cursor: pointer;\r\n        padding: 0;\r\n        width: 24px;\r\n        height: 24px;\r\n        display: flex;\r\n        align-items: center;\r\n        justify-content: center;\r\n    }\r\n    \r\n    .nav-link.active {\r\n        color: #F87060 !important;\r\n    }\r\n    \r\n    .nav-link.active::after {\r\n        width: 100% !important;\r\n    }\r\n`;\r\n\r\ndocument.head.appendChild(style);","import { rectToClientRect, arrow as arrow$1, autoPlacement as autoPlacement$1, detectOverflow as detectOverflow$1, flip as flip$1, hide as hide$1, inline as inline$1, limitShift as limitShift$1, offset as offset$1, shift as shift$1, size as size$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getFrameElement, getNodeScroll, getDocumentElement, isTopLayer, getNodeName, isOverflowElement, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\n\nfunction getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {\n  if (ignoreScrollbarX === void 0) {\n    ignoreScrollbarX = false;\n  }\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 :\n  // RTL <body> scrollbar.\n  getWindowScrollBarX(documentElement, htmlRect));\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nconst absoluteOrFixed = /*#__PURE__*/new Set(['absolute', 'fixed']);\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n\n  // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n  // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n  function setLeftRTLScrollbarOffset() {\n    offsets.x = getWindowScrollBarX(documentElement);\n  }\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      setLeftRTLScrollbarOffset();\n    }\n  }\n  if (isFixed && !isOffsetParentAnElement && documentElement) {\n    setLeftRTLScrollbarOffset();\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n\n  // Firefox returns the <html> element as the offsetParent if it's non-static,\n  // while Chrome and Safari return the <body> element. The <body> element must\n  // be used to perform the correct calculations even if the <html> element is\n  // non-static.\n  if (getDocumentElement(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\nfunction rectsAreEqual(a, b) {\n  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n}\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = elementRectForRootMargin;\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n        // It's possible that even though the ratio is reported as 1, the\n        // element is not actually fully within the IntersectionObserver's root\n        // area anymore. This can happen under performance constraints. This may\n        // be a bug in the browser's IntersectionObserver implementation. To\n        // work around this, we compare the element's bounding rect now with\n        // what it was at the time we created the IntersectionObserver. If they\n        // are not equal then the element moved, so we refresh.\n        refresh();\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (_e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          const ignoreCrossAxisOverflow = checkCrossAxis === 'alignment' ? initialSideAxis !== getSideAxis(nextPlacement) : false;\n          if (!ignoreCrossAxisOverflow ||\n          // We leave the current main axis only if every placement on that axis\n          // overflows the main axis.\n          overflowsData.every(d => d.overflows[0] > 0 && getSideAxis(d.placement) === initialSideAxis)) {\n            // Try next placement and re-run the lifecycle.\n            return {\n              data: {\n                index: nextIndex,\n                overflows: overflowsData\n              },\n              reset: {\n                placement: nextPlacement\n              }\n            };\n          }\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nconst originSides = /*#__PURE__*/new Set(['left', 'top']);\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = originSides.has(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = originSides.has(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n        availableWidth = maximumClippingWidth;\n      }\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nconst yAxisSides = /*#__PURE__*/new Set(['top', 'bottom']);\nfunction getSideAxis(placement) {\n  return yAxisSides.has(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nconst lrPlacement = ['left', 'right'];\nconst rlPlacement = ['right', 'left'];\nconst tbPlacement = ['top', 'bottom'];\nconst btPlacement = ['bottom', 'top'];\nfunction getSideList(side, isStart, rtl) {\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rlPlacement : lrPlacement;\n      return isStart ? lrPlacement : rlPlacement;\n    case 'left':\n    case 'right':\n      return isStart ? tbPlacement : btPlacement;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","exports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {default: a};\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (\n      key === 'default' ||\n      key === '__esModule' ||\n      Object.prototype.hasOwnProperty.call(dest, key)\n    ) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get,\n  });\n};\n","function hasWindow() {\n  return typeof window !== 'undefined';\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nconst invalidOverflowDisplayValues = /*#__PURE__*/new Set(['inline', 'contents']);\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);\n}\nconst tableElements = /*#__PURE__*/new Set(['table', 'td', 'th']);\nfunction isTableElement(element) {\n  return tableElements.has(getNodeName(element));\n}\nconst topLayerSelectors = [':popover-open', ':modal'];\nfunction isTopLayer(element) {\n  return topLayerSelectors.some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (_e) {\n      return false;\n    }\n  });\n}\nconst transformProperties = ['transform', 'translate', 'scale', 'rotate', 'perspective'];\nconst willChangeValues = ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'];\nconst containValues = ['paint', 'layout', 'strict', 'content'];\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  // https://drafts.csswg.org/css-transforms-2/#individual-transforms\n  return transformProperties.some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || willChangeValues.some(value => (css.willChange || '').includes(value)) || containValues.some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nconst lastTraversableNodeNames = /*#__PURE__*/new Set(['html', 'body', '#document']);\nfunction isLastTraversableNode(node) {\n  return lastTraversableNodeNames.has(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getFrameElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\n"],"names":[],"version":3,"file":"portafolio-personale.f66f603e.js.map","sourceRoot":"/__parcel_source_root/"}